{"2.1.3": ".. _whatsnew_213:\n\nWhat's new in 2.1.3 (November 10, 2023)\n---------------------------------------\n\nThese are the changes in pandas 2.1.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_213.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed infinite recursion from operations that return a new object on some DataFrame subclasses (:issue:`55763`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_213.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :meth:`DatetimeIndex.diff` raising ``TypeError`` (:issue:`55080`)\n- Bug in :meth:`Index.isin` raising for Arrow backed string and ``None`` value (:issue:`55821`)\n- Fix :func:`read_parquet` and :func:`read_feather` for `CVE-2023-47248 <https://www.cve.org/CVERecord?id=CVE-2023-47248>`__ (:issue:`55894`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_213.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.1.2..v2.1.3|HEAD\n", "1.2.4": ".. _whatsnew_124:\n\nWhat's new in 1.2.4 (April 12, 2021)\n------------------------------------\n\nThese are the changes in pandas 1.2.4. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_124.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n\n- Fixed regression in :meth:`DataFrame.sum` when ``min_count`` greater than the :class:`DataFrame` shape was passed resulted in a ``ValueError`` (:issue:`39738`)\n- Fixed regression in :meth:`DataFrame.to_json` raising ``AttributeError`` when run on PyPy (:issue:`39837`)\n- Fixed regression in (in)equality comparison of ``pd.NaT`` with a non-datetimelike numpy array returning a scalar instead of an array (:issue:`40722`)\n- Fixed regression in :meth:`DataFrame.where` not returning a copy in the case of an all True condition (:issue:`39595`)\n- Fixed regression in :meth:`DataFrame.replace` raising ``IndexError`` when ``regex`` was a multi-key dictionary (:issue:`39338`)\n- Fixed regression in repr of floats in an ``object`` column not respecting ``float_format`` when printed in the console or outputted through :meth:`DataFrame.to_string`, :meth:`DataFrame.to_html`, and :meth:`DataFrame.to_latex` (:issue:`40024`)\n- Fixed regression in NumPy ufuncs such as ``np.add`` not passing through all arguments for :class:`DataFrame` (:issue:`40662`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_124.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.2.3..v1.2.4\n", "1.3.5": ".. _whatsnew_135:\n\nWhat's new in 1.3.5 (December 12, 2021)\n---------------------------------------\n\nThese are the changes in pandas 1.3.5. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_135.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`Series.equals` when comparing floats with dtype object to None (:issue:`44190`)\n- Fixed regression in :func:`merge_asof` raising error when array was supplied as join key (:issue:`42844`)\n- Fixed regression when resampling :class:`DataFrame` with :class:`DateTimeIndex` with empty groups and ``uint8``, ``uint16`` or ``uint32`` columns incorrectly raising ``RuntimeError`` (:issue:`43329`)\n- Fixed regression in creating a :class:`DataFrame` from a timezone-aware :class:`Timestamp` scalar near a Daylight Savings Time transition (:issue:`42505`)\n- Fixed performance regression in :func:`read_csv` (:issue:`44106`)\n- Fixed regression in :meth:`Series.duplicated` and :meth:`Series.drop_duplicates` when Series has :class:`Categorical` dtype with boolean categories (:issue:`44351`)\n- Fixed regression in :meth:`.DataFrameGroupBy.sum` and :meth:`.SeriesGroupBy.sum` with ``timedelta64[ns]`` dtype containing ``NaT`` failing to treat that value as NA (:issue:`42659`)\n- Fixed regression in :meth:`.RollingGroupby.cov` and :meth:`.RollingGroupby.corr` when ``other`` had the same shape as each group would incorrectly return superfluous groups in the result (:issue:`42915`)\n\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_135.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.3.4..v1.3.5|HEAD\n", "1.0.3": "\n.. _whatsnew_103:\n\nWhat's new in 1.0.3 (March 17, 2020)\n------------------------------------\n\nThese are the changes in pandas 1.0.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_103.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in ``resample.agg`` when the underlying data is non-writeable (:issue:`31710`)\n- Fixed regression in :class:`DataFrame` exponentiation with reindexing (:issue:`32685`)\n\n.. _whatsnew_103.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.0.2..v1.0.3\n", "0.1": ".. _whatsnew_0152:\n\nVersion 0.15.2 (December 12, 2014)\n----------------------------------\n\n{{ header }}\n\n\nThis is a minor release from 0.15.1 and includes a large number of bug fixes\nalong with several new features, enhancements, and performance improvements.\nA small number of API changes were necessary to fix existing bugs.\nWe recommend that all users upgrade to this version.\n\n- :ref:`Enhancements <whatsnew_0152.enhancements>`\n- :ref:`API Changes <whatsnew_0152.api>`\n- :ref:`Performance Improvements <whatsnew_0152.performance>`\n- :ref:`Bug Fixes <whatsnew_0152.bug_fixes>`\n\n.. _whatsnew_0152.api:\n\nAPI changes\n~~~~~~~~~~~\n\n- Indexing in ``MultiIndex`` beyond lex-sort depth is now supported, though\n  a lexically sorted index will have a better performance. (:issue:`2646`)\n\n  .. code-block:: ipython\n\n    In [1]: df = pd.DataFrame({'jim':[0, 0, 1, 1],\n       ...:                    'joe':['x', 'x', 'z', 'y'],\n       ...:                    'jolie':np.random.rand(4)}).set_index(['jim', 'joe'])\n       ...:\n\n    In [2]: df\n    Out[2]:\n                jolie\n    jim joe\n    0   x    0.126970\n        x    0.966718\n    1   z    0.260476\n        y    0.897237\n\n    [4 rows x 1 columns]\n\n    In [3]: df.index.lexsort_depth\n    Out[3]: 1\n\n    # in prior versions this would raise a KeyError\n    # will now show a PerformanceWarning\n    In [4]: df.loc[(1, 'z')]\n    Out[4]:\n                jolie\n    jim joe\n    1   z    0.260476\n\n    [1 rows x 1 columns]\n\n    # lexically sorting\n    In [5]: df2 = df.sort_index()\n\n    In [6]: df2\n    Out[6]:\n                jolie\n    jim joe\n    0   x    0.126970\n        x    0.966718\n    1   y    0.897237\n        z    0.260476\n\n    [4 rows x 1 columns]\n\n    In [7]: df2.index.lexsort_depth\n    Out[7]: 2\n\n    In [8]: df2.loc[(1,'z')]\n    Out[8]:\n                jolie\n    jim joe\n    1   z    0.260476\n\n    [1 rows x 1 columns]\n\n- Bug in unique of Series with ``category`` dtype, which returned all categories regardless\n  whether they were \"used\" or not (see :issue:`8559` for the discussion).\n  Previous behaviour was to return all categories:\n\n  .. code-block:: ipython\n\n    In [3]: cat = pd.Categorical(['a', 'b', 'a'], categories=['a', 'b', 'c'])\n\n    In [4]: cat\n    Out[4]:\n    [a, b, a]\n    Categories (3, object): [a < b < c]\n\n    In [5]: cat.unique()\n    Out[5]: array(['a', 'b', 'c'], dtype=object)\n\n  Now, only the categories that do effectively occur in the array are returned:\n\n  .. ipython:: python\n\n    cat = pd.Categorical(['a', 'b', 'a'], categories=['a', 'b', 'c'])\n    cat.unique()\n\n- ``Series.all`` and ``Series.any`` now support the ``level`` and ``skipna`` parameters. ``Series.all``, ``Series.any``, ``Index.all``, and ``Index.any`` no longer support the ``out`` and ``keepdims`` parameters, which existed for compatibility with ndarray. Various index types no longer support the ``all`` and ``any`` aggregation functions and will now raise ``TypeError``. (:issue:`8302`).\n\n- Allow equality comparisons of Series with a categorical dtype and object dtype; previously these would raise ``TypeError`` (:issue:`8938`)\n\n- Bug in ``NDFrame``: conflicting attribute/column names now behave consistently between getting and setting. Previously, when both a column and attribute named ``y`` existed, ``data.y`` would return the attribute, while ``data.y = z`` would update the column (:issue:`8994`)\n\n  .. ipython:: python\n\n     data = pd.DataFrame({'x': [1, 2, 3]})\n     data.y = 2\n     data['y'] = [2, 4, 6]\n     data\n\n     # this assignment was inconsistent\n     data.y = 5\n\n  Old behavior:\n\n  .. code-block:: ipython\n\n     In [6]: data.y\n     Out[6]: 2\n\n     In [7]: data['y'].values\n     Out[7]: array([5, 5, 5])\n\n  New behavior:\n\n  .. ipython:: python\n\n     data.y\n     data['y'].values\n\n- ``Timestamp('now')`` is now equivalent to ``Timestamp.now()`` in that it returns the local time rather than UTC. Also, ``Timestamp('today')`` is now equivalent to ``Timestamp.today()`` and both have ``tz`` as a possible argument. (:issue:`9000`)\n\n- Fix negative step support for label-based slices (:issue:`8753`)\n\n  Old behavior:\n\n  .. code-block:: ipython\n\n     In [1]: s = pd.Series(np.arange(3), ['a', 'b', 'c'])\n     Out[1]:\n     a    0\n     b    1\n     c    2\n     dtype: int64\n\n     In [2]: s.loc['c':'a':-1]\n     Out[2]:\n     c    2\n     dtype: int64\n\n  New behavior:\n\n  .. ipython:: python\n\n     s = pd.Series(np.arange(3), ['a', 'b', 'c'])\n     s.loc['c':'a':-1]\n\n\n.. _whatsnew_0152.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n\n``Categorical`` enhancements:\n\n- Added ability to export Categorical data to Stata (:issue:`8633`).  See :ref:`here <io.stata-categorical>` for limitations of categorical variables exported to Stata data files.\n- Added flag ``order_categoricals`` to ``StataReader`` and ``read_stata`` to select whether to order imported categorical data (:issue:`8836`).  See :ref:`here <io.stata-categorical>` for more information on importing categorical variables from Stata data files.\n- Added ability to export Categorical data to/from HDF5 (:issue:`7621`). Queries work the same as if it was an object array. However, the ``category`` dtyped data is stored in a more efficient manner. See :ref:`here <io.hdf5-categorical>` for an example and caveats w.r.t. prior versions of pandas.\n- Added support for ``searchsorted()`` on ``Categorical`` class (:issue:`8420`).\n\nOther enhancements:\n\n- Added the ability to specify the SQL type of columns when writing a DataFrame\n  to a database (:issue:`8778`).\n  For example, specifying to use the sqlalchemy ``String`` type instead of the\n  default ``Text`` type for string columns:\n\n  .. code-block:: python\n\n     from sqlalchemy.types import String\n     data.to_sql('data_dtype', engine, dtype={'Col_1': String})  # noqa F821\n\n- ``Series.all`` and ``Series.any`` now support the ``level`` and ``skipna`` parameters (:issue:`8302`):\n\n  .. code-block:: python\n\n     >>> s = pd.Series([False, True, False], index=[0, 0, 1])\n     >>> s.any(level=0)\n     0     True\n     1    False\n     dtype: bool\n\n- ``Panel`` now supports the ``all`` and ``any`` aggregation functions. (:issue:`8302`):\n\n  .. code-block:: python\n\n     >>> p = pd.Panel(np.random.rand(2, 5, 4) > 0.1)\n     >>> p.all()\n            0      1      2     3\n     0   True   True   True  True\n     1   True  False   True  True\n     2   True   True   True  True\n     3  False   True  False  True\n     4   True   True   True  True\n\n- Added support for ``utcfromtimestamp()``, ``fromtimestamp()``, and ``combine()`` on ``Timestamp`` class (:issue:`5351`).\n- Added Google Analytics (`pandas.io.ga`) basic documentation (:issue:`8835`). See `here <https://pandas.pydata.org/pandas-docs/version/0.15.2/remote_data.html#remote-data-ga>`__.\n- ``Timedelta`` arithmetic returns ``NotImplemented`` in unknown cases, allowing extensions by custom classes (:issue:`8813`).\n- ``Timedelta`` now supports arithmetic with ``numpy.ndarray`` objects of the appropriate dtype (numpy 1.8 or newer only) (:issue:`8884`).\n- Added ``Timedelta.to_timedelta64()`` method to the public API (:issue:`8884`).\n- Added ``gbq.generate_bq_schema()`` function to the gbq module (:issue:`8325`).\n- ``Series`` now works with map objects the same way as generators (:issue:`8909`).\n- Added context manager to ``HDFStore`` for automatic closing (:issue:`8791`).\n- ``to_datetime`` gains an ``exact`` keyword to allow for a format to not require an exact match for a provided format string (if its ``False``). ``exact`` defaults to ``True`` (meaning that exact matching is still the default)  (:issue:`8904`)\n- Added ``axvlines`` boolean option to parallel_coordinates plot function, determines whether vertical lines will be printed, default is True\n- Added ability to read table footers to read_html (:issue:`8552`)\n- ``to_sql`` now infers data types of non-NA values for columns that contain NA values and have dtype ``object`` (:issue:`8778`).\n\n\n.. _whatsnew_0152.performance:\n\nPerformance\n~~~~~~~~~~~\n\n- Reduce memory usage when skiprows is an integer in read_csv (:issue:`8681`)\n- Performance boost for ``to_datetime`` conversions with a passed ``format=``, and the ``exact=False`` (:issue:`8904`)\n\n\n.. _whatsnew_0152.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\n- Bug in concat of Series with ``category`` dtype which were coercing to ``object``. (:issue:`8641`)\n- Bug in Timestamp-Timestamp not returning a Timedelta type and datelike-datelike ops with timezones (:issue:`8865`)\n- Made consistent a timezone mismatch exception (either tz operated with None or incompatible timezone), will now return ``TypeError`` rather than ``ValueError`` (a couple of edge cases only), (:issue:`8865`)\n- Bug in using a ``pd.Grouper(key=...)`` with no level/axis or level only (:issue:`8795`, :issue:`8866`)\n- Report a ``TypeError`` when invalid/no parameters are passed in a groupby (:issue:`8015`)\n- Bug in packaging pandas with ``py2app/cx_Freeze`` (:issue:`8602`, :issue:`8831`)\n- Bug in ``groupby`` signatures that didn't include \\*args or \\*\\*kwargs (:issue:`8733`).\n- ``io.data.Options`` now raises ``RemoteDataError`` when no expiry dates are available from Yahoo and when it receives no data from Yahoo (:issue:`8761`), (:issue:`8783`).\n- Unclear error message in csv parsing when passing dtype and names and the parsed data is a different data type (:issue:`8833`)\n- Bug in slicing a MultiIndex with an empty list and at least one boolean indexer (:issue:`8781`)\n- ``io.data.Options`` now raises ``RemoteDataError`` when no expiry dates are available from Yahoo (:issue:`8761`).\n- ``Timedelta`` kwargs may now be numpy ints and floats (:issue:`8757`).\n- Fixed several outstanding bugs for ``Timedelta`` arithmetic and comparisons (:issue:`8813`, :issue:`5963`, :issue:`5436`).\n- ``sql_schema`` now generates dialect appropriate ``CREATE TABLE`` statements (:issue:`8697`)\n- ``slice`` string method now takes step into account (:issue:`8754`)\n- Bug in ``BlockManager`` where setting values with different type would break block integrity (:issue:`8850`)\n- Bug in ``DatetimeIndex`` when using ``time`` object as key (:issue:`8667`)\n- Bug in ``merge`` where ``how='left'`` and ``sort=False`` would not preserve left frame order (:issue:`7331`)\n- Bug in ``MultiIndex.reindex`` where reindexing at level would not reorder labels (:issue:`4088`)\n- Bug in certain operations with dateutil timezones, manifesting with dateutil 2.3 (:issue:`8639`)\n- Regression in DatetimeIndex iteration with a Fixed/Local offset timezone (:issue:`8890`)\n- Bug in ``to_datetime`` when parsing a nanoseconds using the ``%f`` format (:issue:`8989`)\n- ``io.data.Options`` now raises ``RemoteDataError`` when no expiry dates are available from Yahoo and when it receives no data from Yahoo (:issue:`8761`), (:issue:`8783`).\n- Fix: The font size was only set on x axis if vertical or the y axis if horizontal. (:issue:`8765`)\n- Fixed division by 0 when reading big csv files in python 3 (:issue:`8621`)\n- Bug in outputting a MultiIndex with ``to_html,index=False`` which would add an extra column (:issue:`8452`)\n- Imported categorical variables from Stata files retain the ordinal information in the underlying data (:issue:`8836`).\n- Defined ``.size`` attribute across ``NDFrame`` objects to provide compat with numpy >= 1.9.1; buggy with ``np.array_split`` (:issue:`8846`)\n- Skip testing of histogram plots for matplotlib <= 1.2 (:issue:`8648`).\n- Bug where ``get_data_google`` returned object dtypes (:issue:`3995`)\n- Bug in ``DataFrame.stack(..., dropna=False)`` when the DataFrame's ``columns`` is a ``MultiIndex``\n  whose ``labels`` do not reference all its ``levels``. (:issue:`8844`)\n- Bug in that Option context applied on ``__enter__`` (:issue:`8514`)\n- Bug in resample that causes a ValueError when resampling across multiple days\n  and the last offset is not calculated from the start of the range (:issue:`8683`)\n- Bug where ``DataFrame.plot(kind='scatter')`` fails when checking if an np.array is in the DataFrame (:issue:`8852`)\n- Bug in ``pd.infer_freq/DataFrame.inferred_freq`` that prevented proper sub-daily frequency inference when the index contained DST days (:issue:`8772`).\n- Bug where index name was still used when plotting a series with ``use_index=False`` (:issue:`8558`).\n- Bugs when trying to stack multiple columns, when some (or all) of the level names are numbers (:issue:`8584`).\n- Bug in ``MultiIndex`` where ``__contains__`` returns wrong result if index is not lexically sorted or unique (:issue:`7724`)\n- BUG CSV: fix problem with trailing white space in skipped rows, (:issue:`8679`), (:issue:`8661`), (:issue:`8983`)\n- Regression in ``Timestamp`` does not parse 'Z' zone designator for UTC (:issue:`8771`)\n- Bug in ``StataWriter`` the produces writes strings with 244 characters irrespective of actual size (:issue:`8969`)\n- Fixed ValueError raised by cummin/cummax when datetime64 Series contains NaT. (:issue:`8965`)\n- Bug in DataReader returns object dtype if there are missing values (:issue:`8980`)\n- Bug in plotting if sharex was enabled and index was a timeseries, would show labels on multiple axes (:issue:`3964`).\n- Bug where passing a unit to the TimedeltaIndex constructor applied the to nano-second conversion twice. (:issue:`9011`).\n- Bug in plotting of a period-like array (:issue:`9012`)\n\n\n.. _whatsnew_0.15.2.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.15.1..v0.15.2\n", "2.1.0": ".. _whatsnew_210:\n\nWhat's new in 2.1.0 (Aug 30, 2023)\n--------------------------------------\n\nThese are the changes in pandas 2.1.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_210.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_210.enhancements.pyarrow_dependency:\n\nPyArrow will become a required dependency with pandas 3.0\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n`PyArrow <https://arrow.apache.org/docs/python/index.html>`_ will become a required\ndependency of pandas starting with pandas 3.0. This decision was made based on\n`PDEP 10 <https://pandas.pydata.org/pdeps/0010-required-pyarrow-dependency.html>`_.\n\nThis will enable more changes that are hugely beneficial to pandas users, including\nbut not limited to:\n\n- inferring strings as PyArrow backed strings by default enabling a significant\n  reduction of the memory footprint and huge performance improvements.\n- inferring more complex dtypes with PyArrow by default, like ``Decimal``, ``lists``,\n  ``bytes``, ``structured data`` and more.\n- Better interoperability with other libraries that depend on Apache Arrow.\n\nWe are collecting feedback on this decision `here <https://github.com/pandas-dev/pandas/issues/54466>`_.\n\n.. _whatsnew_210.enhancements.infer_strings:\n\nAvoid NumPy object dtype for strings by default\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously, all strings were stored in columns with NumPy object dtype by default.\nThis release introduces an option ``future.infer_string`` that infers all\nstrings as PyArrow backed strings with dtype ``\"string[pyarrow_numpy]\"`` instead.\nThis is a new string dtype implementation that follows NumPy semantics in comparison\noperations and will return ``np.nan`` as the missing value indicator.\nSetting the option will also infer the dtype ``\"string\"`` as a :class:`StringDtype` with\nstorage set to ``\"pyarrow_numpy\"``, ignoring the value behind the option\n``mode.string_storage``.\n\nThis option only works if PyArrow is installed. PyArrow backed strings have a\nsignificantly reduced memory footprint and provide a big performance improvement\ncompared to NumPy object (:issue:`54430`).\n\nThe option can be enabled with:\n\n.. code-block:: python\n\n    pd.options.future.infer_string = True\n\nThis behavior will become the default with pandas 3.0.\n\n.. _whatsnew_210.enhancements.reduction_extension_dtypes:\n\nDataFrame reductions preserve extension dtypes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn previous versions of pandas, the results of DataFrame reductions\n(:meth:`DataFrame.sum` :meth:`DataFrame.mean` etc.) had NumPy dtypes, even when the DataFrames\nwere of extension dtypes. Pandas can now keep the dtypes when doing reductions over DataFrame\ncolumns with a common dtype (:issue:`52788`).\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [1]: df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\n    In [2]: df.sum()\n    Out[2]:\n    a    5\n    b    9\n    dtype: int64\n    In [3]: df = df.astype(\"int64[pyarrow]\")\n    In [4]: df.sum()\n    Out[4]:\n    a    5\n    b    9\n    dtype: int64\n\n*New Behavior*\n\n.. ipython:: python\n\n    df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\n    df.sum()\n    df = df.astype(\"int64[pyarrow]\")\n    df.sum()\n\nNotice that the dtype is now a masked dtype and PyArrow dtype, respectively, while previously it was a NumPy integer dtype.\n\nTo allow DataFrame reductions to preserve extension dtypes, :meth:`.ExtensionArray._reduce` has gotten a new keyword parameter ``keepdims``. Calling :meth:`.ExtensionArray._reduce` with ``keepdims=True`` should return an array of length 1 along the reduction axis. In order to maintain backward compatibility, the parameter is not required, but will it become required in the future. If the parameter is not found in the signature, DataFrame reductions can not preserve extension dtypes. Also, if the parameter is not found, a ``FutureWarning`` will be emitted and type checkers like mypy may complain about the signature not being compatible with :meth:`.ExtensionArray._reduce`.\n\n.. _whatsnew_210.enhancements.cow:\n\nCopy-on-Write improvements\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n- :meth:`Series.transform` not respecting Copy-on-Write when ``func`` modifies :class:`Series` inplace (:issue:`53747`)\n- Calling :meth:`Index.values` will now return a read-only NumPy array (:issue:`53704`)\n- Setting a :class:`Series` into a :class:`DataFrame` now creates a lazy instead of a deep copy (:issue:`53142`)\n- The :class:`DataFrame` constructor, when constructing a DataFrame from a dictionary\n  of Index objects and specifying ``copy=False``, will now use a lazy copy\n  of those Index objects for the columns of the DataFrame (:issue:`52947`)\n- A shallow copy of a Series or DataFrame (``df.copy(deep=False)``) will now also return\n  a shallow copy of the rows/columns :class:`Index` objects instead of only a shallow copy of\n  the data, i.e. the index of the result is no longer identical\n  (``df.copy(deep=False).index is df.index`` is no longer True) (:issue:`53721`)\n- :meth:`DataFrame.head` and :meth:`DataFrame.tail` will now return deep copies (:issue:`54011`)\n- Add lazy copy mechanism to :meth:`DataFrame.eval` (:issue:`53746`)\n\n- Trying to operate inplace on a temporary column selection\n  (for example, ``df[\"a\"].fillna(100, inplace=True)``)\n  will now always raise a warning when Copy-on-Write is enabled. In this mode,\n  operating inplace like this will never work, since the selection behaves\n  as a temporary copy. This holds true for:\n\n  - DataFrame.update / Series.update\n  - DataFrame.fillna / Series.fillna\n  - DataFrame.replace / Series.replace\n  - DataFrame.clip / Series.clip\n  - DataFrame.where / Series.where\n  - DataFrame.mask / Series.mask\n  - DataFrame.interpolate / Series.interpolate\n  - DataFrame.ffill / Series.ffill\n  - DataFrame.bfill / Series.bfill\n\n.. _whatsnew_210.enhancements.map_na_action:\n\nNew :meth:`DataFrame.map` method and support for ExtensionArrays\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe :meth:`DataFrame.map` been added and :meth:`DataFrame.applymap` has been deprecated. :meth:`DataFrame.map` has the same functionality as :meth:`DataFrame.applymap`, but the new name better communicates that this is the :class:`DataFrame` version of :meth:`Series.map` (:issue:`52353`).\n\nWhen given a callable, :meth:`Series.map` applies the callable to all elements of the :class:`Series`.\nSimilarly, :meth:`DataFrame.map` applies the callable to all elements of the :class:`DataFrame`,\nwhile :meth:`Index.map` applies the callable to all elements of the :class:`Index`.\n\nFrequently, it is not desirable to apply the callable to nan-like values of the array and to avoid doing\nthat, the ``map`` method could be called with ``na_action=\"ignore\"``, i.e. ``ser.map(func, na_action=\"ignore\")``.\nHowever, ``na_action=\"ignore\"`` was not implemented for many :class:`.ExtensionArray` and ``Index`` types\nand ``na_action=\"ignore\"`` did not work correctly for any :class:`.ExtensionArray` subclass except the nullable numeric ones (i.e. with dtype :class:`Int64` etc.).\n\n``na_action=\"ignore\"`` now works for all array types (:issue:`52219`, :issue:`51645`, :issue:`51809`, :issue:`51936`, :issue:`52033`; :issue:`52096`).\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [1]: ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\n    In [2]: ser.map(str.upper, na_action=\"ignore\")\n    NotImplementedError\n    In [3]: df = pd.DataFrame(ser)\n    In [4]: df.applymap(str.upper, na_action=\"ignore\")  # worked for DataFrame\n         0\n    0    A\n    1    B\n    2  NaN\n    In [5]: idx = pd.Index(ser)\n    In [6]: idx.map(str.upper, na_action=\"ignore\")\n    TypeError: CategoricalIndex.map() got an unexpected keyword argument 'na_action'\n\n*New behavior*:\n\n.. ipython:: python\n\n    ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\n    ser.map(str.upper, na_action=\"ignore\")\n    df = pd.DataFrame(ser)\n    df.map(str.upper, na_action=\"ignore\")\n    idx = pd.Index(ser)\n    idx.map(str.upper, na_action=\"ignore\")\n\nAlso, note that :meth:`Categorical.map` implicitly has had its ``na_action`` set to ``\"ignore\"`` by default.\nThis has been deprecated and the default for :meth:`Categorical.map` will change\nto ``na_action=None``, consistent with all the other array types.\n\n.. _whatsnew_210.enhancements.new_stack:\n\nNew implementation of :meth:`DataFrame.stack`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\npandas has reimplemented :meth:`DataFrame.stack`. To use the new implementation, pass the argument ``future_stack=True``. This will become the only option in pandas 3.0.\n\nThe previous implementation had two main behavioral downsides.\n\n1. The previous implementation would unnecessarily introduce NA values into the result. The user could have NA values automatically removed by passing ``dropna=True`` (the default), but doing this could also remove NA values from the result that existed in the input. See the examples below.\n2. The previous implementation with ``sort=True`` (the default) would sometimes sort part of the resulting index, and sometimes not. If the input's columns are *not* a :class:`MultiIndex`, then the resulting index would never be sorted. If the columns are a :class:`MultiIndex`, then in most cases the level(s) in the resulting index that come from stacking the column level(s) would be sorted. In rare cases such level(s) would be sorted in a non-standard order, depending on how the columns were created.\n\nThe new implementation (``future_stack=True``) will no longer unnecessarily introduce NA values when stacking multiple levels and will never sort. As such, the arguments ``dropna`` and ``sort`` are not utilized and must remain unspecified when using ``future_stack=True``. These arguments will be removed in the next major release.\n\n.. ipython:: python\n\n    columns = pd.MultiIndex.from_tuples([(\"B\", \"d\"), (\"A\", \"c\")])\n    df = pd.DataFrame([[0, 2], [1, 3]], index=[\"z\", \"y\"], columns=columns)\n    df\n\nIn the previous version (``future_stack=False``), the default of ``dropna=True`` would remove unnecessarily introduced NA values but still coerce the dtype to ``float64`` in the process. In the new version, no NAs are introduced and so there is no coercion of the dtype.\n\n.. ipython:: python\n    :okwarning:\n\n    df.stack([0, 1], future_stack=False, dropna=True)\n    df.stack([0, 1], future_stack=True)\n\nIf the input contains NA values, the previous version would drop those as well with ``dropna=True`` or introduce new NA values with ``dropna=False``. The new version persists all values from the input.\n\n.. ipython:: python\n    :okwarning:\n\n    df = pd.DataFrame([[0, 2], [np.nan, np.nan]], columns=columns)\n    df\n    df.stack([0, 1], future_stack=False, dropna=True)\n    df.stack([0, 1], future_stack=False, dropna=False)\n    df.stack([0, 1], future_stack=True)\n\n.. _whatsnew_210.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n- :meth:`Series.ffill` and :meth:`Series.bfill` are now supported for objects with :class:`IntervalDtype` (:issue:`54247`)\n- Added ``filters`` parameter to :func:`read_parquet` to filter out data, compatible with both ``engines`` (:issue:`53212`)\n- :meth:`.Categorical.map` and :meth:`CategoricalIndex.map` now have a ``na_action`` parameter.\n  :meth:`.Categorical.map` implicitly had a default value of ``\"ignore\"`` for ``na_action``. This has formally been deprecated and will be changed to ``None`` in the future.\n  Also notice that :meth:`Series.map` has default ``na_action=None`` and calls to series with categorical data will now use ``na_action=None`` unless explicitly set otherwise (:issue:`44279`)\n- :class:`api.extensions.ExtensionArray` now has a :meth:`~api.extensions.ExtensionArray.map` method (:issue:`51809`)\n- :meth:`DataFrame.applymap` now uses the :meth:`~api.extensions.ExtensionArray.map` method of underlying :class:`api.extensions.ExtensionArray` instances (:issue:`52219`)\n- :meth:`MultiIndex.sort_values` now supports ``na_position`` (:issue:`51612`)\n- :meth:`MultiIndex.sortlevel` and :meth:`Index.sortlevel` gained a new keyword ``na_position`` (:issue:`51612`)\n- :meth:`arrays.DatetimeArray.map`, :meth:`arrays.TimedeltaArray.map` and :meth:`arrays.PeriodArray.map` can now take a ``na_action`` argument (:issue:`51644`)\n- :meth:`arrays.SparseArray.map` now supports ``na_action`` (:issue:`52096`).\n- :meth:`pandas.read_html` now supports the ``storage_options`` keyword when used with a URL, allowing users to add headers to the outbound HTTP request (:issue:`49944`)\n- Add :meth:`Index.diff` and :meth:`Index.round` (:issue:`19708`)\n- Add ``\"latex-math\"`` as an option to the ``escape`` argument of :class:`.Styler` which will not escape all characters between ``\"\\(\"`` and ``\"\\)\"`` during formatting (:issue:`51903`)\n- Add dtype of categories to ``repr`` information of :class:`CategoricalDtype` (:issue:`52179`)\n- Adding ``engine_kwargs`` parameter to :func:`read_excel` (:issue:`52214`)\n- Classes that are useful for type-hinting have been added to the public API in the new submodule ``pandas.api.typing`` (:issue:`48577`)\n- Implemented :attr:`Series.dt.is_month_start`, :attr:`Series.dt.is_month_end`, :attr:`Series.dt.is_year_start`, :attr:`Series.dt.is_year_end`, :attr:`Series.dt.is_quarter_start`, :attr:`Series.dt.is_quarter_end`, :attr:`Series.dt.days_in_month`, :attr:`Series.dt.unit`, :attr:`Series.dt.normalize`, :meth:`Series.dt.day_name`, :meth:`Series.dt.month_name`, :meth:`Series.dt.tz_convert` for :class:`ArrowDtype` with ``pyarrow.timestamp`` (:issue:`52388`, :issue:`51718`)\n- :meth:`.DataFrameGroupBy.agg` and :meth:`.DataFrameGroupBy.transform` now support grouping by multiple keys when the index is not a :class:`MultiIndex` for ``engine=\"numba\"`` (:issue:`53486`)\n- :meth:`.SeriesGroupBy.agg` and :meth:`.DataFrameGroupBy.agg` now support passing in multiple functions for ``engine=\"numba\"`` (:issue:`53486`)\n- :meth:`.SeriesGroupBy.transform` and :meth:`.DataFrameGroupBy.transform` now support passing in a string as the function for ``engine=\"numba\"`` (:issue:`53579`)\n- :meth:`DataFrame.stack` gained the ``sort`` keyword to dictate whether the resulting :class:`MultiIndex` levels are sorted (:issue:`15105`)\n- :meth:`DataFrame.unstack` gained the ``sort`` keyword to dictate whether the resulting :class:`MultiIndex` levels are sorted (:issue:`15105`)\n- :meth:`Series.explode` now supports PyArrow-backed list types (:issue:`53602`)\n- :meth:`Series.str.join` now supports ``ArrowDtype(pa.string())`` (:issue:`53646`)\n- Add ``validate`` parameter to :meth:`Categorical.from_codes` (:issue:`50975`)\n- Added :meth:`.ExtensionArray.interpolate` used by :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` (:issue:`53659`)\n- Added ``engine_kwargs`` parameter to :meth:`DataFrame.to_excel` (:issue:`53220`)\n- Implemented :func:`api.interchange.from_dataframe` for :class:`DatetimeTZDtype` (:issue:`54239`)\n- Implemented ``__from_arrow__`` on :class:`DatetimeTZDtype` (:issue:`52201`)\n- Implemented ``__pandas_priority__`` to allow custom types to take precedence over :class:`DataFrame`, :class:`Series`, :class:`Index`, or :class:`.ExtensionArray` for arithmetic operations, :ref:`see the developer guide <extending.pandas_priority>` (:issue:`48347`)\n- Improve error message when having incompatible columns using :meth:`DataFrame.merge` (:issue:`51861`)\n- Improve error message when setting :class:`DataFrame` with wrong number of columns through :meth:`DataFrame.isetitem` (:issue:`51701`)\n- Improved error handling when using :meth:`DataFrame.to_json` with incompatible ``index`` and ``orient`` arguments (:issue:`52143`)\n- Improved error message when creating a DataFrame with empty data (0 rows), no index and an incorrect number of columns (:issue:`52084`)\n- Improved error message when providing an invalid ``index`` or ``offset`` argument to :class:`.VariableOffsetWindowIndexer` (:issue:`54379`)\n- Let :meth:`DataFrame.to_feather` accept a non-default :class:`Index` and non-string column names (:issue:`51787`)\n- Added a new parameter ``by_row`` to :meth:`Series.apply` and :meth:`DataFrame.apply`. When set to ``False`` the supplied callables will always operate on the whole Series or DataFrame (:issue:`53400`, :issue:`53601`).\n- :meth:`DataFrame.shift` and :meth:`Series.shift` now allow shifting by multiple periods by supplying a list of periods (:issue:`44424`)\n- Groupby aggregations with ``numba`` (such as :meth:`.DataFrameGroupBy.sum`) now can preserve the dtype of the input instead of casting to ``float64`` (:issue:`44952`)\n- Improved error message when :meth:`.DataFrameGroupBy.agg` failed (:issue:`52930`)\n- Many read/to_* functions, such as :meth:`DataFrame.to_pickle` and :func:`read_csv`, support forwarding compression arguments to ``lzma.LZMAFile`` (:issue:`52979`)\n- Reductions :meth:`Series.argmax`, :meth:`Series.argmin`, :meth:`Series.idxmax`, :meth:`Series.idxmin`, :meth:`Index.argmax`, :meth:`Index.argmin`, :meth:`DataFrame.idxmax`, :meth:`DataFrame.idxmin` are now supported for object-dtype (:issue:`4279`, :issue:`18021`, :issue:`40685`, :issue:`43697`)\n- :meth:`DataFrame.to_parquet` and :func:`read_parquet` will now write and read ``attrs`` respectively (:issue:`54346`)\n- :meth:`Index.all` and :meth:`Index.any` with floating dtypes and timedelta64 dtypes no longer raise ``TypeError``, matching the :meth:`Series.all` and :meth:`Series.any` behavior (:issue:`54566`)\n- :meth:`Series.cummax`, :meth:`Series.cummin` and :meth:`Series.cumprod` are now supported for pyarrow dtypes with pyarrow version 13.0 and above (:issue:`52085`)\n- Added support for the DataFrame Consortium Standard (:issue:`54383`)\n- Performance improvement in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` (:issue:`51722`)\n- PyArrow-backed integer dtypes now support bitwise operations (:issue:`54495`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_210.api_breaking:\n\nBackwards incompatible API changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_210.api_breaking.deps:\n\nIncreased minimum version for Python\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\npandas 2.1.0 supports Python 3.9 and higher.\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSome minimum supported versions of dependencies were updated.\nIf installed, we now require:\n\n+----------------------+-----------------+----------+---------+\n| Package              | Minimum Version | Required | Changed |\n+======================+=================+==========+=========+\n| numpy                | 1.22.4          |    X     |    X    |\n+----------------------+-----------------+----------+---------+\n| mypy (dev)           | 1.4.1           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| beautifulsoup4       | 4.11.1          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| bottleneck           | 1.3.4           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| dataframe-api-compat | 0.1.7           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| fastparquet          | 0.8.1           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| fsspec               | 2022.05.0       |          |    X    |\n+----------------------+-----------------+----------+---------+\n| hypothesis           | 6.46.1          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| gcsfs                | 2022.05.0       |          |    X    |\n+----------------------+-----------------+----------+---------+\n| jinja2               | 3.1.2           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| lxml                 | 4.8.0           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| numba                | 0.55.2          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| numexpr              | 2.8.0           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| openpyxl             | 3.0.10          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| pandas-gbq           | 0.17.5          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| psycopg2             | 2.9.3           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| pyreadstat           | 1.1.5           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| pyqt5                | 5.15.6          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| pytables             | 3.7.0           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| pytest               | 7.3.2           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| python-snappy        | 0.6.1           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| pyxlsb               | 1.0.9           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| s3fs                 | 2022.05.0       |          |    X    |\n+----------------------+-----------------+----------+---------+\n| scipy                | 1.8.1           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| sqlalchemy           | 1.4.36          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| tabulate             | 0.8.10          |          |    X    |\n+----------------------+-----------------+----------+---------+\n| xarray               | 2022.03.0       |          |    X    |\n+----------------------+-----------------+----------+---------+\n| xlsxwriter           | 3.0.3           |          |    X    |\n+----------------------+-----------------+----------+---------+\n| zstandard            | 0.17.0          |          |    X    |\n+----------------------+-----------------+----------+---------+\n\nFor `optional libraries <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\n.. _whatsnew_210.api_breaking.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n- :class:`arrays.PandasArray` has been renamed :class:`.NumpyExtensionArray` and the attached dtype name changed from ``PandasDtype`` to ``NumpyEADtype``; importing ``PandasArray`` still works until the next major version (:issue:`53694`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_210.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\nDeprecated silent upcasting in setitem-like Series operations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPDEP-6: https://pandas.pydata.org/pdeps/0006-ban-upcasting.html\n\nSetitem-like operations on Series (or DataFrame columns) which silently upcast the dtype are\ndeprecated and show a warning. Examples of affected operations are:\n\n- ``ser.fillna('foo', inplace=True)``\n- ``ser.where(ser.isna(), 'foo', inplace=True)``\n- ``ser.iloc[indexer] = 'foo'``\n- ``ser.loc[indexer] = 'foo'``\n- ``df.iloc[indexer, 0] = 'foo'``\n- ``df.loc[indexer, 'a'] = 'foo'``\n- ``ser[indexer] = 'foo'``\n\nwhere ``ser`` is a :class:`Series`, ``df`` is a :class:`DataFrame`, and ``indexer``\ncould be a slice, a mask, a single value, a list or array of values, or any other\nallowed indexer.\n\nIn a future version, these will raise an error and you should cast to a common dtype first.\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n  In [1]: ser = pd.Series([1, 2, 3])\n\n  In [2]: ser\n  Out[2]:\n  0    1\n  1    2\n  2    3\n  dtype: int64\n\n  In [3]: ser[0] = 'not an int64'\n\n  In [4]: ser\n  Out[4]:\n  0    not an int64\n  1               2\n  2               3\n  dtype: object\n\n*New behavior*:\n\n.. code-block:: ipython\n\n  In [1]: ser = pd.Series([1, 2, 3])\n\n  In [2]: ser\n  Out[2]:\n  0    1\n  1    2\n  2    3\n  dtype: int64\n\n  In [3]: ser[0] = 'not an int64'\n  FutureWarning:\n    Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas.\n    Value 'not an int64' has dtype incompatible with int64, please explicitly cast to a compatible dtype first.\n\n  In [4]: ser\n  Out[4]:\n  0    not an int64\n  1               2\n  2               3\n  dtype: object\n\nTo retain the current behaviour, in the case above you could cast ``ser`` to ``object`` dtype first:\n\n.. ipython:: python\n\n  ser = pd.Series([1, 2, 3])\n  ser = ser.astype('object')\n  ser[0] = 'not an int64'\n  ser\n\nDepending on the use-case, it might be more appropriate to cast to a different dtype.\nIn the following, for example, we cast to ``float64``:\n\n.. ipython:: python\n\n  ser = pd.Series([1, 2, 3])\n  ser = ser.astype('float64')\n  ser[0] = 1.1\n  ser\n\nFor further reading, please see https://pandas.pydata.org/pdeps/0006-ban-upcasting.html.\n\nDeprecated parsing datetimes with mixed time zones\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nParsing datetimes with mixed time zones is deprecated and shows a warning unless user passes ``utc=True`` to :func:`to_datetime` (:issue:`50887`)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n  In [7]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\n  In [8]:  pd.to_datetime(data, utc=False)\n  Out[8]:\n  Index([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object')\n\n*New behavior*:\n\n.. code-block:: ipython\n\n  In [9]: pd.to_datetime(data, utc=False)\n  FutureWarning:\n    In a future version of pandas, parsing datetimes with mixed time zones will raise\n    a warning unless `utc=True`. Please specify `utc=True` to opt in to the new behaviour\n    and silence this warning. To create a `Series` with mixed offsets and `object` dtype,\n    please use `apply` and `datetime.datetime.strptime`.\n  Index([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object')\n\nIn order to silence this warning and avoid an error in a future version of pandas,\nplease specify ``utc=True``:\n\n.. ipython:: python\n\n    data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n    pd.to_datetime(data, utc=True)\n\nTo create a ``Series`` with mixed offsets and ``object`` dtype, please use ``apply``\nand ``datetime.datetime.strptime``:\n\n.. ipython:: python\n\n    import datetime as dt\n\n    data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n    pd.Series(data).apply(lambda x: dt.datetime.strptime(x, '%Y-%m-%d %H:%M:%S%z'))\n\nOther Deprecations\n^^^^^^^^^^^^^^^^^^\n- Deprecated :attr:`.DataFrameGroupBy.dtypes`, check ``dtypes`` on the underlying object instead (:issue:`51045`)\n- Deprecated :attr:`DataFrame._data` and :attr:`Series._data`, use public APIs instead (:issue:`33333`)\n- Deprecated :func:`concat` behavior when any of the objects being concatenated have length 0; in the past the dtypes of empty objects were ignored when determining the resulting dtype, in a future version they will not (:issue:`39122`)\n- Deprecated :meth:`.Categorical.to_list`, use ``obj.tolist()`` instead (:issue:`51254`)\n- Deprecated :meth:`.DataFrameGroupBy.all` and :meth:`.DataFrameGroupBy.any` with datetime64 or :class:`PeriodDtype` values, matching the :class:`Series` and :class:`DataFrame` deprecations (:issue:`34479`)\n- Deprecated ``axis=1`` in :meth:`DataFrame.ewm`, :meth:`DataFrame.rolling`, :meth:`DataFrame.expanding`, transpose before calling the method instead (:issue:`51778`)\n- Deprecated ``axis=1`` in :meth:`DataFrame.groupby` and in :class:`Grouper` constructor, do ``frame.T.groupby(...)`` instead (:issue:`51203`)\n- Deprecated ``broadcast_axis`` keyword in :meth:`Series.align` and :meth:`DataFrame.align`, upcast before calling ``align`` with ``left = DataFrame({col: left for col in right.columns}, index=right.index)`` (:issue:`51856`)\n- Deprecated ``downcast`` keyword in :meth:`Index.fillna` (:issue:`53956`)\n- Deprecated ``fill_method`` and ``limit`` keywords in :meth:`DataFrame.pct_change`, :meth:`Series.pct_change`, :meth:`.DataFrameGroupBy.pct_change`, and :meth:`.SeriesGroupBy.pct_change`, explicitly call e.g. :meth:`DataFrame.ffill` or :meth:`DataFrame.bfill` before calling ``pct_change`` instead (:issue:`53491`)\n- Deprecated ``method``, ``limit``, and ``fill_axis`` keywords in :meth:`DataFrame.align` and :meth:`Series.align`, explicitly call :meth:`DataFrame.fillna` or :meth:`Series.fillna` on the alignment results instead (:issue:`51856`)\n- Deprecated ``quantile`` keyword in :meth:`.Rolling.quantile` and :meth:`.Expanding.quantile`, renamed to ``q`` instead (:issue:`52550`)\n- Deprecated accepting slices in :meth:`DataFrame.take`, call ``obj[slicer]`` or pass a sequence of integers instead (:issue:`51539`)\n- Deprecated behavior of :meth:`DataFrame.idxmax`, :meth:`DataFrame.idxmin`, :meth:`Series.idxmax`, :meth:`Series.idxmin` in with all-NA entries or any-NA and ``skipna=False``; in a future version these will raise ``ValueError`` (:issue:`51276`)\n- Deprecated explicit support for subclassing :class:`Index` (:issue:`45289`)\n- Deprecated making functions given to :meth:`Series.agg` attempt to operate on each element in the :class:`Series` and only operate on the whole :class:`Series` if the elementwise operations failed. In the future, functions given to :meth:`Series.agg` will always operate on the whole :class:`Series` only. To keep the current behavior, use :meth:`Series.transform` instead (:issue:`53325`)\n- Deprecated making the functions in a list of functions given to :meth:`DataFrame.agg` attempt to operate on each element in the :class:`DataFrame` and only operate on the columns of the :class:`DataFrame` if the elementwise operations failed. To keep the current behavior, use :meth:`DataFrame.transform` instead (:issue:`53325`)\n- Deprecated passing a :class:`DataFrame` to :meth:`DataFrame.from_records`, use :meth:`DataFrame.set_index` or :meth:`DataFrame.drop` instead (:issue:`51353`)\n- Deprecated silently dropping unrecognized timezones when parsing strings to datetimes (:issue:`18702`)\n- Deprecated the ``axis`` keyword in :meth:`DataFrame.ewm`, :meth:`Series.ewm`, :meth:`DataFrame.rolling`, :meth:`Series.rolling`, :meth:`DataFrame.expanding`, :meth:`Series.expanding` (:issue:`51778`)\n- Deprecated the ``axis`` keyword in :meth:`DataFrame.resample`, :meth:`Series.resample` (:issue:`51778`)\n- Deprecated the ``downcast`` keyword in :meth:`Series.interpolate`, :meth:`DataFrame.interpolate`, :meth:`Series.fillna`, :meth:`DataFrame.fillna`, :meth:`Series.ffill`, :meth:`DataFrame.ffill`, :meth:`Series.bfill`, :meth:`DataFrame.bfill` (:issue:`40988`)\n- Deprecated the behavior of :func:`concat` with both ``len(keys) != len(objs)``, in a future version this will raise instead of truncating to the shorter of the two sequences (:issue:`43485`)\n- Deprecated the behavior of :meth:`Series.argsort` in the presence of NA values; in a future version these will be sorted at the end instead of giving -1 (:issue:`54219`)\n- Deprecated the default of ``observed=False`` in :meth:`DataFrame.groupby` and :meth:`Series.groupby`; this will default to ``True`` in a future version (:issue:`43999`)\n- Deprecating pinning ``group.name`` to each group in :meth:`.SeriesGroupBy.aggregate` aggregations; if your operation requires utilizing the groupby keys, iterate over the groupby object instead (:issue:`41090`)\n- Deprecated the ``axis`` keyword in :meth:`.DataFrameGroupBy.idxmax`, :meth:`.DataFrameGroupBy.idxmin`, :meth:`.DataFrameGroupBy.fillna`, :meth:`.DataFrameGroupBy.take`, :meth:`.DataFrameGroupBy.skew`, :meth:`.DataFrameGroupBy.rank`, :meth:`.DataFrameGroupBy.cumprod`, :meth:`.DataFrameGroupBy.cumsum`, :meth:`.DataFrameGroupBy.cummax`, :meth:`.DataFrameGroupBy.cummin`, :meth:`.DataFrameGroupBy.pct_change`, :meth:`.DataFrameGroupBy.diff`, :meth:`.DataFrameGroupBy.shift`, and :meth:`.DataFrameGroupBy.corrwith`; for ``axis=1`` operate on the underlying :class:`DataFrame` instead (:issue:`50405`, :issue:`51046`)\n- Deprecated :class:`.DataFrameGroupBy` with ``as_index=False`` not including groupings in the result when they are not columns of the DataFrame (:issue:`49519`)\n- Deprecated :func:`is_categorical_dtype`, use ``isinstance(obj.dtype, pd.CategoricalDtype)`` instead (:issue:`52527`)\n- Deprecated :func:`is_datetime64tz_dtype`, check ``isinstance(dtype, pd.DatetimeTZDtype)`` instead (:issue:`52607`)\n- Deprecated :func:`is_int64_dtype`, check ``dtype == np.dtype(np.int64)`` instead (:issue:`52564`)\n- Deprecated :func:`is_interval_dtype`, check ``isinstance(dtype, pd.IntervalDtype)`` instead (:issue:`52607`)\n- Deprecated :func:`is_period_dtype`, check ``isinstance(dtype, pd.PeriodDtype)`` instead (:issue:`52642`)\n- Deprecated :func:`is_sparse`, check ``isinstance(dtype, pd.SparseDtype)`` instead (:issue:`52642`)\n- Deprecated :meth:`.Styler.applymap_index`. Use the new :meth:`.Styler.map_index` method instead (:issue:`52708`)\n- Deprecated :meth:`.Styler.applymap`. Use the new :meth:`.Styler.map` method instead (:issue:`52708`)\n- Deprecated :meth:`DataFrame.applymap`. Use the new :meth:`DataFrame.map` method instead (:issue:`52353`)\n- Deprecated :meth:`DataFrame.swapaxes` and :meth:`Series.swapaxes`, use :meth:`DataFrame.transpose` or :meth:`Series.transpose` instead (:issue:`51946`)\n- Deprecated ``freq`` parameter in :class:`.PeriodArray` constructor, pass ``dtype`` instead (:issue:`52462`)\n- Deprecated allowing non-standard inputs in :func:`take`, pass either a ``numpy.ndarray``, :class:`.ExtensionArray`, :class:`Index`, or :class:`Series` (:issue:`52981`)\n- Deprecated allowing non-standard sequences for :func:`isin`, :func:`value_counts`, :func:`unique`, :func:`factorize`, case to one of ``numpy.ndarray``, :class:`Index`, :class:`.ExtensionArray`, or :class:`Series` before calling (:issue:`52986`)\n- Deprecated behavior of :class:`DataFrame` reductions ``sum``, ``prod``, ``std``, ``var``, ``sem`` with ``axis=None``, in a future version this will operate over both axes returning a scalar instead of behaving like ``axis=0``; note this also affects numpy functions e.g. ``np.sum(df)`` (:issue:`21597`)\n- Deprecated behavior of :func:`concat` when :class:`DataFrame` has columns that are all-NA, in a future version these will not be discarded when determining the resulting dtype (:issue:`40893`)\n- Deprecated behavior of :meth:`Series.dt.to_pydatetime`, in a future version this will return a :class:`Series` containing python ``datetime`` objects instead of an ``ndarray`` of datetimes; this matches the behavior of other :attr:`Series.dt` properties (:issue:`20306`)\n- Deprecated logical operations (``|``, ``&``, ``^``) between pandas objects and dtype-less sequences (e.g. ``list``, ``tuple``), wrap a sequence in a :class:`Series` or NumPy array before operating instead (:issue:`51521`)\n- Deprecated parameter ``convert_type`` in :meth:`Series.apply` (:issue:`52140`)\n- Deprecated passing a dictionary to :meth:`.SeriesGroupBy.agg`; pass a list of aggregations instead (:issue:`50684`)\n- Deprecated the ``fastpath`` keyword in :class:`Categorical` constructor, use :meth:`Categorical.from_codes` instead (:issue:`20110`)\n- Deprecated the behavior of :func:`is_bool_dtype` returning ``True`` for object-dtype :class:`Index` of bool objects (:issue:`52680`)\n- Deprecated the methods :meth:`Series.bool` and :meth:`DataFrame.bool` (:issue:`51749`)\n- Deprecated unused ``closed`` and ``normalize`` keywords in the :class:`DatetimeIndex` constructor (:issue:`52628`)\n- Deprecated unused ``closed`` keyword in the :class:`TimedeltaIndex` constructor (:issue:`52628`)\n- Deprecated logical operation between two non boolean :class:`Series` with different indexes always coercing the result to bool dtype. In a future version, this will maintain the return type of the inputs (:issue:`52500`, :issue:`52538`)\n- Deprecated :class:`Period` and :class:`PeriodDtype` with ``BDay`` freq, use a :class:`DatetimeIndex` with ``BDay`` freq instead (:issue:`53446`)\n- Deprecated :func:`value_counts`, use ``pd.Series(obj).value_counts()`` instead (:issue:`47862`)\n- Deprecated :meth:`Series.first` and :meth:`DataFrame.first`; create a mask and filter using ``.loc`` instead (:issue:`45908`)\n- Deprecated :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` for object-dtype (:issue:`53631`)\n- Deprecated :meth:`Series.last` and :meth:`DataFrame.last`; create a mask and filter using ``.loc`` instead (:issue:`53692`)\n- Deprecated allowing arbitrary ``fill_value`` in :class:`SparseDtype`, in a future version the ``fill_value`` will need to be compatible with the ``dtype.subtype``, either a scalar that can be held by that subtype or ``NaN`` for integer or bool subtypes (:issue:`23124`)\n- Deprecated allowing bool dtype in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile`, consistent with the :meth:`Series.quantile` and :meth:`DataFrame.quantile` behavior (:issue:`51424`)\n- Deprecated behavior of :func:`.testing.assert_series_equal` and :func:`.testing.assert_frame_equal` considering NA-like values (e.g. ``NaN`` vs ``None`` as equivalent) (:issue:`52081`)\n- Deprecated bytes input to :func:`read_excel`. To read a file path, use a string or path-like object (:issue:`53767`)\n- Deprecated constructing :class:`.SparseArray` from scalar data, pass a sequence instead (:issue:`53039`)\n- Deprecated falling back to filling when ``value`` is not specified in :meth:`DataFrame.replace` and :meth:`Series.replace` with non-dict-like ``to_replace`` (:issue:`33302`)\n- Deprecated literal json input to :func:`read_json`. Wrap literal json string input in ``io.StringIO`` instead (:issue:`53409`)\n- Deprecated literal string input to :func:`read_xml`. Wrap literal string/bytes input in ``io.StringIO`` / ``io.BytesIO`` instead (:issue:`53767`)\n- Deprecated literal string/bytes input to :func:`read_html`. Wrap literal string/bytes input in ``io.StringIO`` / ``io.BytesIO`` instead (:issue:`53767`)\n- Deprecated option ``mode.use_inf_as_na``, convert inf entries to ``NaN`` before instead (:issue:`51684`)\n- Deprecated parameter ``obj`` in :meth:`.DataFrameGroupBy.get_group` (:issue:`53545`)\n- Deprecated positional indexing on :class:`Series` with :meth:`Series.__getitem__` and :meth:`Series.__setitem__`, in a future version ``ser[item]`` will *always* interpret ``item`` as a label, not a position (:issue:`50617`)\n- Deprecated replacing builtin and NumPy functions in ``.agg``, ``.apply``, and ``.transform``; use the corresponding string alias (e.g. ``\"sum\"`` for ``sum`` or ``np.sum``) instead (:issue:`53425`)\n- Deprecated strings ``T``, ``t``, ``L`` and ``l`` denoting units in :func:`to_timedelta` (:issue:`52536`)\n- Deprecated the \"method\" and \"limit\" keywords in ``.ExtensionArray.fillna``, implement ``_pad_or_backfill`` instead (:issue:`53621`)\n- Deprecated the ``method`` and ``limit`` keywords in :meth:`DataFrame.replace` and :meth:`Series.replace` (:issue:`33302`)\n- Deprecated the ``method`` and ``limit`` keywords on :meth:`Series.fillna`, :meth:`DataFrame.fillna`, :meth:`.SeriesGroupBy.fillna`, :meth:`.DataFrameGroupBy.fillna`, and :meth:`.Resampler.fillna`, use ``obj.bfill()`` or ``obj.ffill()`` instead (:issue:`53394`)\n- Deprecated the behavior of :meth:`Series.__getitem__`, :meth:`Series.__setitem__`, :meth:`DataFrame.__getitem__`, :meth:`DataFrame.__setitem__` with an integer slice on objects with a floating-dtype index, in a future version this will be treated as *positional* indexing (:issue:`49612`)\n- Deprecated the use of non-supported datetime64 and timedelta64 resolutions with :func:`pandas.array`. Supported resolutions are: \"s\", \"ms\", \"us\", \"ns\" resolutions (:issue:`53058`)\n- Deprecated values ``\"pad\"``, ``\"ffill\"``, ``\"bfill\"``, ``\"backfill\"`` for :meth:`Series.interpolate` and :meth:`DataFrame.interpolate`, use ``obj.ffill()`` or ``obj.bfill()`` instead (:issue:`53581`)\n- Deprecated the behavior of :meth:`Index.argmax`, :meth:`Index.argmin`, :meth:`Series.argmax`, :meth:`Series.argmin` with either all-NAs and ``skipna=True`` or any-NAs and ``skipna=False`` returning -1; in a future version this will raise ``ValueError`` (:issue:`33941`, :issue:`33942`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_sql` except ``name`` and ``con`` (:issue:`54229`)\n- Deprecated silently ignoring ``fill_value`` when passing both ``freq`` and ``fill_value`` to :meth:`DataFrame.shift`, :meth:`Series.shift` and :meth:`.DataFrameGroupBy.shift`; in a future version this will raise ``ValueError`` (:issue:`53832`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_210.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- Performance improvement in :func:`concat` with homogeneous ``np.float64`` or ``np.float32`` dtypes (:issue:`52685`)\n- Performance improvement in :func:`factorize` for object columns not containing strings (:issue:`51921`)\n- Performance improvement in :func:`read_orc` when reading a remote URI file path (:issue:`51609`)\n- Performance improvement in :func:`read_parquet` and :meth:`DataFrame.to_parquet` when reading a remote file with ``engine=\"pyarrow\"`` (:issue:`51609`)\n- Performance improvement in :func:`read_parquet` on string columns when using ``use_nullable_dtypes=True`` (:issue:`47345`)\n- Performance improvement in :meth:`DataFrame.clip` and :meth:`Series.clip` (:issue:`51472`)\n- Performance improvement in :meth:`DataFrame.filter` when ``items`` is given (:issue:`52941`)\n- Performance improvement in :meth:`DataFrame.first_valid_index` and :meth:`DataFrame.last_valid_index` for extension array dtypes (:issue:`51549`)\n- Performance improvement in :meth:`DataFrame.where` when ``cond`` is backed by an extension dtype (:issue:`51574`)\n- Performance improvement in :meth:`MultiIndex.set_levels` and :meth:`MultiIndex.set_codes` when ``verify_integrity=True`` (:issue:`51873`)\n- Performance improvement in :meth:`MultiIndex.sortlevel` when ``ascending`` is a list (:issue:`51612`)\n- Performance improvement in :meth:`Series.combine_first` (:issue:`51777`)\n- Performance improvement in :meth:`~arrays.ArrowExtensionArray.fillna` when array does not contain nulls (:issue:`51635`)\n- Performance improvement in :meth:`~arrays.ArrowExtensionArray.isna` when array has zero nulls or is all nulls (:issue:`51630`)\n- Performance improvement when parsing strings to ``boolean[pyarrow]`` dtype (:issue:`51730`)\n- Performance improvement when searching an :class:`Index` sliced from other indexes (:issue:`51738`)\n- Performance improvement in :func:`concat` (:issue:`52291`, :issue:`52290`)\n- :class:`Period`'s default formatter (``period_format``) is now significantly (~twice) faster. This improves performance of ``str(Period)``, ``repr(Period)``, and :meth:`.Period.strftime(fmt=None)`, as well as ``.PeriodArray.strftime(fmt=None)``, ``.PeriodIndex.strftime(fmt=None)`` and ``.PeriodIndex.format(fmt=None)``. ``to_csv`` operations involving :class:`.PeriodArray` or :class:`PeriodIndex` with default ``date_format`` are also significantly accelerated (:issue:`51459`)\n- Performance improvement accessing :attr:`arrays.IntegerArrays.dtype` & :attr:`arrays.FloatingArray.dtype` (:issue:`52998`)\n- Performance improvement for :class:`.DataFrameGroupBy`/:class:`.SeriesGroupBy` aggregations (e.g. :meth:`.DataFrameGroupBy.sum`) with ``engine=\"numba\"`` (:issue:`53731`)\n- Performance improvement in :class:`DataFrame` reductions with ``axis=1`` and extension dtypes (:issue:`54341`)\n- Performance improvement in :class:`DataFrame` reductions with ``axis=None`` and extension dtypes (:issue:`54308`)\n- Performance improvement in :class:`MultiIndex` and multi-column operations (e.g. :meth:`DataFrame.sort_values`, :meth:`DataFrame.groupby`, :meth:`Series.unstack`) when index/column values are already sorted (:issue:`53806`)\n- Performance improvement in :class:`Series` reductions (:issue:`52341`)\n- Performance improvement in :func:`concat` when ``axis=1`` and objects have different indexes (:issue:`52541`)\n- Performance improvement in :func:`concat` when the concatenation axis is a :class:`MultiIndex` (:issue:`53574`)\n- Performance improvement in :func:`merge` for PyArrow backed strings (:issue:`54443`)\n- Performance improvement in :func:`read_csv` with ``engine=\"c\"`` (:issue:`52632`)\n- Performance improvement in :meth:`.ArrowExtensionArray.to_numpy` (:issue:`52525`)\n- Performance improvement in :meth:`.DataFrameGroupBy.groups` (:issue:`53088`)\n- Performance improvement in :meth:`DataFrame.astype` when ``dtype`` is an extension dtype (:issue:`54299`)\n- Performance improvement in :meth:`DataFrame.iloc` when input is an single integer and dataframe is backed by extension dtypes (:issue:`54508`)\n- Performance improvement in :meth:`DataFrame.isin` for extension dtypes (:issue:`53514`)\n- Performance improvement in :meth:`DataFrame.loc` when selecting rows and columns (:issue:`53014`)\n- Performance improvement in :meth:`DataFrame.transpose` when transposing a DataFrame with a single PyArrow dtype (:issue:`54224`)\n- Performance improvement in :meth:`DataFrame.transpose` when transposing a DataFrame with a single masked dtype, e.g. :class:`Int64` (:issue:`52836`)\n- Performance improvement in :meth:`Series.add` for PyArrow string and binary dtypes (:issue:`53150`)\n- Performance improvement in :meth:`Series.corr` and :meth:`Series.cov` for extension dtypes (:issue:`52502`)\n- Performance improvement in :meth:`Series.drop_duplicates` for ``ArrowDtype`` (:issue:`54667`).\n- Performance improvement in :meth:`Series.ffill`, :meth:`Series.bfill`, :meth:`DataFrame.ffill`, :meth:`DataFrame.bfill` with PyArrow dtypes (:issue:`53950`)\n- Performance improvement in :meth:`Series.str.get_dummies` for PyArrow-backed strings (:issue:`53655`)\n- Performance improvement in :meth:`Series.str.get` for PyArrow-backed strings (:issue:`53152`)\n- Performance improvement in :meth:`Series.str.split` with ``expand=True`` for PyArrow-backed strings (:issue:`53585`)\n- Performance improvement in :meth:`Series.to_numpy` when dtype is a NumPy float dtype and ``na_value`` is ``np.nan`` (:issue:`52430`)\n- Performance improvement in :meth:`~arrays.ArrowExtensionArray.astype` when converting from a PyArrow timestamp or duration dtype to NumPy (:issue:`53326`)\n- Performance improvement in various :class:`MultiIndex` set and indexing operations (:issue:`53955`)\n- Performance improvement when doing various reshaping operations on :class:`arrays.IntegerArray` & :class:`arrays.FloatingArray` by avoiding doing unnecessary validation (:issue:`53013`)\n- Performance improvement when indexing with PyArrow timestamp and duration dtypes (:issue:`53368`)\n- Performance improvement when passing an array to :meth:`RangeIndex.take`, :meth:`DataFrame.loc`, or :meth:`DataFrame.iloc` and the DataFrame is using a RangeIndex (:issue:`53387`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_210.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n- Bug in :meth:`CategoricalIndex.remove_categories` where ordered categories would not be maintained (:issue:`53935`).\n- Bug in :meth:`Series.astype` with ``dtype=\"category\"`` for nullable arrays with read-only null value masks (:issue:`53658`)\n- Bug in :meth:`Series.map` , where the value of the ``na_action`` parameter was not used if the series held a :class:`Categorical` (:issue:`22527`).\n\nDatetimelike\n^^^^^^^^^^^^\n- :meth:`DatetimeIndex.map` with ``na_action=\"ignore\"`` now works as expected (:issue:`51644`)\n- :meth:`DatetimeIndex.slice_indexer` now raises ``KeyError`` for non-monotonic indexes if either of the slice bounds is not in the index; this behaviour was previously deprecated but inconsistently handled (:issue:`53983`)\n- Bug in :class:`DateOffset` which had inconsistent behavior when multiplying a :class:`DateOffset` object by a constant (:issue:`47953`)\n- Bug in :func:`date_range` when ``freq`` was a :class:`DateOffset` with ``nanoseconds`` (:issue:`46877`)\n- Bug in :func:`to_datetime` converting :class:`Series` or :class:`DataFrame` containing :class:`arrays.ArrowExtensionArray` of PyArrow timestamps to numpy datetimes (:issue:`52545`)\n- Bug in :meth:`.DatetimeArray.map` and :meth:`DatetimeIndex.map`, where the supplied callable operated array-wise instead of element-wise (:issue:`51977`)\n- Bug in :meth:`DataFrame.to_sql` raising ``ValueError`` for PyArrow-backed date like dtypes (:issue:`53854`)\n- Bug in :meth:`Timestamp.date`, :meth:`Timestamp.isocalendar`, :meth:`Timestamp.timetuple`, and :meth:`Timestamp.toordinal` were returning incorrect results for inputs outside those supported by the Python standard library's datetime module (:issue:`53668`)\n- Bug in :meth:`Timestamp.round` with values close to the implementation bounds returning incorrect results instead of raising ``OutOfBoundsDatetime`` (:issue:`51494`)\n- Bug in constructing a :class:`Series` or :class:`DataFrame` from a datetime or timedelta scalar always inferring nanosecond resolution instead of inferring from the input (:issue:`52212`)\n- Bug in constructing a :class:`Timestamp` from a string representing a time without a date inferring an incorrect unit (:issue:`54097`)\n- Bug in constructing a :class:`Timestamp` with ``ts_input=pd.NA`` raising ``TypeError`` (:issue:`45481`)\n- Bug in parsing datetime strings with weekday but no day e.g. \"2023 Sept Thu\" incorrectly raising ``AttributeError`` instead of ``ValueError`` (:issue:`52659`)\n- Bug in the repr for :class:`Series` when dtype is a timezone aware datetime with non-nanosecond resolution raising ``OutOfBoundsDatetime`` (:issue:`54623`)\n\nTimedelta\n^^^^^^^^^\n- Bug in :class:`TimedeltaIndex` division or multiplication leading to ``.freq`` of \"0 Days\" instead of ``None`` (:issue:`51575`)\n- Bug in :class:`Timedelta` with NumPy ``timedelta64`` objects not properly raising ``ValueError`` (:issue:`52806`)\n- Bug in :func:`to_timedelta` converting :class:`Series` or :class:`DataFrame` containing :class:`ArrowDtype` of ``pyarrow.duration`` to NumPy ``timedelta64`` (:issue:`54298`)\n- Bug in :meth:`Timedelta.__hash__`, raising an ``OutOfBoundsTimedelta`` on certain large values of second resolution (:issue:`54037`)\n- Bug in :meth:`Timedelta.round` with values close to the implementation bounds returning incorrect results instead of raising ``OutOfBoundsTimedelta`` (:issue:`51494`)\n- Bug in :meth:`TimedeltaIndex.map` with ``na_action=\"ignore\"`` (:issue:`51644`)\n- Bug in :meth:`arrays.TimedeltaArray.map` and :meth:`TimedeltaIndex.map`, where the supplied callable operated array-wise instead of element-wise (:issue:`51977`)\n\nTimezones\n^^^^^^^^^\n- Bug in :func:`infer_freq` that raises ``TypeError`` for ``Series`` of timezone-aware timestamps (:issue:`52456`)\n- Bug in :meth:`DatetimeTZDtype.base` that always returns a NumPy dtype with nanosecond resolution (:issue:`52705`)\n\nNumeric\n^^^^^^^\n- Bug in :class:`RangeIndex` setting ``step`` incorrectly when being the subtrahend with minuend a numeric value (:issue:`53255`)\n- Bug in :meth:`Series.corr` and :meth:`Series.cov` raising ``AttributeError`` for masked dtypes (:issue:`51422`)\n- Bug when calling :meth:`Series.kurt` and :meth:`Series.skew` on NumPy data of all zero returning a Python type instead of a NumPy type (:issue:`53482`)\n- Bug in :meth:`Series.mean`, :meth:`DataFrame.mean` with object-dtype values containing strings that can be converted to numbers (e.g. \"2\") returning incorrect numeric results; these now raise ``TypeError`` (:issue:`36703`, :issue:`44008`)\n- Bug in :meth:`DataFrame.corrwith` raising ``NotImplementedError`` for PyArrow-backed dtypes (:issue:`52314`)\n- Bug in :meth:`DataFrame.size` and :meth:`Series.size` returning 64-bit integer instead of a Python int (:issue:`52897`)\n- Bug in :meth:`DateFrame.dot` returning ``object`` dtype for :class:`ArrowDtype` data (:issue:`53979`)\n- Bug in :meth:`Series.any`, :meth:`Series.all`, :meth:`DataFrame.any`, and :meth:`DataFrame.all` had the default value of ``bool_only`` set to ``None`` instead of ``False``; this change should have no impact on users (:issue:`53258`)\n- Bug in :meth:`Series.corr` and :meth:`Series.cov` raising ``AttributeError`` for masked dtypes (:issue:`51422`)\n- Bug in :meth:`Series.median` and :meth:`DataFrame.median` with object-dtype values containing strings that can be converted to numbers (e.g. \"2\") returning incorrect numeric results; these now raise ``TypeError`` (:issue:`34671`)\n- Bug in :meth:`Series.sum` converting dtype ``uint64`` to ``int64`` (:issue:`53401`)\n\n\nConversion\n^^^^^^^^^^\n- Bug in :func:`DataFrame.style.to_latex` and :func:`DataFrame.style.to_html` if the DataFrame contains integers with more digits than can be represented by floating point double precision (:issue:`52272`)\n- Bug in :func:`array`  when given a ``datetime64`` or ``timedelta64`` dtype with unit of \"s\", \"us\", or \"ms\" returning :class:`.NumpyExtensionArray` instead of :class:`.DatetimeArray` or :class:`.TimedeltaArray` (:issue:`52859`)\n- Bug in :func:`array`  when given an empty list and no dtype returning :class:`.NumpyExtensionArray` instead of :class:`.FloatingArray` (:issue:`54371`)\n- Bug in :meth:`.ArrowDtype.numpy_dtype` returning nanosecond units for non-nanosecond ``pyarrow.timestamp`` and ``pyarrow.duration`` types (:issue:`51800`)\n- Bug in :meth:`DataFrame.__repr__` incorrectly raising a ``TypeError`` when the dtype of a column is ``np.record`` (:issue:`48526`)\n- Bug in :meth:`DataFrame.info` raising  ``ValueError`` when ``use_numba`` is set (:issue:`51922`)\n- Bug in :meth:`DataFrame.insert` raising ``TypeError`` if ``loc`` is ``np.int64`` (:issue:`53193`)\n- Bug in :meth:`HDFStore.select` loses precision of large int when stored and retrieved (:issue:`54186`)\n- Bug in :meth:`Series.astype` not supporting ``object_`` (:issue:`54251`)\n\nStrings\n^^^^^^^\n- Bug in :meth:`Series.str` that did not raise a  ``TypeError`` when iterated (:issue:`54173`)\n- Bug in ``repr`` for :class:`DataFrame`` with string-dtype columns (:issue:`54797`)\n\nInterval\n^^^^^^^^\n- :meth:`IntervalIndex.get_indexer` and :meth:`IntervalIndex.get_indexer_nonunique` raising if ``target`` is read-only array (:issue:`53703`)\n- Bug in :class:`IntervalDtype` where the object could be kept alive when deleted (:issue:`54184`)\n- Bug in :func:`interval_range` where a float ``step`` would produce incorrect intervals from floating point artifacts (:issue:`54477`)\n\nIndexing\n^^^^^^^^\n- Bug in :meth:`DataFrame.__setitem__` losing dtype when setting a :class:`DataFrame` into duplicated columns (:issue:`53143`)\n- Bug in :meth:`DataFrame.__setitem__` with a boolean mask and :meth:`DataFrame.putmask` with mixed non-numeric dtypes and a value other than ``NaN`` incorrectly raising ``TypeError`` (:issue:`53291`)\n- Bug in :meth:`DataFrame.iloc` when using ``nan`` as the only element (:issue:`52234`)\n- Bug in :meth:`Series.loc` casting :class:`Series` to ``np.dnarray`` when assigning :class:`Series` at predefined index of ``object`` dtype :class:`Series` (:issue:`48933`)\n\nMissing\n^^^^^^^\n- Bug in :meth:`DataFrame.interpolate` failing to fill across data when ``method`` is ``\"pad\"``, ``\"ffill\"``, ``\"bfill\"``, or ``\"backfill\"`` (:issue:`53898`)\n- Bug in :meth:`DataFrame.interpolate` ignoring ``inplace`` when :class:`DataFrame` is empty (:issue:`53199`)\n- Bug in :meth:`Series.idxmin`, :meth:`Series.idxmax`, :meth:`DataFrame.idxmin`, :meth:`DataFrame.idxmax` with a :class:`DatetimeIndex` index containing ``NaT`` incorrectly returning ``NaN`` instead of ``NaT`` (:issue:`43587`)\n- Bug in :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` failing to raise on invalid ``downcast`` keyword, which can be only ``None`` or ``\"infer\"`` (:issue:`53103`)\n- Bug in :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` with complex dtype incorrectly failing to fill ``NaN`` entries (:issue:`53635`)\n\nMultiIndex\n^^^^^^^^^^\n- Bug in :meth:`MultiIndex.set_levels` not preserving dtypes for :class:`Categorical` (:issue:`52125`)\n- Bug in displaying a :class:`MultiIndex` with a long element (:issue:`52960`)\n\nI/O\n^^^\n- :meth:`DataFrame.to_orc` now raising ``ValueError`` when non-default :class:`Index` is given (:issue:`51828`)\n- :meth:`DataFrame.to_sql` now raising ``ValueError`` when the name param is left empty while using SQLAlchemy to connect (:issue:`52675`)\n- Bug in :func:`json_normalize` could not parse metadata fields list type (:issue:`37782`)\n- Bug in :func:`read_csv` where it would error when ``parse_dates`` was set to a list or dictionary with ``engine=\"pyarrow\"`` (:issue:`47961`)\n- Bug in :func:`read_csv` with ``engine=\"pyarrow\"`` raising when specifying a ``dtype`` with ``index_col`` (:issue:`53229`)\n- Bug in :func:`read_hdf` not properly closing store after an ``IndexError`` is raised (:issue:`52781`)\n- Bug in :func:`read_html` where style elements were read into DataFrames (:issue:`52197`)\n- Bug in :func:`read_html` where tail texts were removed together with elements containing ``display:none`` style (:issue:`51629`)\n- Bug in :func:`read_sql_table` raising an exception when reading a view (:issue:`52969`)\n- Bug in :func:`read_sql` when reading multiple timezone aware columns with the same column name (:issue:`44421`)\n- Bug in :func:`read_xml` stripping whitespace in string data (:issue:`53811`)\n- Bug in :meth:`DataFrame.to_html` where ``colspace`` was incorrectly applied in case of multi index columns (:issue:`53885`)\n- Bug in :meth:`DataFrame.to_html` where conversion for an empty :class:`DataFrame` with complex dtype raised a ``ValueError`` (:issue:`54167`)\n- Bug in :meth:`DataFrame.to_json` where :class:`.DateTimeArray`/:class:`.DateTimeIndex` with non nanosecond precision could not be serialized correctly (:issue:`53686`)\n- Bug when writing and reading empty Stata dta files where dtype information was lost (:issue:`46240`)\n- Bug where ``bz2`` was treated as a hard requirement (:issue:`53857`)\n\nPeriod\n^^^^^^\n- Bug in :class:`PeriodDtype` constructor failing to raise ``TypeError`` when no argument is passed or when ``None`` is passed (:issue:`27388`)\n- Bug in :class:`PeriodDtype` constructor incorrectly returning the same ``normalize`` for different :class:`DateOffset` ``freq`` inputs (:issue:`24121`)\n- Bug in :class:`PeriodDtype` constructor raising ``ValueError`` instead of ``TypeError`` when an invalid type is passed (:issue:`51790`)\n- Bug in :class:`PeriodDtype` where the object could be kept alive when deleted (:issue:`54184`)\n- Bug in :func:`read_csv` not processing empty strings as a null value, with ``engine=\"pyarrow\"`` (:issue:`52087`)\n- Bug in :func:`read_csv` returning ``object`` dtype columns instead of ``float64`` dtype columns with ``engine=\"pyarrow\"`` for columns that are all null with ``engine=\"pyarrow\"`` (:issue:`52087`)\n- Bug in :meth:`Period.now` not accepting the ``freq`` parameter as a keyword argument (:issue:`53369`)\n- Bug in :meth:`PeriodIndex.map` with ``na_action=\"ignore\"`` (:issue:`51644`)\n- Bug in :meth:`arrays.PeriodArray.map` and :meth:`PeriodIndex.map`, where the supplied callable operated array-wise instead of element-wise (:issue:`51977`)\n- Bug in incorrectly allowing construction of :class:`Period` or :class:`PeriodDtype` with :class:`CustomBusinessDay` freq; use :class:`BusinessDay` instead (:issue:`52534`)\n\nPlotting\n^^^^^^^^\n- Bug in :meth:`Series.plot` when invoked with ``color=None`` (:issue:`51953`)\n- Fixed UserWarning in :meth:`DataFrame.plot.scatter` when invoked with ``c=\"b\"`` (:issue:`53908`)\n\nGroupby/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n- Bug in :meth:`.DataFrameGroupBy.idxmin`, :meth:`.SeriesGroupBy.idxmin`, :meth:`.DataFrameGroupBy.idxmax`, :meth:`.SeriesGroupBy.idxmax` returns wrong dtype when used on an empty DataFrameGroupBy or SeriesGroupBy (:issue:`51423`)\n- Bug in :meth:`DataFrame.groupby.rank` on nullable datatypes when passing ``na_option=\"bottom\"`` or ``na_option=\"top\"`` (:issue:`54206`)\n- Bug in :meth:`DataFrame.resample` and :meth:`Series.resample` in incorrectly allowing non-fixed ``freq`` when resampling on a :class:`TimedeltaIndex` (:issue:`51896`)\n- Bug in :meth:`DataFrame.resample` and :meth:`Series.resample` losing time zone when resampling empty data (:issue:`53664`)\n- Bug in :meth:`DataFrame.resample` and :meth:`Series.resample` where ``origin`` has no effect in resample when values are outside of axis  (:issue:`53662`)\n- Bug in weighted rolling aggregations when specifying ``min_periods=0`` (:issue:`51449`)\n- Bug in :meth:`DataFrame.groupby` and :meth:`Series.groupby` where, when the index of the\n  grouped :class:`Series` or :class:`DataFrame` was a :class:`DatetimeIndex`, :class:`TimedeltaIndex`\n  or :class:`PeriodIndex`, and the ``groupby`` method was given a function as its first argument,\n  the function operated on the whole index rather than each element of the index (:issue:`51979`)\n- Bug in :meth:`.DataFrameGroupBy.agg` with lists not respecting ``as_index=False`` (:issue:`52849`)\n- Bug in :meth:`.DataFrameGroupBy.apply` causing an error to be raised when the input :class:`DataFrame` was subset as a :class:`DataFrame` after groupby (``[['a']]`` and not ``['a']``) and the given callable returned :class:`Series` that were not all indexed the same (:issue:`52444`)\n- Bug in :meth:`.DataFrameGroupBy.apply` raising a ``TypeError`` when selecting multiple columns and providing a function that returns ``np.ndarray`` results (:issue:`18930`)\n- Bug in :meth:`.DataFrameGroupBy.groups` and :meth:`.SeriesGroupBy.groups` with a datetime key in conjunction with another key produced an incorrect number of group keys (:issue:`51158`)\n- Bug in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` may implicitly sort the result index with ``sort=False`` (:issue:`53009`)\n- Bug in :meth:`.SeriesGroupBy.size` where the dtype would be ``np.int64`` for data with :class:`ArrowDtype` or masked dtypes (e.g. ``Int64``) (:issue:`53831`)\n- Bug in :meth:`DataFrame.groupby` with column selection on the resulting groupby object not returning names as tuples when grouping by a list consisting of a single element (:issue:`53500`)\n- Bug in :meth:`.DataFrameGroupBy.var` and :meth:`.SeriesGroupBy.var` failing to raise ``TypeError`` when called with datetime64, timedelta64 or :class:`PeriodDtype` values (:issue:`52128`, :issue:`53045`)\n- Bug in :meth:`.DataFrameGroupBy.resample` with ``kind=\"period\"`` raising ``AttributeError`` (:issue:`24103`)\n- Bug in :meth:`.Resampler.ohlc` with empty object returning a :class:`Series` instead of empty :class:`DataFrame` (:issue:`42902`)\n- Bug in :meth:`.SeriesGroupBy.count` and :meth:`.DataFrameGroupBy.count` where the dtype would be ``np.int64`` for data with :class:`ArrowDtype` or masked dtypes (e.g. ``Int64``) (:issue:`53831`)\n- Bug in :meth:`.SeriesGroupBy.nth` and :meth:`.DataFrameGroupBy.nth` after performing column selection when using ``dropna=\"any\"`` or ``dropna=\"all\"`` would not subset columns (:issue:`53518`)\n- Bug in :meth:`.SeriesGroupBy.nth` and :meth:`.DataFrameGroupBy.nth` raised after performing column selection when using ``dropna=\"any\"`` or ``dropna=\"all\"`` resulted in rows being dropped (:issue:`53518`)\n- Bug in :meth:`.SeriesGroupBy.sum` and :meth:`.DataFrameGroupBy.sum` summing ``np.inf + np.inf`` and ``(-np.inf) + (-np.inf)`` to ``np.nan`` instead of ``np.inf`` and ``-np.inf`` respectively (:issue:`53606`)\n- Bug in :meth:`Series.groupby` raising an error when grouped :class:`Series` has a :class:`DatetimeIndex` index and a :class:`Series` with a name that is a month is given to the ``by`` argument (:issue:`48509`)\n\nReshaping\n^^^^^^^^^\n- Bug in :func:`concat` coercing to ``object`` dtype when one column has ``pa.null()`` dtype (:issue:`53702`)\n- Bug in :func:`crosstab` when ``dropna=False`` would not keep ``np.nan`` in the result (:issue:`10772`)\n- Bug in :func:`melt` where the ``variable`` column would lose extension dtypes (:issue:`54297`)\n- Bug in :func:`merge_asof` raising ``KeyError`` for extension dtypes (:issue:`52904`)\n- Bug in :func:`merge_asof` raising ``ValueError`` for data backed by read-only ndarrays (:issue:`53513`)\n- Bug in :func:`merge_asof` with ``left_index=True`` or ``right_index=True`` with mismatched index dtypes giving incorrect results in some cases instead of raising ``MergeError`` (:issue:`53870`)\n- Bug in :func:`merge` when merging on integer ``ExtensionDtype`` and float NumPy dtype raising ``TypeError`` (:issue:`46178`)\n- Bug in :meth:`DataFrame.agg` and :meth:`Series.agg` on non-unique columns would return incorrect type when dist-like argument passed in (:issue:`51099`)\n- Bug in :meth:`DataFrame.combine_first` ignoring other's columns if ``other`` is empty (:issue:`53792`)\n- Bug in :meth:`DataFrame.idxmin` and :meth:`DataFrame.idxmax`, where the axis dtype would be lost for empty frames (:issue:`53265`)\n- Bug in :meth:`DataFrame.merge` not merging correctly when having ``MultiIndex`` with single level (:issue:`52331`)\n- Bug in :meth:`DataFrame.stack` losing extension dtypes when columns is a :class:`MultiIndex` and frame contains mixed dtypes (:issue:`45740`)\n- Bug in :meth:`DataFrame.stack` sorting columns lexicographically (:issue:`53786`)\n- Bug in :meth:`DataFrame.transpose` inferring dtype for object column (:issue:`51546`)\n- Bug in :meth:`Series.combine_first` converting ``int64`` dtype to ``float64`` and losing precision on very large integers (:issue:`51764`)\n- Bug when joining empty :class:`DataFrame` objects, where the joined index would be a :class:`RangeIndex` instead of the joined index type (:issue:`52777`)\n\nSparse\n^^^^^^\n- Bug in :class:`SparseDtype` constructor failing to raise ``TypeError`` when given an incompatible ``dtype`` for its subtype, which must be a NumPy dtype (:issue:`53160`)\n- Bug in :meth:`arrays.SparseArray.map` allowed the fill value to be included in the sparse values (:issue:`52095`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n- Bug in :class:`.ArrowStringArray` constructor raises ``ValueError`` with dictionary types of strings (:issue:`54074`)\n- Bug in :class:`DataFrame` constructor not copying :class:`Series` with extension dtype when given in dict (:issue:`53744`)\n- Bug in :class:`~arrays.ArrowExtensionArray` converting pandas non-nanosecond temporal objects from non-zero values to zero values (:issue:`53171`)\n- Bug in :meth:`Series.quantile` for PyArrow temporal types raising ``ArrowInvalid`` (:issue:`52678`)\n- Bug in :meth:`Series.rank` returning wrong order for small values with ``Float64`` dtype (:issue:`52471`)\n- Bug in :meth:`Series.unique` for boolean ``ArrowDtype`` with ``NA`` values (:issue:`54667`)\n- Bug in :meth:`~arrays.ArrowExtensionArray.__iter__` and :meth:`~arrays.ArrowExtensionArray.__getitem__` returning python datetime and timedelta objects for non-nano dtypes (:issue:`53326`)\n- Bug in :meth:`~arrays.ArrowExtensionArray.factorize` returning incorrect uniques for a ``pyarrow.dictionary`` type ``pyarrow.chunked_array`` with more than one chunk (:issue:`54844`)\n- Bug when passing an :class:`ExtensionArray` subclass to ``dtype`` keywords. This will now raise a ``UserWarning`` to encourage passing an instance instead (:issue:`31356`, :issue:`54592`)\n- Bug where the :class:`DataFrame` repr would not work when a column had an :class:`ArrowDtype` with a ``pyarrow.ExtensionDtype`` (:issue:`54063`)\n- Bug where the ``__from_arrow__`` method of masked ExtensionDtypes (e.g. :class:`Float64Dtype`, :class:`BooleanDtype`) would not accept PyArrow arrays of type ``pyarrow.null()`` (:issue:`52223`)\n\nStyler\n^^^^^^\n- Bug in :meth:`.Styler._copy` calling overridden methods in subclasses of :class:`.Styler` (:issue:`52728`)\n\nMetadata\n^^^^^^^^\n- Fixed metadata propagation in :meth:`DataFrame.max`, :meth:`DataFrame.min`, :meth:`DataFrame.prod`, :meth:`DataFrame.mean`, :meth:`Series.mode`, :meth:`DataFrame.median`, :meth:`DataFrame.sem`, :meth:`DataFrame.skew`, :meth:`DataFrame.kurt` (:issue:`28283`)\n- Fixed metadata propagation in :meth:`DataFrame.squeeze`, and :meth:`DataFrame.describe` (:issue:`28283`)\n- Fixed metadata propagation in :meth:`DataFrame.std` (:issue:`28283`)\n\nOther\n^^^^^\n- Bug in :class:`.FloatingArray.__contains__` with ``NaN`` item incorrectly returning ``False`` when ``NaN`` values are present (:issue:`52840`)\n- Bug in :class:`DataFrame` and :class:`Series` raising for data of complex dtype when ``NaN`` values are present (:issue:`53627`)\n- Bug in :class:`DatetimeIndex` where ``repr`` of index passed with time does not print time is midnight and non-day based freq(:issue:`53470`)\n- Bug in :func:`.testing.assert_frame_equal` and :func:`.testing.assert_series_equal` now throw assertion error for two unequal sets (:issue:`51727`)\n- Bug in :func:`.testing.assert_frame_equal` checks category dtypes even when asked not to check index type (:issue:`52126`)\n- Bug in :func:`api.interchange.from_dataframe` was not respecting ``allow_copy`` argument (:issue:`54322`)\n- Bug in :func:`api.interchange.from_dataframe` was raising during interchanging from non-pandas tz-aware data containing null values (:issue:`54287`)\n- Bug in :func:`api.interchange.from_dataframe` when converting an empty DataFrame object (:issue:`53155`)\n- Bug in :func:`from_dummies` where the resulting :class:`Index` did not match the original :class:`Index` (:issue:`54300`)\n- Bug in :func:`from_dummies` where the resulting data would always be ``object`` dtype instead of the dtype of the columns (:issue:`54300`)\n- Bug in :meth:`.DataFrameGroupBy.first`, :meth:`.DataFrameGroupBy.last`, :meth:`.SeriesGroupBy.first`, and :meth:`.SeriesGroupBy.last` where an empty group would return ``np.nan`` instead of the corresponding :class:`.ExtensionArray` NA value (:issue:`39098`)\n- Bug in :meth:`DataFrame.pivot_table` with casting the mean of ints back to an int (:issue:`16676`)\n- Bug in :meth:`DataFrame.reindex` with a ``fill_value`` that should be inferred with a :class:`ExtensionDtype` incorrectly inferring ``object`` dtype (:issue:`52586`)\n- Bug in :meth:`DataFrame.shift` with ``axis=1`` on a :class:`DataFrame` with a single :class:`ExtensionDtype` column giving incorrect results (:issue:`53832`)\n- Bug in :meth:`Index.sort_values` when a ``key`` is passed (:issue:`52764`)\n- Bug in :meth:`Series.align`, :meth:`DataFrame.align`, :meth:`Series.reindex`, :meth:`DataFrame.reindex`, :meth:`Series.interpolate`, :meth:`DataFrame.interpolate`, incorrectly failing to raise with method=\"asfreq\" (:issue:`53620`)\n- Bug in :meth:`Series.argsort` failing to raise when an invalid ``axis`` is passed (:issue:`54257`)\n- Bug in :meth:`Series.map` when giving a callable to an empty series, the returned series had ``object`` dtype. It now keeps the original dtype (:issue:`52384`)\n- Bug in :meth:`Series.memory_usage` when ``deep=True`` throw an error with Series of objects and the returned value is incorrect, as it does not take into account GC corrections (:issue:`51858`)\n- Bug in :meth:`period_range` the default behavior when freq was not passed as an argument was incorrect(:issue:`53687`)\n- Fixed incorrect ``__name__`` attribute of ``pandas._libs.json`` (:issue:`52898`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_210.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.0.3..v2.1.0\n", "1.5.0": ".. _whatsnew_150:\n\nWhat's new in 1.5.0 (September 19, 2022)\n----------------------------------------\n\nThese are the changes in pandas 1.5.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_150.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_150.enhancements.pandas-stubs:\n\n``pandas-stubs``\n^^^^^^^^^^^^^^^^\n\nThe ``pandas-stubs`` library is now supported by the pandas development team, providing type stubs for the pandas API. Please visit\nhttps://github.com/pandas-dev/pandas-stubs for more information.\n\nWe thank VirtusLab and Microsoft for their initial, significant contributions to ``pandas-stubs``\n\n.. _whatsnew_150.enhancements.arrow:\n\nNative PyArrow-backed ExtensionArray\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWith `Pyarrow <https://arrow.apache.org/docs/python/index.html>`__ installed, users can now create pandas objects\nthat are backed by a ``pyarrow.ChunkedArray`` and ``pyarrow.DataType``.\n\nThe ``dtype`` argument can accept a string of a `pyarrow data type <https://arrow.apache.org/docs/python/api/datatypes.html>`__\nwith ``pyarrow`` in brackets e.g. ``\"int64[pyarrow]\"`` or, for pyarrow data types that take parameters, a :class:`ArrowDtype`\ninitialized with a ``pyarrow.DataType``.\n\n.. ipython:: python\n\n    import pyarrow as pa\n    ser_float = pd.Series([1.0, 2.0, None], dtype=\"float32[pyarrow]\")\n    ser_float\n\n    list_of_int_type = pd.ArrowDtype(pa.list_(pa.int64()))\n    ser_list = pd.Series([[1, 2], [3, None]], dtype=list_of_int_type)\n    ser_list\n\n    ser_list.take([1, 0])\n    ser_float * 5\n    ser_float.mean()\n    ser_float.dropna()\n\nMost operations are supported and have been implemented using `pyarrow compute <https://arrow.apache.org/docs/python/api/compute.html>`__ functions.\nWe recommend installing the latest version of PyArrow to access the most recently implemented compute functions.\n\n.. warning::\n\n    This feature is experimental, and the API can change in a future release without warning.\n\n.. _whatsnew_150.enhancements.dataframe_interchange:\n\nDataFrame interchange protocol implementation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPandas now implement the DataFrame interchange API spec.\nSee the full details on the API at https://data-apis.org/dataframe-protocol/latest/index.html\n\nThe protocol consists of two parts:\n\n- New method :meth:`DataFrame.__dataframe__` which produces the interchange object.\n  It effectively \"exports\" the pandas dataframe as an interchange object so\n  any other library which has the protocol implemented can \"import\" that dataframe\n  without knowing anything about the producer except that it makes an interchange object.\n- New function :func:`pandas.api.interchange.from_dataframe` which can take\n  an arbitrary interchange object from any conformant library and construct a\n  pandas DataFrame out of it.\n\n.. _whatsnew_150.enhancements.styler:\n\nStyler\n^^^^^^\n\nThe most notable development is the new method :meth:`.Styler.concat` which\nallows adding customised footer rows to visualise additional calculations on the data,\ne.g. totals and counts etc. (:issue:`43875`, :issue:`46186`)\n\nAdditionally there is an alternative output method :meth:`.Styler.to_string`,\nwhich allows using the Styler's formatting methods to create, for example, CSVs (:issue:`44502`).\n\nA new feature :meth:`.Styler.relabel_index` is also made available to provide full customisation of the display of\nindex or column headers (:issue:`47864`)\n\nMinor feature improvements are:\n\n  - Adding the ability to render ``border`` and ``border-{side}`` CSS properties in Excel (:issue:`42276`)\n  - Making keyword arguments consist: :meth:`.Styler.highlight_null` now accepts ``color`` and deprecates ``null_color`` although this remains backwards compatible (:issue:`45907`)\n\n.. _whatsnew_150.enhancements.resample_group_keys:\n\nControl of index with ``group_keys`` in :meth:`DataFrame.resample`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe argument ``group_keys`` has been added to the method :meth:`DataFrame.resample`.\nAs with :meth:`DataFrame.groupby`, this argument controls the whether each group is added\nto the index in the resample when :meth:`.Resampler.apply` is used.\n\n.. warning::\n   Not specifying the ``group_keys`` argument will retain the\n   previous behavior and emit a warning if the result will change\n   by specifying ``group_keys=False``. In a future version\n   of pandas, not specifying ``group_keys`` will default to\n   the same behavior as ``group_keys=False``.\n\n.. code-block:: ipython\n\n    In [11]: df = pd.DataFrame(\n       ....:     {'a': range(6)},\n       ....:     index=pd.date_range(\"2021-01-01\", periods=6, freq=\"8H\")\n       ....: )\n       ....:\n\n    In [12]: df.resample(\"D\", group_keys=True).apply(lambda x: x)\n    Out[12]:\n                                    a\n    2021-01-01 2021-01-01 00:00:00  0\n               2021-01-01 08:00:00  1\n               2021-01-01 16:00:00  2\n    2021-01-02 2021-01-02 00:00:00  3\n               2021-01-02 08:00:00  4\n               2021-01-02 16:00:00  5\n\n    In [13]: df.resample(\"D\", group_keys=False).apply(lambda x: x)\n    Out[13]:\n                         a\n    2021-01-01 00:00:00  0\n    2021-01-01 08:00:00  1\n    2021-01-01 16:00:00  2\n    2021-01-02 00:00:00  3\n    2021-01-02 08:00:00  4\n    2021-01-02 16:00:00  5\n\nPreviously, the resulting index would depend upon the values returned by ``apply``,\nas seen in the following example.\n\n.. code-block:: ipython\n\n    In [1]: # pandas 1.3\n    In [2]: df.resample(\"D\").apply(lambda x: x)\n    Out[2]:\n                         a\n    2021-01-01 00:00:00  0\n    2021-01-01 08:00:00  1\n    2021-01-01 16:00:00  2\n    2021-01-02 00:00:00  3\n    2021-01-02 08:00:00  4\n    2021-01-02 16:00:00  5\n\n    In [3]: df.resample(\"D\").apply(lambda x: x.reset_index())\n    Out[3]:\n                               index  a\n    2021-01-01 0 2021-01-01 00:00:00  0\n               1 2021-01-01 08:00:00  1\n               2 2021-01-01 16:00:00  2\n    2021-01-02 0 2021-01-02 00:00:00  3\n               1 2021-01-02 08:00:00  4\n               2 2021-01-02 16:00:00  5\n\n.. _whatsnew_150.enhancements.from_dummies:\n\nfrom_dummies\n^^^^^^^^^^^^\n\nAdded new function :func:`~pandas.from_dummies` to convert a dummy coded :class:`DataFrame` into a categorical :class:`DataFrame`.\n\n.. ipython:: python\n\n    import pandas as pd\n\n    df = pd.DataFrame({\"col1_a\": [1, 0, 1], \"col1_b\": [0, 1, 0],\n                       \"col2_a\": [0, 1, 0], \"col2_b\": [1, 0, 0],\n                       \"col2_c\": [0, 0, 1]})\n\n    pd.from_dummies(df, sep=\"_\")\n\n.. _whatsnew_150.enhancements.orc:\n\nWriting to ORC files\n^^^^^^^^^^^^^^^^^^^^\n\nThe new method :meth:`DataFrame.to_orc` allows writing to ORC files (:issue:`43864`).\n\nThis functionality depends the `pyarrow <http://arrow.apache.org/docs/python/>`__ library. For more details, see :ref:`the IO docs on ORC <io.orc>`.\n\n.. warning::\n\n   * It is *highly recommended* to install pyarrow using conda due to some issues occurred by pyarrow.\n   * :func:`~pandas.DataFrame.to_orc` requires pyarrow>=7.0.0.\n   * :func:`~pandas.DataFrame.to_orc` is not supported on Windows yet, you can find valid environments on :ref:`install optional dependencies <install.warn_orc>`.\n   * For supported dtypes please refer to `supported ORC features in Arrow <https://arrow.apache.org/docs/cpp/orc.html#data-types>`__.\n   * Currently timezones in datetime columns are not preserved when a dataframe is converted into ORC files.\n\n.. code-block:: python\n\n    df = pd.DataFrame(data={\"col1\": [1, 2], \"col2\": [3, 4]})\n    df.to_orc(\"./out.orc\")\n\n.. _whatsnew_150.enhancements.tar:\n\nReading directly from TAR archives\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nI/O methods like :func:`read_csv` or :meth:`DataFrame.to_json` now allow reading and writing\ndirectly on TAR archives (:issue:`44787`).\n\n.. code-block:: python\n\n   df = pd.read_csv(\"./movement.tar.gz\")\n   # ...\n   df.to_csv(\"./out.tar.gz\")\n\nThis supports ``.tar``, ``.tar.gz``, ``.tar.bz`` and ``.tar.xz2`` archives.\nThe used compression method is inferred from the filename.\nIf the compression method cannot be inferred, use the ``compression`` argument:\n\n.. code-block:: python\n\n   df = pd.read_csv(some_file_obj, compression={\"method\": \"tar\", \"mode\": \"r:gz\"}) # noqa F821\n\n(``mode`` being one of ``tarfile.open``'s modes: https://docs.python.org/3/library/tarfile.html#tarfile.open)\n\n\n.. _whatsnew_150.enhancements.read_xml_dtypes:\n\nread_xml now supports ``dtype``, ``converters``, and ``parse_dates``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSimilar to other IO methods, :func:`pandas.read_xml` now supports assigning specific dtypes to columns,\napply converter methods, and parse dates (:issue:`43567`).\n\n.. ipython:: python\n\n    from io import StringIO\n    xml_dates = \"\"\"<?xml version='1.0' encoding='utf-8'?>\n    <data>\n      <row>\n        <shape>square</shape>\n        <degrees>00360</degrees>\n        <sides>4.0</sides>\n        <date>2020-01-01</date>\n       </row>\n      <row>\n        <shape>circle</shape>\n        <degrees>00360</degrees>\n        <sides/>\n        <date>2021-01-01</date>\n      </row>\n      <row>\n        <shape>triangle</shape>\n        <degrees>00180</degrees>\n        <sides>3.0</sides>\n        <date>2022-01-01</date>\n      </row>\n    </data>\"\"\"\n\n    df = pd.read_xml(\n        StringIO(xml_dates),\n        dtype={'sides': 'Int64'},\n        converters={'degrees': str},\n        parse_dates=['date']\n    )\n    df\n    df.dtypes\n\n\n.. _whatsnew_150.enhancements.read_xml_iterparse:\n\nread_xml now supports large XML using ``iterparse``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor very large XML files that can range in hundreds of megabytes to gigabytes, :func:`pandas.read_xml`\nnow supports parsing such sizeable files using `lxml's iterparse`_ and `etree's iterparse`_\nwhich are memory-efficient methods to iterate through XML trees and extract specific elements\nand attributes without holding entire tree in memory (:issue:`45442`).\n\n.. code-block:: ipython\n\n    In [1]: df = pd.read_xml(\n    ...      \"/path/to/downloaded/enwikisource-latest-pages-articles.xml\",\n    ...      iterparse = {\"page\": [\"title\", \"ns\", \"id\"]})\n    ...  )\n    df\n    Out[2]:\n                                                         title   ns        id\n    0                                       Gettysburg Address    0     21450\n    1                                                Main Page    0     42950\n    2                            Declaration by United Nations    0      8435\n    3             Constitution of the United States of America    0      8435\n    4                     Declaration of Independence (Israel)    0     17858\n    ...                                                    ...  ...       ...\n    3578760               Page:Black cat 1897 07 v2 n10.pdf/17  104    219649\n    3578761               Page:Black cat 1897 07 v2 n10.pdf/43  104    219649\n    3578762               Page:Black cat 1897 07 v2 n10.pdf/44  104    219649\n    3578763      The History of Tom Jones, a Foundling/Book IX    0  12084291\n    3578764  Page:Shakespeare of Stratford (1926) Yale.djvu/91  104     21450\n\n    [3578765 rows x 3 columns]\n\n\n.. _`lxml's iterparse`: https://lxml.de/3.2/parsing.html#iterparse-and-iterwalk\n.. _`etree's iterparse`: https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.iterparse\n\n.. _whatsnew_150.enhancements.copy_on_write:\n\nCopy on Write\n^^^^^^^^^^^^^\n\nA new feature ``copy_on_write`` was added (:issue:`46958`). Copy on write ensures that\nany DataFrame or Series derived from another in any way always behaves as a copy.\nCopy on write disallows updating any other object than the object the method\nwas applied to.\n\nCopy on write can be enabled through:\n\n.. code-block:: python\n\n    pd.set_option(\"mode.copy_on_write\", True)\n    pd.options.mode.copy_on_write = True\n\nAlternatively, copy on write can be enabled locally through:\n\n.. code-block:: python\n\n    with pd.option_context(\"mode.copy_on_write\", True):\n        ...\n\nWithout copy on write, the parent :class:`DataFrame` is updated when updating a child\n:class:`DataFrame` that was derived from this :class:`DataFrame`.\n\n.. ipython:: python\n\n    df = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": 1})\n    view = df[\"foo\"]\n    view.iloc[0]\n    df\n\nWith copy on write enabled, df won't be updated anymore:\n\n.. ipython:: python\n\n    with pd.option_context(\"mode.copy_on_write\", True):\n        df = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": 1})\n        view = df[\"foo\"]\n        view.iloc[0]\n        df\n\nA more detailed explanation can be found `here <https://phofl.github.io/cow-introduction.html>`_.\n\n.. _whatsnew_150.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n- :meth:`Series.map` now raises when ``arg`` is dict but ``na_action`` is not either ``None`` or ``'ignore'`` (:issue:`46588`)\n- :meth:`MultiIndex.to_frame` now supports the argument ``allow_duplicates`` and raises on duplicate labels if it is missing or False (:issue:`45245`)\n- :class:`.StringArray` now accepts array-likes containing nan-likes (``None``, ``np.nan``) for the ``values`` parameter in its constructor in addition to strings and :attr:`pandas.NA`. (:issue:`40839`)\n- Improved the rendering of ``categories`` in :class:`CategoricalIndex` (:issue:`45218`)\n- :meth:`DataFrame.plot` will now allow the ``subplots`` parameter to be a list of iterables specifying column groups, so that columns may be grouped together in the same subplot (:issue:`29688`).\n- :meth:`to_numeric` now preserves float64 arrays when downcasting would generate values not representable in float32 (:issue:`43693`)\n- :meth:`Series.reset_index` and :meth:`DataFrame.reset_index` now support the argument ``allow_duplicates`` (:issue:`44410`)\n- :meth:`.DataFrameGroupBy.min`, :meth:`.SeriesGroupBy.min`, :meth:`.DataFrameGroupBy.max`, and :meth:`.SeriesGroupBy.max` now supports `Numba <https://numba.pydata.org/>`_ execution with the ``engine`` keyword (:issue:`45428`)\n- :func:`read_csv` now supports ``defaultdict`` as a ``dtype`` parameter (:issue:`41574`)\n- :meth:`DataFrame.rolling` and :meth:`Series.rolling` now support a ``step`` parameter with fixed-length windows (:issue:`15354`)\n- Implemented a ``bool``-dtype :class:`Index`, passing a bool-dtype array-like to ``pd.Index`` will now retain ``bool`` dtype instead of casting to ``object`` (:issue:`45061`)\n- Implemented a complex-dtype :class:`Index`, passing a complex-dtype array-like to ``pd.Index`` will now retain complex dtype instead of casting to ``object`` (:issue:`45845`)\n- :class:`Series` and :class:`DataFrame` with :class:`IntegerDtype` now supports bitwise operations (:issue:`34463`)\n- Add ``milliseconds`` field support for :class:`.DateOffset` (:issue:`43371`)\n- :meth:`DataFrame.where` tries to maintain dtype of :class:`DataFrame` if fill value can be cast without loss of precision (:issue:`45582`)\n- :meth:`DataFrame.reset_index` now accepts a ``names`` argument which renames the index names (:issue:`6878`)\n- :func:`concat` now raises when ``levels`` is given but ``keys`` is None (:issue:`46653`)\n- :func:`concat` now raises when ``levels`` contains duplicate values (:issue:`46653`)\n- Added ``numeric_only`` argument to :meth:`DataFrame.corr`, :meth:`DataFrame.corrwith`, :meth:`DataFrame.cov`, :meth:`DataFrame.idxmin`, :meth:`DataFrame.idxmax`, :meth:`.DataFrameGroupBy.idxmin`, :meth:`.DataFrameGroupBy.idxmax`, :meth:`.DataFrameGroupBy.var`, :meth:`.SeriesGroupBy.var`, :meth:`.DataFrameGroupBy.std`, :meth:`.SeriesGroupBy.std`, :meth:`.DataFrameGroupBy.sem`, :meth:`.SeriesGroupBy.sem`, and :meth:`.DataFrameGroupBy.quantile` (:issue:`46560`)\n- A :class:`errors.PerformanceWarning` is now thrown when using ``string[pyarrow]`` dtype with methods that don't dispatch to ``pyarrow.compute`` methods (:issue:`42613`, :issue:`46725`)\n- Added ``validate`` argument to :meth:`DataFrame.join` (:issue:`46622`)\n- Added ``numeric_only`` argument to :meth:`.Resampler.sum`, :meth:`.Resampler.prod`, :meth:`.Resampler.min`, :meth:`.Resampler.max`, :meth:`.Resampler.first`, and :meth:`.Resampler.last` (:issue:`46442`)\n- ``times`` argument in :class:`.ExponentialMovingWindow` now accepts ``np.timedelta64`` (:issue:`47003`)\n- :class:`.DataError`, :class:`.SpecificationError`, :class:`.SettingWithCopyError`, :class:`.SettingWithCopyWarning`, :class:`.NumExprClobberingError`, :class:`.UndefinedVariableError`, :class:`.IndexingError`, :class:`.PyperclipException`, :class:`.PyperclipWindowsException`, :class:`.CSSWarning`, :class:`.PossibleDataLossError`, :class:`.ClosedFileError`, :class:`.IncompatibilityWarning`, :class:`.AttributeConflictWarning`, :class:`.DatabaseError`, :class:`.PossiblePrecisionLoss`, :class:`.ValueLabelTypeMismatch`, :class:`.InvalidColumnName`, and :class:`.CategoricalConversionWarning` are now exposed in ``pandas.errors`` (:issue:`27656`)\n- Added ``check_like`` argument to :func:`testing.assert_series_equal` (:issue:`47247`)\n- Add support for :meth:`.DataFrameGroupBy.ohlc` and :meth:`.SeriesGroupBy.ohlc` for extension array dtypes (:issue:`37493`)\n- Allow reading compressed SAS files with :func:`read_sas` (e.g., ``.sas7bdat.gz`` files)\n- :func:`pandas.read_html` now supports extracting links from table cells (:issue:`13141`)\n- :meth:`DatetimeIndex.astype` now supports casting timezone-naive indexes to ``datetime64[s]``, ``datetime64[ms]``, and ``datetime64[us]``, and timezone-aware indexes to the corresponding ``datetime64[unit, tzname]`` dtypes (:issue:`47579`)\n- :class:`Series` reducers (e.g. ``min``, ``max``, ``sum``, ``mean``) will now successfully operate when the dtype is numeric and ``numeric_only=True`` is provided; previously this would raise a ``NotImplementedError`` (:issue:`47500`)\n- :meth:`RangeIndex.union` now can return a :class:`RangeIndex` instead of a :class:`Int64Index` if the resulting values are equally spaced (:issue:`47557`, :issue:`43885`)\n- :meth:`DataFrame.compare` now accepts an argument ``result_names`` to allow the user to specify the result's names of both left and right DataFrame which are being compared. This is by default ``'self'`` and ``'other'`` (:issue:`44354`)\n- :meth:`DataFrame.quantile` gained a ``method`` argument that can accept ``table`` to evaluate multi-column quantiles (:issue:`43881`)\n- :class:`Interval` now supports checking whether one interval is contained by another interval (:issue:`46613`)\n- Added ``copy`` keyword to :meth:`Series.set_axis` and :meth:`DataFrame.set_axis` to allow user to set axis on a new object without necessarily copying the underlying data (:issue:`47932`)\n- The method :meth:`.ExtensionArray.factorize` accepts ``use_na_sentinel=False`` for determining how null values are to be treated (:issue:`46601`)\n- The ``Dockerfile`` now installs a dedicated ``pandas-dev`` virtual environment for pandas development instead of using the ``base`` environment (:issue:`48427`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_150.notable_bug_fixes:\n\nNotable bug fixes\n~~~~~~~~~~~~~~~~~\n\nThese are bug fixes that might have notable behavior changes.\n\n.. _whatsnew_150.notable_bug_fixes.groupby_transform_dropna:\n\nUsing ``dropna=True`` with ``groupby`` transforms\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA transform is an operation whose result has the same size as its input. When the\nresult is a :class:`DataFrame` or :class:`Series`, it is also required that the\nindex of the result matches that of the input. In pandas 1.4, using\n:meth:`.DataFrameGroupBy.transform` or :meth:`.SeriesGroupBy.transform` with null\nvalues in the groups and ``dropna=True`` gave incorrect results. Demonstrated by the\nexamples below, the incorrect results either contained incorrect values, or the result\ndid not have the same index as the input.\n\n.. ipython:: python\n\n    df = pd.DataFrame({'a': [1, 1, np.nan], 'b': [2, 3, 4]})\n\n*Old behavior*:\n\n.. code-block:: ipython\n\n    In [3]: # Value in the last row should be np.nan\n            df.groupby('a', dropna=True).transform('sum')\n    Out[3]:\n       b\n    0  5\n    1  5\n    2  5\n\n    In [3]: # Should have one additional row with the value np.nan\n            df.groupby('a', dropna=True).transform(lambda x: x.sum())\n    Out[3]:\n       b\n    0  5\n    1  5\n\n    In [3]: # The value in the last row is np.nan interpreted as an integer\n            df.groupby('a', dropna=True).transform('ffill')\n    Out[3]:\n                         b\n    0                    2\n    1                    3\n    2 -9223372036854775808\n\n    In [3]: # Should have one additional row with the value np.nan\n            df.groupby('a', dropna=True).transform(lambda x: x)\n    Out[3]:\n       b\n    0  2\n    1  3\n\n*New behavior*:\n\n.. ipython:: python\n\n    df.groupby('a', dropna=True).transform('sum')\n    df.groupby('a', dropna=True).transform(lambda x: x.sum())\n    df.groupby('a', dropna=True).transform('ffill')\n    df.groupby('a', dropna=True).transform(lambda x: x)\n\n.. _whatsnew_150.notable_bug_fixes.to_json_incorrectly_localizing_naive_timestamps:\n\nSerializing tz-naive Timestamps with to_json() with ``iso_dates=True``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`DataFrame.to_json`, :meth:`Series.to_json`, and :meth:`Index.to_json`\nwould incorrectly localize DatetimeArrays/DatetimeIndexes with tz-naive Timestamps\nto UTC. (:issue:`38760`)\n\nNote that this patch does not fix the localization of tz-aware Timestamps to UTC\nupon serialization. (Related issue :issue:`12997`)\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [32]: index = pd.date_range(\n       ....:     start='2020-12-28 00:00:00',\n       ....:     end='2020-12-28 02:00:00',\n       ....:     freq='1H',\n       ....: )\n       ....:\n\n    In [33]: a = pd.Series(\n       ....:     data=range(3),\n       ....:     index=index,\n       ....: )\n       ....:\n\n    In [4]: from io import StringIO\n\n    In [5]: a.to_json(date_format='iso')\n    Out[5]: '{\"2020-12-28T00:00:00.000Z\":0,\"2020-12-28T01:00:00.000Z\":1,\"2020-12-28T02:00:00.000Z\":2}'\n\n    In [6]: pd.read_json(StringIO(a.to_json(date_format='iso')), typ=\"series\").index == a.index\n    Out[6]: array([False, False, False])\n\n*New Behavior*\n\n.. code-block:: ipython\n\n    In [34]: from io import StringIO\n\n    In [35]: a.to_json(date_format='iso')\n    Out[35]: '{\"2020-12-28T00:00:00.000Z\":0,\"2020-12-28T01:00:00.000Z\":1,\"2020-12-28T02:00:00.000Z\":2}'\n\n    # Roundtripping now works\n    In [36]: pd.read_json(StringIO(a.to_json(date_format='iso')), typ=\"series\").index == a.index\n    Out[36]: array([ True,  True,  True])\n\n.. _whatsnew_150.notable_bug_fixes.groupby_value_counts_categorical:\n\nDataFrameGroupBy.value_counts with non-grouping categorical columns and ``observed=True``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nCalling :meth:`.DataFrameGroupBy.value_counts` with ``observed=True`` would incorrectly drop non-observed categories of non-grouping columns (:issue:`46357`).\n\n.. code-block:: ipython\n\n    In [6]: df = pd.DataFrame([\"a\", \"b\", \"c\"], dtype=\"category\").iloc[0:2]\n    In [7]: df\n    Out[7]:\n       0\n    0  a\n    1  b\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [8]: df.groupby(level=0, observed=True).value_counts()\n    Out[8]:\n    0  a    1\n    1  b    1\n    dtype: int64\n\n\n*New Behavior*\n\n.. code-block:: ipython\n\n    In [9]: df.groupby(level=0, observed=True).value_counts()\n    Out[9]:\n    0  a    1\n    1  a    0\n       b    1\n    0  b    0\n       c    0\n    1  c    0\n    dtype: int64\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_150.api_breaking:\n\nBackwards incompatible API changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_150.api_breaking.deps:\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSome minimum supported versions of dependencies were updated.\nIf installed, we now require:\n\n+-----------------+-----------------+----------+---------+\n| Package         | Minimum Version | Required | Changed |\n+=================+=================+==========+=========+\n| numpy           | 1.20.3          |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| mypy (dev)      | 0.971           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| beautifulsoup4  | 4.9.3           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| blosc           | 1.21.0          |          |    X    |\n+-----------------+-----------------+----------+---------+\n| bottleneck      | 1.3.2           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| fsspec          | 2021.07.0       |          |    X    |\n+-----------------+-----------------+----------+---------+\n| hypothesis      | 6.13.0          |          |    X    |\n+-----------------+-----------------+----------+---------+\n| gcsfs           | 2021.07.0       |          |    X    |\n+-----------------+-----------------+----------+---------+\n| jinja2          | 3.0.0           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| lxml            | 4.6.3           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| numba           | 0.53.1          |          |    X    |\n+-----------------+-----------------+----------+---------+\n| numexpr         | 2.7.3           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| openpyxl        | 3.0.7           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| pandas-gbq      | 0.15.0          |          |    X    |\n+-----------------+-----------------+----------+---------+\n| psycopg2        | 2.8.6           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| pymysql         | 1.0.2           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| pyreadstat      | 1.1.2           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| pyxlsb          | 1.0.8           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| s3fs            | 2021.08.0       |          |    X    |\n+-----------------+-----------------+----------+---------+\n| scipy           | 1.7.1           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| sqlalchemy      | 1.4.16          |          |    X    |\n+-----------------+-----------------+----------+---------+\n| tabulate        | 0.8.9           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| xarray          | 0.19.0          |          |    X    |\n+-----------------+-----------------+----------+---------+\n| xlsxwriter      | 1.4.3           |          |    X    |\n+-----------------+-----------------+----------+---------+\n\nFor `optional libraries <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\nThe following table lists the lowest version per library that is currently being tested throughout the development of pandas.\nOptional libraries below the lowest tested version may still work, but are not considered supported.\n\n+-----------------+-----------------+---------+\n| Package         | Minimum Version | Changed |\n+=================+=================+=========+\n| beautifulsoup4  |4.9.3            |    X    |\n+-----------------+-----------------+---------+\n| blosc           |1.21.0           |    X    |\n+-----------------+-----------------+---------+\n| bottleneck      |1.3.2            |    X    |\n+-----------------+-----------------+---------+\n| brotlipy        |0.7.0            |         |\n+-----------------+-----------------+---------+\n| fastparquet     |0.4.0            |         |\n+-----------------+-----------------+---------+\n| fsspec          |2021.08.0        |    X    |\n+-----------------+-----------------+---------+\n| html5lib        |1.1              |         |\n+-----------------+-----------------+---------+\n| hypothesis      |6.13.0           |    X    |\n+-----------------+-----------------+---------+\n| gcsfs           |2021.08.0        |    X    |\n+-----------------+-----------------+---------+\n| jinja2          |3.0.0            |    X    |\n+-----------------+-----------------+---------+\n| lxml            |4.6.3            |    X    |\n+-----------------+-----------------+---------+\n| matplotlib      |3.3.2            |         |\n+-----------------+-----------------+---------+\n| numba           |0.53.1           |    X    |\n+-----------------+-----------------+---------+\n| numexpr         |2.7.3            |    X    |\n+-----------------+-----------------+---------+\n| odfpy           |1.4.1            |         |\n+-----------------+-----------------+---------+\n| openpyxl        |3.0.7            |    X    |\n+-----------------+-----------------+---------+\n| pandas-gbq      |0.15.0           |    X    |\n+-----------------+-----------------+---------+\n| psycopg2        |2.8.6            |    X    |\n+-----------------+-----------------+---------+\n| pyarrow         |1.0.1            |         |\n+-----------------+-----------------+---------+\n| pymysql         |1.0.2            |    X    |\n+-----------------+-----------------+---------+\n| pyreadstat      |1.1.2            |    X    |\n+-----------------+-----------------+---------+\n| pytables        |3.6.1            |         |\n+-----------------+-----------------+---------+\n| python-snappy   |0.6.0            |         |\n+-----------------+-----------------+---------+\n| pyxlsb          |1.0.8            |    X    |\n+-----------------+-----------------+---------+\n| s3fs            |2021.08.0        |    X    |\n+-----------------+-----------------+---------+\n| scipy           |1.7.1            |    X    |\n+-----------------+-----------------+---------+\n| sqlalchemy      |1.4.16           |    X    |\n+-----------------+-----------------+---------+\n| tabulate        |0.8.9            |    X    |\n+-----------------+-----------------+---------+\n| tzdata          |2022a            |         |\n+-----------------+-----------------+---------+\n| xarray          |0.19.0           |    X    |\n+-----------------+-----------------+---------+\n| xlrd            |2.0.1            |         |\n+-----------------+-----------------+---------+\n| xlsxwriter      |1.4.3            |    X    |\n+-----------------+-----------------+---------+\n| xlwt            |1.3.0            |         |\n+-----------------+-----------------+---------+\n| zstandard       |0.15.2           |         |\n+-----------------+-----------------+---------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\n.. _whatsnew_150.api_breaking.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n\n- BigQuery I/O methods :func:`read_gbq` and :meth:`DataFrame.to_gbq` default to\n  ``auth_local_webserver = True``. Google has deprecated the\n  ``auth_local_webserver = False`` `\"out of band\" (copy-paste) flow\n  <https://developers.googleblog.com/2022/02/making-oauth-flows-safer.html?m=1#disallowed-oob>`_.\n  The ``auth_local_webserver = False`` option is planned to stop working in\n  October 2022. (:issue:`46312`)\n- :func:`read_json` now raises ``FileNotFoundError`` (previously ``ValueError``) when input is a string ending in ``.json``, ``.json.gz``, ``.json.bz2``, etc. but no such file exists. (:issue:`29102`)\n- Operations with :class:`Timestamp` or :class:`Timedelta` that would previously raise ``OverflowError`` instead raise ``OutOfBoundsDatetime`` or ``OutOfBoundsTimedelta`` where appropriate (:issue:`47268`)\n- When :func:`read_sas` previously returned ``None``, it now returns an empty :class:`DataFrame` (:issue:`47410`)\n- :class:`DataFrame` constructor raises if ``index`` or ``columns`` arguments are sets (:issue:`47215`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_150.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\n.. warning::\n\n    In the next major version release, 2.0, several larger API changes are being considered without a formal deprecation such as\n    making the standard library `zoneinfo <https://docs.python.org/3/library/zoneinfo.html>`_ the default timezone implementation instead of ``pytz``,\n    having the :class:`Index` support all data types instead of having multiple subclasses (:class:`CategoricalIndex`, :class:`Int64Index`, etc.), and more.\n    The changes under consideration are logged in `this GitHub issue <https://github.com/pandas-dev/pandas/issues/44823>`_, and any\n    feedback or concerns are welcome.\n\n.. _whatsnew_150.deprecations.int_slicing_series:\n\nLabel-based integer slicing on a Series with an Int64Index or RangeIndex\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn a future version, integer slicing on a :class:`Series` with a :class:`Int64Index` or :class:`RangeIndex` will be treated as *label-based*, not positional. This will make the behavior consistent with other :meth:`Series.__getitem__` and :meth:`Series.__setitem__` behaviors (:issue:`45162`).\n\nFor example:\n\n.. ipython:: python\n\n   ser = pd.Series([1, 2, 3, 4, 5], index=[2, 3, 5, 7, 11])\n\nIn the old behavior, ``ser[2:4]`` treats the slice as positional:\n\n*Old behavior*:\n\n.. code-block:: ipython\n\n    In [3]: ser[2:4]\n    Out[3]:\n    5    3\n    7    4\n    dtype: int64\n\nIn a future version, this will be treated as label-based:\n\n*Future behavior*:\n\n.. code-block:: ipython\n\n    In [4]: ser.loc[2:4]\n    Out[4]:\n    2    1\n    3    2\n    dtype: int64\n\nTo retain the old behavior, use ``series.iloc[i:j]``. To get the future behavior,\nuse ``series.loc[i:j]``.\n\nSlicing on a :class:`DataFrame` will not be affected.\n\n.. _whatsnew_150.deprecations.excel_writer_attributes:\n\n:class:`ExcelWriter` attributes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAll attributes of :class:`ExcelWriter` were previously documented as not\npublic. However some third party Excel engines documented accessing\n``ExcelWriter.book`` or ``ExcelWriter.sheets``, and users were utilizing these\nand possibly other attributes. Previously these attributes were not safe to use;\ne.g. modifications to ``ExcelWriter.book`` would not update ``ExcelWriter.sheets``\nand conversely. In order to support this, pandas has made some attributes public\nand improved their implementations so that they may now be safely used. (:issue:`45572`)\n\nThe following attributes are now public and considered safe to access.\n\n - ``book``\n - ``check_extension``\n - ``close``\n - ``date_format``\n - ``datetime_format``\n - ``engine``\n - ``if_sheet_exists``\n - ``sheets``\n - ``supported_extensions``\n\nThe following attributes have been deprecated. They now raise a ``FutureWarning``\nwhen accessed and will be removed in a future version. Users should be aware\nthat their usage is considered unsafe, and can lead to unexpected results.\n\n - ``cur_sheet``\n - ``handles``\n - ``path``\n - ``save``\n - ``write_cells``\n\nSee the documentation of :class:`ExcelWriter` for further details.\n\n.. _whatsnew_150.deprecations.group_keys_in_apply:\n\nUsing ``group_keys`` with transformers in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn previous versions of pandas, if it was inferred that the function passed to\n:meth:`.DataFrameGroupBy.apply` or :meth:`.SeriesGroupBy.apply` was a transformer (i.e. the resulting index was equal to\nthe input index), the ``group_keys`` argument of :meth:`DataFrame.groupby` and\n:meth:`Series.groupby` was ignored and the group keys would never be added to\nthe index of the result. In the future, the group keys will be added to the index\nwhen the user specifies ``group_keys=True``.\n\nAs ``group_keys=True`` is the default value of :meth:`DataFrame.groupby` and\n:meth:`Series.groupby`, not specifying ``group_keys`` with a transformer will\nraise a ``FutureWarning``. This can be silenced and the previous behavior\nretained by specifying ``group_keys=False``.\n\n.. _whatsnew_150.deprecations.setitem_column_try_inplace:\n   _ see also _whatsnew_130.notable_bug_fixes.setitem_column_try_inplace\n\nInplace operation when setting values with ``loc`` and ``iloc``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nMost of the time setting values with :meth:`DataFrame.iloc` attempts to set values\ninplace, only falling back to inserting a new array if necessary. There are\nsome cases where this rule is not followed, for example when setting an entire\ncolumn from an array with different dtype:\n\n.. ipython:: python\n\n   df = pd.DataFrame({'price': [11.1, 12.2]}, index=['book1', 'book2'])\n   original_prices = df['price']\n   new_prices = np.array([98, 99])\n\n*Old behavior*:\n\n.. code-block:: ipython\n\n    In [3]: df.iloc[:, 0] = new_prices\n    In [4]: df.iloc[:, 0]\n    Out[4]:\n    book1    98\n    book2    99\n    Name: price, dtype: int64\n    In [5]: original_prices\n    Out[5]:\n    book1    11.1\n    book2    12.2\n    Name: price, float: 64\n\nThis behavior is deprecated. In a future version, setting an entire column with\niloc will attempt to operate inplace.\n\n*Future behavior*:\n\n.. code-block:: ipython\n\n    In [3]: df.iloc[:, 0] = new_prices\n    In [4]: df.iloc[:, 0]\n    Out[4]:\n    book1    98.0\n    book2    99.0\n    Name: price, dtype: float64\n    In [5]: original_prices\n    Out[5]:\n    book1    98.0\n    book2    99.0\n    Name: price, dtype: float64\n\nTo get the old behavior, use :meth:`DataFrame.__setitem__` directly:\n\n.. code-block:: ipython\n\n    In [3]: df[df.columns[0]] = new_prices\n    In [4]: df.iloc[:, 0]\n    Out[4]\n    book1    98\n    book2    99\n    Name: price, dtype: int64\n    In [5]: original_prices\n    Out[5]:\n    book1    11.1\n    book2    12.2\n    Name: price, dtype: float64\n\nTo get the old behaviour when ``df.columns`` is not unique and you want to\nchange a single column by index, you can use :meth:`DataFrame.isetitem`, which\nhas been added in pandas 1.5:\n\n.. code-block:: ipython\n\n    In [3]: df_with_duplicated_cols = pd.concat([df, df], axis='columns')\n    In [3]: df_with_duplicated_cols.isetitem(0, new_prices)\n    In [4]: df_with_duplicated_cols.iloc[:, 0]\n    Out[4]:\n    book1    98\n    book2    99\n    Name: price, dtype: int64\n    In [5]: original_prices\n    Out[5]:\n    book1    11.1\n    book2    12.2\n    Name: 0, dtype: float64\n\n.. _whatsnew_150.deprecations.numeric_only_default:\n\n``numeric_only`` default value\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAcross the :class:`DataFrame`, :class:`.DataFrameGroupBy`, and :class:`.Resampler` operations such as\n``min``, ``sum``, and ``idxmax``, the default\nvalue of the ``numeric_only`` argument, if it exists at all, was inconsistent.\nFurthermore, operations with the default value ``None`` can lead to surprising\nresults. (:issue:`46560`)\n\n.. code-block:: ipython\n\n    In [1]: df = pd.DataFrame({\"a\": [1, 2], \"b\": [\"x\", \"y\"]})\n\n    In [2]: # Reading the next line without knowing the contents of df, one would\n            # expect the result to contain the products for both columns a and b.\n            df[[\"a\", \"b\"]].prod()\n    Out[2]:\n    a    2\n    dtype: int64\n\nTo avoid this behavior, the specifying the value ``numeric_only=None`` has been\ndeprecated, and will be removed in a future version of pandas. In the future,\nall operations with a ``numeric_only`` argument will default to ``False``. Users\nshould either call the operation only with columns that can be operated on, or\nspecify ``numeric_only=True`` to operate only on Boolean, integer, and float columns.\n\nIn order to support the transition to the new behavior, the following methods have\ngained the ``numeric_only`` argument.\n\n- :meth:`DataFrame.corr`\n- :meth:`DataFrame.corrwith`\n- :meth:`DataFrame.cov`\n- :meth:`DataFrame.idxmin`\n- :meth:`DataFrame.idxmax`\n- :meth:`.DataFrameGroupBy.cummin`\n- :meth:`.DataFrameGroupBy.cummax`\n- :meth:`.DataFrameGroupBy.idxmin`\n- :meth:`.DataFrameGroupBy.idxmax`\n- :meth:`.DataFrameGroupBy.var`\n- :meth:`.DataFrameGroupBy.std`\n- :meth:`.DataFrameGroupBy.sem`\n- :meth:`.DataFrameGroupBy.quantile`\n- :meth:`.Resampler.mean`\n- :meth:`.Resampler.median`\n- :meth:`.Resampler.sem`\n- :meth:`.Resampler.std`\n- :meth:`.Resampler.var`\n- :meth:`DataFrame.rolling` operations\n- :meth:`DataFrame.expanding` operations\n- :meth:`DataFrame.ewm` operations\n\n.. _whatsnew_150.deprecations.other:\n\nOther Deprecations\n^^^^^^^^^^^^^^^^^^\n- Deprecated the keyword ``line_terminator`` in :meth:`DataFrame.to_csv` and :meth:`Series.to_csv`, use ``lineterminator`` instead; this is for consistency with :func:`read_csv` and the standard library 'csv' module (:issue:`9568`)\n- Deprecated behavior of :meth:`SparseArray.astype`, :meth:`Series.astype`, and :meth:`DataFrame.astype` with :class:`SparseDtype` when passing a non-sparse ``dtype``. In a future version, this will cast to that non-sparse dtype instead of wrapping it in a :class:`SparseDtype` (:issue:`34457`)\n- Deprecated behavior of :meth:`DatetimeIndex.intersection` and :meth:`DatetimeIndex.symmetric_difference` (``union`` behavior was already deprecated in version 1.3.0) with mixed time zones; in a future version both will be cast to UTC instead of object dtype (:issue:`39328`, :issue:`45357`)\n- Deprecated :meth:`DataFrame.iteritems`, :meth:`Series.iteritems`, :meth:`HDFStore.iteritems` in favor of :meth:`DataFrame.items`, :meth:`Series.items`, :meth:`HDFStore.items`  (:issue:`45321`)\n- Deprecated :meth:`Series.is_monotonic` and :meth:`Index.is_monotonic` in favor of :meth:`Series.is_monotonic_increasing` and :meth:`Index.is_monotonic_increasing` (:issue:`45422`, :issue:`21335`)\n- Deprecated behavior of :meth:`DatetimeIndex.astype`, :meth:`TimedeltaIndex.astype`, :meth:`PeriodIndex.astype` when converting to an integer dtype other than ``int64``. In a future version, these will convert to exactly the specified dtype (instead of always ``int64``) and will raise if the conversion overflows (:issue:`45034`)\n- Deprecated the ``__array_wrap__`` method of DataFrame and Series, rely on standard numpy ufuncs instead (:issue:`45451`)\n- Deprecated treating float-dtype data as wall-times when passed with a timezone to :class:`Series` or :class:`DatetimeIndex` (:issue:`45573`)\n- Deprecated the behavior of :meth:`Series.fillna` and :meth:`DataFrame.fillna` with ``timedelta64[ns]`` dtype and incompatible fill value; in a future version this will cast to a common dtype (usually object) instead of raising, matching the behavior of other dtypes (:issue:`45746`)\n- Deprecated the ``warn`` parameter in :func:`infer_freq` (:issue:`45947`)\n- Deprecated allowing non-keyword arguments in :meth:`.ExtensionArray.argsort` (:issue:`46134`)\n- Deprecated treating all-bool ``object``-dtype columns as bool-like in :meth:`DataFrame.any` and :meth:`DataFrame.all` with ``bool_only=True``, explicitly cast to bool instead (:issue:`46188`)\n- Deprecated behavior of method :meth:`DataFrame.quantile`, attribute ``numeric_only`` will default False. Including datetime/timedelta columns in the result (:issue:`7308`).\n- Deprecated :attr:`Timedelta.freq` and :attr:`Timedelta.is_populated` (:issue:`46430`)\n- Deprecated :attr:`Timedelta.delta` (:issue:`46476`)\n- Deprecated passing arguments as positional in :meth:`DataFrame.any` and :meth:`Series.any` (:issue:`44802`)\n- Deprecated passing positional arguments to :meth:`DataFrame.pivot` and :func:`pivot` except ``data`` (:issue:`30228`)\n- Deprecated the methods :meth:`DataFrame.mad`, :meth:`Series.mad`, and the corresponding groupby methods (:issue:`11787`)\n- Deprecated positional arguments to :meth:`Index.join` except for ``other``, use keyword-only arguments instead of positional arguments (:issue:`46518`)\n- Deprecated positional arguments to :meth:`StringMethods.rsplit` and :meth:`StringMethods.split` except for ``pat``, use keyword-only arguments instead of positional arguments (:issue:`47423`)\n- Deprecated indexing on a timezone-naive :class:`DatetimeIndex` using a string representing a timezone-aware datetime (:issue:`46903`, :issue:`36148`)\n- Deprecated allowing ``unit=\"M\"`` or ``unit=\"Y\"`` in :class:`Timestamp` constructor with a non-round float value (:issue:`47267`)\n- Deprecated the ``display.column_space`` global configuration option (:issue:`7576`)\n- Deprecated the argument ``na_sentinel`` in :func:`factorize`, :meth:`Index.factorize`, and :meth:`.ExtensionArray.factorize`; pass ``use_na_sentinel=True`` instead to use the sentinel ``-1`` for NaN values and ``use_na_sentinel=False`` instead of ``na_sentinel=None`` to encode NaN values (:issue:`46910`)\n- Deprecated :meth:`.DataFrameGroupBy.transform` not aligning the result when the UDF returned DataFrame (:issue:`45648`)\n- Clarified warning from :func:`to_datetime` when delimited dates can't be parsed in accordance to specified ``dayfirst`` argument (:issue:`46210`)\n- Emit warning from :func:`to_datetime` when delimited dates can't be parsed in accordance to specified ``dayfirst`` argument even for dates where leading zero is omitted (e.g. ``31/1/2001``) (:issue:`47880`)\n- Deprecated :class:`Series` and :class:`Resampler` reducers (e.g. ``min``, ``max``, ``sum``, ``mean``) raising a ``NotImplementedError`` when the dtype is non-numric and ``numeric_only=True`` is provided; this will raise a ``TypeError`` in a future version (:issue:`47500`)\n- Deprecated :meth:`Series.rank` returning an empty result when the dtype is non-numeric and ``numeric_only=True`` is provided; this will raise a ``TypeError`` in a future version (:issue:`47500`)\n- Deprecated argument ``errors`` for :meth:`Series.mask`, :meth:`Series.where`, :meth:`DataFrame.mask`, and :meth:`DataFrame.where` as ``errors`` had no effect on this methods (:issue:`47728`)\n- Deprecated arguments ``*args`` and ``**kwargs`` in :class:`Rolling`, :class:`Expanding`, and :class:`ExponentialMovingWindow` ops. (:issue:`47836`)\n- Deprecated the ``inplace`` keyword in :meth:`Categorical.set_ordered`, :meth:`Categorical.as_ordered`, and :meth:`Categorical.as_unordered` (:issue:`37643`)\n- Deprecated setting a categorical's categories with ``cat.categories = ['a', 'b', 'c']``, use :meth:`Categorical.rename_categories` instead (:issue:`37643`)\n- Deprecated unused arguments ``encoding`` and ``verbose`` in :meth:`Series.to_excel` and :meth:`DataFrame.to_excel` (:issue:`47912`)\n- Deprecated the ``inplace`` keyword in :meth:`DataFrame.set_axis` and :meth:`Series.set_axis`, use ``obj = obj.set_axis(..., copy=False)`` instead (:issue:`48130`)\n- Deprecated producing a single element when iterating over a :class:`DataFrameGroupBy` or a :class:`SeriesGroupBy` that has been grouped by a list of length 1; A tuple of length one will be returned instead (:issue:`42795`)\n- Fixed up warning message of deprecation of :meth:`MultiIndex.lesort_depth` as public method, as the message previously referred to :meth:`MultiIndex.is_lexsorted` instead (:issue:`38701`)\n- Deprecated the ``sort_columns`` argument in :meth:`DataFrame.plot` and :meth:`Series.plot` (:issue:`47563`).\n- Deprecated positional arguments for all but the first argument of :meth:`DataFrame.to_stata` and :func:`read_stata`, use keyword arguments instead (:issue:`48128`).\n- Deprecated the ``mangle_dupe_cols`` argument in :func:`read_csv`, :func:`read_fwf`, :func:`read_table` and :func:`read_excel`. The argument was never implemented, and a new argument where the renaming pattern can be specified will be added instead (:issue:`47718`)\n- Deprecated allowing ``dtype='datetime64'`` or ``dtype=np.datetime64`` in :meth:`Series.astype`, use \"datetime64[ns]\" instead (:issue:`47844`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_150.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- Performance improvement in :meth:`DataFrame.corrwith` for column-wise (axis=0) Pearson and Spearman correlation when other is a :class:`Series` (:issue:`46174`)\n- Performance improvement in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` for some user-defined DataFrame -> Series functions (:issue:`45387`)\n- Performance improvement in :meth:`DataFrame.duplicated` when subset consists of only one column (:issue:`45236`)\n- Performance improvement in :meth:`.DataFrameGroupBy.diff` and :meth:`.SeriesGroupBy.diff` (:issue:`16706`)\n- Performance improvement in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` when broadcasting values for user-defined functions (:issue:`45708`)\n- Performance improvement in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` for user-defined functions when only a single group exists (:issue:`44977`)\n- Performance improvement in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` when grouping on a non-unique unsorted index (:issue:`46527`)\n- Performance improvement in :meth:`DataFrame.loc` and :meth:`Series.loc` for tuple-based indexing of a :class:`MultiIndex` (:issue:`45681`, :issue:`46040`, :issue:`46330`)\n- Performance improvement in :meth:`.DataFrameGroupBy.var` and :meth:`.SeriesGroupBy.var` with ``ddof`` other than one (:issue:`48152`)\n- Performance improvement in :meth:`DataFrame.to_records` when the index is a :class:`MultiIndex` (:issue:`47263`)\n- Performance improvement in :attr:`MultiIndex.values` when the MultiIndex contains levels of type DatetimeIndex, TimedeltaIndex or ExtensionDtypes (:issue:`46288`)\n- Performance improvement in :func:`merge` when left and/or right are empty (:issue:`45838`)\n- Performance improvement in :meth:`DataFrame.join` when left and/or right are empty (:issue:`46015`)\n- Performance improvement in :meth:`DataFrame.reindex` and :meth:`Series.reindex` when target is a :class:`MultiIndex` (:issue:`46235`)\n- Performance improvement when setting values in a pyarrow backed string array (:issue:`46400`)\n- Performance improvement in :func:`factorize` (:issue:`46109`)\n- Performance improvement in :class:`DataFrame` and :class:`Series` constructors for extension dtype scalars (:issue:`45854`)\n- Performance improvement in :func:`read_excel` when ``nrows`` argument provided (:issue:`32727`)\n- Performance improvement in :meth:`.Styler.to_excel` when applying repeated CSS formats (:issue:`47371`)\n- Performance improvement in :meth:`MultiIndex.is_monotonic_increasing`  (:issue:`47458`)\n- Performance improvement in :class:`BusinessHour` ``str`` and ``repr`` (:issue:`44764`)\n- Performance improvement in datetime arrays string formatting when one of the default strftime formats ``\"%Y-%m-%d %H:%M:%S\"`` or ``\"%Y-%m-%d %H:%M:%S.%f\"`` is used. (:issue:`44764`)\n- Performance improvement in :meth:`Series.to_sql` and :meth:`DataFrame.to_sql` (:class:`SQLiteTable`) when processing time arrays. (:issue:`44764`)\n- Performance improvement to :func:`read_sas` (:issue:`47404`)\n- Performance improvement in ``argmax`` and ``argmin`` for :class:`arrays.SparseArray` (:issue:`34197`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_150.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n- Bug in :meth:`.Categorical.view` not accepting integer dtypes (:issue:`25464`)\n- Bug in :meth:`.CategoricalIndex.union` when the index's categories are integer-dtype and the index contains ``NaN`` values incorrectly raising instead of casting to ``float64`` (:issue:`45362`)\n- Bug in :meth:`concat` when concatenating two (or more) unordered :class:`CategoricalIndex` variables, whose categories are permutations, yields incorrect index values (:issue:`24845`)\n\nDatetimelike\n^^^^^^^^^^^^\n- Bug in :meth:`DataFrame.quantile` with datetime-like dtypes and no rows incorrectly returning ``float64`` dtype instead of retaining datetime-like dtype (:issue:`41544`)\n- Bug in :func:`to_datetime` with sequences of ``np.str_`` objects incorrectly raising (:issue:`32264`)\n- Bug in :class:`Timestamp` construction when passing datetime components as positional arguments and ``tzinfo`` as a keyword argument incorrectly raising (:issue:`31929`)\n- Bug in :meth:`Index.astype` when casting from object dtype to ``timedelta64[ns]`` dtype incorrectly casting ``np.datetime64(\"NaT\")`` values to ``np.timedelta64(\"NaT\")`` instead of raising (:issue:`45722`)\n- Bug in :meth:`.SeriesGroupBy.value_counts` index when passing categorical column (:issue:`44324`)\n- Bug in :meth:`DatetimeIndex.tz_localize` localizing to UTC failing to make a copy of the underlying data (:issue:`46460`)\n- Bug in :meth:`DatetimeIndex.resolution` incorrectly returning \"day\" instead of \"nanosecond\" for nanosecond-resolution indexes (:issue:`46903`)\n- Bug in :class:`Timestamp` with an integer or float value and ``unit=\"Y\"`` or ``unit=\"M\"`` giving slightly-wrong results (:issue:`47266`)\n- Bug in :class:`.DatetimeArray` construction when passed another :class:`.DatetimeArray` and ``freq=None`` incorrectly inferring the freq from the given array (:issue:`47296`)\n- Bug in :func:`to_datetime` where ``OutOfBoundsDatetime`` would be thrown even if ``errors=coerce`` if there were more than 50 rows (:issue:`45319`)\n- Bug when adding a :class:`DateOffset` to a :class:`Series` would not add the ``nanoseconds`` field (:issue:`47856`)\n\nTimedelta\n^^^^^^^^^\n- Bug in :func:`astype_nansafe` astype(\"timedelta64[ns]\") fails when np.nan is included (:issue:`45798`)\n- Bug in constructing a :class:`Timedelta` with a ``np.timedelta64`` object and a ``unit`` sometimes silently overflowing and returning incorrect results instead of raising ``OutOfBoundsTimedelta`` (:issue:`46827`)\n- Bug in constructing a :class:`Timedelta` from a large integer or float with ``unit=\"W\"`` silently overflowing and returning incorrect results instead of raising ``OutOfBoundsTimedelta`` (:issue:`47268`)\n\nTime Zones\n^^^^^^^^^^\n- Bug in :class:`Timestamp` constructor raising when passed a ``ZoneInfo`` tzinfo object (:issue:`46425`)\n\nNumeric\n^^^^^^^\n- Bug in operations with array-likes with ``dtype=\"boolean\"`` and :attr:`NA` incorrectly altering the array in-place (:issue:`45421`)\n- Bug in arithmetic operations with nullable types without :attr:`NA` values not matching the same operation with non-nullable types (:issue:`48223`)\n- Bug in ``floordiv`` when dividing by ``IntegerDtype`` ``0`` would return ``0`` instead of ``inf`` (:issue:`48223`)\n- Bug in division, ``pow`` and ``mod`` operations on array-likes with ``dtype=\"boolean\"`` not being like their ``np.bool_`` counterparts (:issue:`46063`)\n- Bug in multiplying a :class:`Series` with ``IntegerDtype`` or ``FloatingDtype`` by an array-like with ``timedelta64[ns]`` dtype incorrectly raising (:issue:`45622`)\n- Bug in :meth:`mean` where the optional dependency ``bottleneck`` causes precision loss linear in the length of the array. ``bottleneck`` has been disabled for :meth:`mean` improving the loss to log-linear but may result in a performance decrease. (:issue:`42878`)\n\nConversion\n^^^^^^^^^^\n- Bug in :meth:`DataFrame.astype` not preserving subclasses (:issue:`40810`)\n- Bug in constructing a :class:`Series` from a float-containing list or a floating-dtype ndarray-like (e.g. ``dask.Array``) and an integer dtype raising instead of casting like we would with an ``np.ndarray`` (:issue:`40110`)\n- Bug in :meth:`Float64Index.astype` to unsigned integer dtype incorrectly casting to ``np.int64`` dtype (:issue:`45309`)\n- Bug in :meth:`Series.astype` and :meth:`DataFrame.astype` from floating dtype to unsigned integer dtype failing to raise in the presence of negative values (:issue:`45151`)\n- Bug in :func:`array` with ``FloatingDtype`` and values containing float-castable strings incorrectly raising (:issue:`45424`)\n- Bug when comparing string and datetime64ns objects causing ``OverflowError`` exception. (:issue:`45506`)\n- Bug in metaclass of generic abstract dtypes causing :meth:`DataFrame.apply` and :meth:`Series.apply` to raise for the built-in function ``type`` (:issue:`46684`)\n- Bug in :meth:`DataFrame.to_records` returning inconsistent numpy types if the index was a :class:`MultiIndex` (:issue:`47263`)\n- Bug in :meth:`DataFrame.to_dict` for ``orient=\"list\"`` or ``orient=\"index\"`` was not returning native types (:issue:`46751`)\n- Bug in :meth:`DataFrame.apply` that returns a :class:`DataFrame` instead of a :class:`Series` when applied to an empty :class:`DataFrame` and ``axis=1`` (:issue:`39111`)\n- Bug when inferring the dtype from an iterable that is *not* a NumPy ``ndarray`` consisting of all NumPy unsigned integer scalars did not result in an unsigned integer dtype (:issue:`47294`)\n- Bug in :meth:`DataFrame.eval` when pandas objects (e.g. ``'Timestamp'``) were column names (:issue:`44603`)\n\nStrings\n^^^^^^^\n- Bug in :meth:`str.startswith` and :meth:`str.endswith` when using other series as parameter _pat_. Now raises ``TypeError`` (:issue:`3485`)\n- Bug in :meth:`Series.str.zfill` when strings contain leading signs, padding '0' before the sign character rather than after as ``str.zfill`` from standard library (:issue:`20868`)\n\nInterval\n^^^^^^^^\n- Bug in :meth:`IntervalArray.__setitem__` when setting ``np.nan`` into an integer-backed array raising ``ValueError`` instead of ``TypeError`` (:issue:`45484`)\n- Bug in :class:`IntervalDtype` when using datetime64[ns, tz] as a dtype string (:issue:`46999`)\n\nIndexing\n^^^^^^^^\n- Bug in :meth:`DataFrame.iloc` where indexing a single row on a :class:`DataFrame` with a single ExtensionDtype column gave a copy instead of a view on the underlying data (:issue:`45241`)\n- Bug in :meth:`DataFrame.__getitem__` returning copy when :class:`DataFrame` has duplicated columns even if a unique column is selected (:issue:`45316`, :issue:`41062`)\n- Bug in :meth:`Series.align` does not create :class:`MultiIndex` with union of levels when both MultiIndexes intersections are identical (:issue:`45224`)\n- Bug in setting a NA value (``None`` or ``np.nan``) into a :class:`Series` with int-based :class:`IntervalDtype` incorrectly casting to object dtype instead of a float-based :class:`IntervalDtype` (:issue:`45568`)\n- Bug in indexing setting values into an ``ExtensionDtype`` column with ``df.iloc[:, i] = values`` with ``values`` having the same dtype as ``df.iloc[:, i]`` incorrectly inserting a new array instead of setting in-place (:issue:`33457`)\n- Bug in :meth:`Series.__setitem__` with a non-integer :class:`Index` when using an integer key to set a value that cannot be set inplace where a ``ValueError`` was raised instead of casting to a common dtype (:issue:`45070`)\n- Bug in :meth:`DataFrame.loc` not casting ``None`` to ``NA`` when setting value as a list into :class:`DataFrame` (:issue:`47987`)\n- Bug in :meth:`Series.__setitem__` when setting incompatible values into a ``PeriodDtype`` or ``IntervalDtype`` :class:`Series` raising when indexing with a boolean mask but coercing when indexing with otherwise-equivalent indexers; these now consistently coerce, along with :meth:`Series.mask` and :meth:`Series.where` (:issue:`45768`)\n- Bug in :meth:`DataFrame.where` with multiple columns with datetime-like dtypes failing to downcast results consistent with other dtypes (:issue:`45837`)\n- Bug in :func:`isin` upcasting to ``float64`` with unsigned integer dtype and list-like argument without a dtype (:issue:`46485`)\n- Bug in :meth:`Series.loc.__setitem__` and :meth:`Series.loc.__getitem__` not raising when using multiple keys without using a :class:`MultiIndex` (:issue:`13831`)\n- Bug in :meth:`Index.reindex` raising ``AssertionError`` when ``level`` was specified but no :class:`MultiIndex` was given; level is ignored now (:issue:`35132`)\n- Bug when setting a value too large for a :class:`Series` dtype failing to coerce to a common type (:issue:`26049`, :issue:`32878`)\n- Bug in :meth:`loc.__setitem__` treating ``range`` keys as positional instead of label-based (:issue:`45479`)\n- Bug in :meth:`DataFrame.__setitem__` casting extension array dtypes to object when setting with a scalar key and :class:`DataFrame` as value (:issue:`46896`)\n- Bug in :meth:`Series.__setitem__` when setting a scalar to a nullable pandas dtype would not raise a ``TypeError`` if the scalar could not be cast (losslessly) to the nullable type (:issue:`45404`)\n- Bug in :meth:`Series.__setitem__` when setting ``boolean`` dtype values containing ``NA`` incorrectly raising instead of casting to ``boolean`` dtype (:issue:`45462`)\n- Bug in :meth:`Series.loc` raising with boolean indexer containing ``NA`` when :class:`Index` did not match (:issue:`46551`)\n- Bug in :meth:`Series.__setitem__` where setting :attr:`NA` into a numeric-dtype :class:`Series` would incorrectly upcast to object-dtype rather than treating the value as ``np.nan`` (:issue:`44199`)\n- Bug in :meth:`DataFrame.loc` when setting values to a column and right hand side is a dictionary (:issue:`47216`)\n- Bug in :meth:`Series.__setitem__` with ``datetime64[ns]`` dtype, an all-``False`` boolean mask, and an incompatible value incorrectly casting to ``object`` instead of retaining ``datetime64[ns]`` dtype (:issue:`45967`)\n- Bug in :meth:`Index.__getitem__`  raising ``ValueError`` when indexer is from boolean dtype with ``NA`` (:issue:`45806`)\n- Bug in :meth:`Series.__setitem__` losing precision when enlarging :class:`Series` with scalar (:issue:`32346`)\n- Bug in :meth:`Series.mask` with ``inplace=True`` or setting values with a boolean mask with small integer dtypes incorrectly raising (:issue:`45750`)\n- Bug in :meth:`DataFrame.mask` with ``inplace=True`` and ``ExtensionDtype`` columns incorrectly raising (:issue:`45577`)\n- Bug in getting a column from a DataFrame with an object-dtype row index with datetime-like values: the resulting Series now preserves the exact object-dtype Index from the parent DataFrame (:issue:`42950`)\n- Bug in :meth:`DataFrame.__getattribute__` raising ``AttributeError`` if columns have ``\"string\"`` dtype (:issue:`46185`)\n- Bug in :meth:`DataFrame.compare` returning all ``NaN`` column when comparing extension array dtype and numpy dtype (:issue:`44014`)\n- Bug in :meth:`DataFrame.where` setting wrong values with ``\"boolean\"`` mask for numpy dtype (:issue:`44014`)\n- Bug in indexing on a :class:`DatetimeIndex` with a ``np.str_`` key incorrectly raising (:issue:`45580`)\n- Bug in :meth:`CategoricalIndex.get_indexer` when index contains ``NaN`` values, resulting in elements that are in target but not present in the index to be mapped to the index of the NaN element, instead of -1 (:issue:`45361`)\n- Bug in setting large integer values into :class:`Series` with ``float32`` or ``float16`` dtype incorrectly altering these values instead of coercing to ``float64`` dtype (:issue:`45844`)\n- Bug in :meth:`Series.asof` and :meth:`DataFrame.asof` incorrectly casting bool-dtype results to ``float64`` dtype (:issue:`16063`)\n- Bug in :meth:`NDFrame.xs`, :meth:`DataFrame.iterrows`, :meth:`DataFrame.loc` and :meth:`DataFrame.iloc` not always propagating metadata (:issue:`28283`)\n- Bug in :meth:`DataFrame.sum` min_count changes dtype if input contains NaNs (:issue:`46947`)\n- Bug in :class:`IntervalTree` that lead to an infinite recursion. (:issue:`46658`)\n- Bug in :class:`PeriodIndex` raising ``AttributeError`` when indexing on ``NA``, rather than putting ``NaT`` in its place. (:issue:`46673`)\n- Bug in :meth:`DataFrame.at` would allow the modification of multiple columns (:issue:`48296`)\n\nMissing\n^^^^^^^\n- Bug in :meth:`Series.fillna` and :meth:`DataFrame.fillna` with ``downcast`` keyword not being respected in some cases where there are no NA values present (:issue:`45423`)\n- Bug in :meth:`Series.fillna` and :meth:`DataFrame.fillna` with :class:`IntervalDtype` and incompatible value raising instead of casting to a common (usually object) dtype (:issue:`45796`)\n- Bug in :meth:`Series.map` not respecting ``na_action`` argument if mapper is a ``dict`` or :class:`Series` (:issue:`47527`)\n- Bug in :meth:`DataFrame.interpolate` with object-dtype column not returning a copy with ``inplace=False`` (:issue:`45791`)\n- Bug in :meth:`DataFrame.dropna` allows to set both ``how`` and ``thresh`` incompatible arguments (:issue:`46575`)\n- Bug in :meth:`DataFrame.fillna` ignored ``axis`` when :class:`DataFrame` is single block (:issue:`47713`)\n\nMultiIndex\n^^^^^^^^^^\n- Bug in :meth:`DataFrame.loc` returning empty result when slicing a :class:`MultiIndex` with a negative step size and non-null start/stop values (:issue:`46156`)\n- Bug in :meth:`DataFrame.loc` raising when slicing a :class:`MultiIndex` with a negative step size other than -1 (:issue:`46156`)\n- Bug in :meth:`DataFrame.loc` raising when slicing a :class:`MultiIndex` with a negative step size and slicing a non-int labeled index level (:issue:`46156`)\n- Bug in :meth:`Series.to_numpy` where multiindexed Series could not be converted to numpy arrays when an ``na_value`` was supplied (:issue:`45774`)\n- Bug in :class:`MultiIndex.equals` not commutative when only one side has extension array dtype (:issue:`46026`)\n- Bug in :meth:`MultiIndex.from_tuples` cannot construct Index of empty tuples (:issue:`45608`)\n\nI/O\n^^^\n- Bug in :meth:`DataFrame.to_stata` where no error is raised if the :class:`DataFrame` contains ``-np.inf`` (:issue:`45350`)\n- Bug in :func:`read_excel` results in an infinite loop with certain ``skiprows`` callables (:issue:`45585`)\n- Bug in :meth:`DataFrame.info` where a new line at the end of the output is omitted when called on an empty :class:`DataFrame` (:issue:`45494`)\n- Bug in :func:`read_csv` not recognizing line break for ``on_bad_lines=\"warn\"`` for ``engine=\"c\"`` (:issue:`41710`)\n- Bug in :meth:`DataFrame.to_csv` not respecting ``float_format`` for ``Float64`` dtype (:issue:`45991`)\n- Bug in :func:`read_csv` not respecting a specified converter to index columns in all cases (:issue:`40589`)\n- Bug in :func:`read_csv` interpreting second row as :class:`Index` names even when ``index_col=False`` (:issue:`46569`)\n- Bug in :func:`read_parquet` when ``engine=\"pyarrow\"`` which caused partial write to disk when column of unsupported datatype was passed (:issue:`44914`)\n- Bug in :func:`DataFrame.to_excel` and :class:`ExcelWriter` would raise when writing an empty DataFrame to a ``.ods`` file (:issue:`45793`)\n- Bug in :func:`read_csv` ignoring non-existing header row for ``engine=\"python\"`` (:issue:`47400`)\n- Bug in :func:`read_excel` raising uncontrolled ``IndexError`` when ``header`` references non-existing rows (:issue:`43143`)\n- Bug in :func:`read_html` where elements surrounding ``<br>`` were joined without a space between them (:issue:`29528`)\n- Bug in :func:`read_csv` when data is longer than header leading to issues with callables in ``usecols`` expecting strings (:issue:`46997`)\n- Bug in Parquet roundtrip for Interval dtype with ``datetime64[ns]`` subtype (:issue:`45881`)\n- Bug in :func:`read_excel` when reading a ``.ods`` file with newlines between xml elements (:issue:`45598`)\n- Bug in :func:`read_parquet` when ``engine=\"fastparquet\"`` where the file was not closed on error (:issue:`46555`)\n- :meth:`DataFrame.to_html` now excludes the ``border`` attribute from ``<table>`` elements when ``border`` keyword is set to ``False``.\n- Bug in :func:`read_sas` with certain types of compressed SAS7BDAT files (:issue:`35545`)\n- Bug in :func:`read_excel` not forward filling :class:`MultiIndex` when no names were given (:issue:`47487`)\n- Bug in :func:`read_sas` returned ``None`` rather than an empty DataFrame for SAS7BDAT files with zero rows (:issue:`18198`)\n- Bug in :meth:`DataFrame.to_string` using wrong missing value with extension arrays in :class:`MultiIndex` (:issue:`47986`)\n- Bug in :class:`StataWriter` where value labels were always written with default encoding (:issue:`46750`)\n- Bug in :class:`StataWriterUTF8` where some valid characters were removed from variable names (:issue:`47276`)\n- Bug in :meth:`DataFrame.to_excel` when writing an empty dataframe with :class:`MultiIndex` (:issue:`19543`)\n- Bug in :func:`read_sas` with RLE-compressed SAS7BDAT files that contain 0x40 control bytes (:issue:`31243`)\n- Bug in :func:`read_sas` that scrambled column names (:issue:`31243`)\n- Bug in :func:`read_sas` with RLE-compressed SAS7BDAT files that contain 0x00 control bytes (:issue:`47099`)\n- Bug in :func:`read_parquet` with ``use_nullable_dtypes=True`` where ``float64`` dtype was returned instead of nullable ``Float64`` dtype (:issue:`45694`)\n- Bug in :meth:`DataFrame.to_json` where ``PeriodDtype`` would not make the serialization roundtrip when read back with :meth:`read_json` (:issue:`44720`)\n- Bug in :func:`read_xml` when reading XML files with Chinese character tags and would raise ``XMLSyntaxError`` (:issue:`47902`)\n\nPeriod\n^^^^^^\n- Bug in subtraction of :class:`Period` from :class:`.PeriodArray` returning wrong results (:issue:`45999`)\n- Bug in :meth:`Period.strftime` and :meth:`PeriodIndex.strftime`, directives ``%l`` and ``%u`` were giving wrong results (:issue:`46252`)\n- Bug in inferring an incorrect ``freq`` when passing a string to :class:`Period` microseconds that are a multiple of 1000 (:issue:`46811`)\n- Bug in constructing a :class:`Period` from a :class:`Timestamp` or ``np.datetime64`` object with non-zero nanoseconds and ``freq=\"ns\"`` incorrectly truncating the nanoseconds (:issue:`46811`)\n- Bug in adding ``np.timedelta64(\"NaT\", \"ns\")`` to a :class:`Period` with a timedelta-like freq incorrectly raising ``IncompatibleFrequency`` instead of returning ``NaT`` (:issue:`47196`)\n- Bug in adding an array of integers to an array with :class:`PeriodDtype` giving incorrect results when ``dtype.freq.n > 1`` (:issue:`47209`)\n- Bug in subtracting a :class:`Period` from an array with :class:`PeriodDtype` returning incorrect results instead of raising ``OverflowError`` when the operation overflows (:issue:`47538`)\n\nPlotting\n^^^^^^^^\n- Bug in :meth:`DataFrame.plot.barh` that prevented labeling the x-axis and ``xlabel`` updating the y-axis label (:issue:`45144`)\n- Bug in :meth:`DataFrame.plot.box` that prevented labeling the x-axis (:issue:`45463`)\n- Bug in :meth:`DataFrame.boxplot` that prevented passing in ``xlabel`` and ``ylabel`` (:issue:`45463`)\n- Bug in :meth:`DataFrame.boxplot` that prevented specifying ``vert=False`` (:issue:`36918`)\n- Bug in :meth:`DataFrame.plot.scatter` that prevented specifying ``norm`` (:issue:`45809`)\n- Fix showing \"None\" as ylabel in :meth:`Series.plot` when not setting ylabel (:issue:`46129`)\n- Bug in :meth:`DataFrame.plot` that led to xticks and vertical grids being improperly placed when plotting a quarterly series (:issue:`47602`)\n- Bug in :meth:`DataFrame.plot` that prevented setting y-axis label, limits and ticks for a secondary y-axis (:issue:`47753`)\n\nGroupby/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n- Bug in :meth:`DataFrame.resample` ignoring ``closed=\"right\"`` on :class:`TimedeltaIndex` (:issue:`45414`)\n- Bug in :meth:`.DataFrameGroupBy.transform` fails when ``func=\"size\"`` and the input DataFrame has multiple columns (:issue:`27469`)\n- Bug in :meth:`.DataFrameGroupBy.size` and :meth:`.DataFrameGroupBy.transform` with ``func=\"size\"`` produced incorrect results when ``axis=1`` (:issue:`45715`)\n- Bug in :meth:`.ExponentialMovingWindow.mean` with ``axis=1`` and ``engine='numba'`` when the :class:`DataFrame` has more columns than rows (:issue:`46086`)\n- Bug when using ``engine=\"numba\"`` would return the same jitted function when modifying ``engine_kwargs`` (:issue:`46086`)\n- Bug in :meth:`.DataFrameGroupBy.transform` fails when ``axis=1`` and ``func`` is ``\"first\"`` or ``\"last\"`` (:issue:`45986`)\n- Bug in :meth:`.DataFrameGroupBy.cumsum` with ``skipna=False`` giving incorrect results (:issue:`46216`)\n- Bug in :meth:`.DataFrameGroupBy.sum`, :meth:`.SeriesGroupBy.sum`, :meth:`.DataFrameGroupBy.prod`, :meth:`.SeriesGroupBy.prod, :meth:`.DataFrameGroupBy.cumsum`, and :meth:`.SeriesGroupBy.cumsum` with integer dtypes losing precision (:issue:`37493`)\n- Bug in :meth:`.DataFrameGroupBy.cumsum` and :meth:`.SeriesGroupBy.cumsum` with ``timedelta64[ns]`` dtype failing to recognize ``NaT`` as a null value (:issue:`46216`)\n- Bug in :meth:`.DataFrameGroupBy.cumsum` and :meth:`.SeriesGroupBy.cumsum` with integer dtypes causing overflows when sum was bigger than maximum of dtype (:issue:`37493`)\n- Bug in :meth:`.DataFrameGroupBy.cummin`, :meth:`.SeriesGroupBy.cummin`, :meth:`.DataFrameGroupBy.cummax` and :meth:`.SeriesGroupBy.cummax` with nullable dtypes incorrectly altering the original data in place (:issue:`46220`)\n- Bug in :meth:`DataFrame.groupby` raising error when ``None`` is in first level of :class:`MultiIndex` (:issue:`47348`)\n- Bug in :meth:`.DataFrameGroupBy.cummax` and :meth:`.SeriesGroupBy.cummax` with ``int64`` dtype with leading value being the smallest possible int64 (:issue:`46382`)\n- Bug in :meth:`.DataFrameGroupBy.cumprod` and :meth:`.SeriesGroupBy.cumprod` ``NaN`` influences calculation in different columns with ``skipna=False`` (:issue:`48064`)\n- Bug in :meth:`.DataFrameGroupBy.max` and :meth:`.SeriesGroupBy.max` with empty groups and ``uint64`` dtype incorrectly raising ``RuntimeError`` (:issue:`46408`)\n- Bug in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` would fail when ``func`` was a string and args or kwargs were supplied (:issue:`46479`)\n- Bug in :meth:`SeriesGroupBy.apply` would incorrectly name its result when there was a unique group (:issue:`46369`)\n- Bug in :meth:`.Rolling.sum` and :meth:`.Rolling.mean` would give incorrect result with window of same values (:issue:`42064`, :issue:`46431`)\n- Bug in :meth:`.Rolling.var` and :meth:`.Rolling.std` would give non-zero result with window of same values (:issue:`42064`)\n- Bug in :meth:`.Rolling.skew` and :meth:`.Rolling.kurt` would give NaN with window of same values (:issue:`30993`)\n- Bug in :meth:`.Rolling.var` would segfault calculating weighted variance when window size was larger than data size (:issue:`46760`)\n- Bug in :meth:`Grouper.__repr__` where ``dropna`` was not included. Now it is (:issue:`46754`)\n- Bug in :meth:`DataFrame.rolling` gives ValueError when center=True, axis=1 and win_type is specified (:issue:`46135`)\n- Bug in :meth:`.DataFrameGroupBy.describe` and :meth:`.SeriesGroupBy.describe` produces inconsistent results for empty datasets (:issue:`41575`)\n- Bug in :meth:`DataFrame.resample` reduction methods when used with ``on`` would attempt to aggregate the provided column (:issue:`47079`)\n- Bug in :meth:`DataFrame.groupby` and :meth:`Series.groupby` would not respect ``dropna=False`` when the input DataFrame/Series had a NaN values in a :class:`MultiIndex` (:issue:`46783`)\n- Bug in :meth:`DataFrameGroupBy.resample` raises ``KeyError`` when getting the result from a key list which misses the resample key (:issue:`47362`)\n- Bug in :meth:`DataFrame.groupby` would lose index columns when the DataFrame is empty for transforms, like fillna (:issue:`47787`)\n- Bug in :meth:`DataFrame.groupby` and :meth:`Series.groupby` with ``dropna=False`` and ``sort=False`` would put any null groups at the end instead the order that they are encountered (:issue:`46584`)\n\nReshaping\n^^^^^^^^^\n- Bug in :func:`concat` between a :class:`Series` with integer dtype and another with :class:`CategoricalDtype` with integer categories and containing ``NaN`` values casting to object dtype instead of ``float64`` (:issue:`45359`)\n- Bug in :func:`get_dummies` that selected object and categorical dtypes but not string (:issue:`44965`)\n- Bug in :meth:`DataFrame.align` when aligning a :class:`MultiIndex` to a :class:`Series` with another :class:`MultiIndex` (:issue:`46001`)\n- Bug in concatenation with ``IntegerDtype``, or ``FloatingDtype`` arrays where the resulting dtype did not mirror the behavior of the non-nullable dtypes (:issue:`46379`)\n- Bug in :func:`concat` losing dtype of columns when ``join=\"outer\"`` and ``sort=True`` (:issue:`47329`)\n- Bug in :func:`concat` not sorting the column names when ``None`` is included (:issue:`47331`)\n- Bug in :func:`concat` with identical key leads to error when indexing :class:`MultiIndex` (:issue:`46519`)\n- Bug in :func:`pivot_table` raising ``TypeError`` when ``dropna=True`` and aggregation column has extension array dtype (:issue:`47477`)\n- Bug in :func:`merge` raising error for ``how=\"cross\"`` when using ``FIPS`` mode in ssl library (:issue:`48024`)\n- Bug in :meth:`DataFrame.join` with a list when using suffixes to join DataFrames with duplicate column names (:issue:`46396`)\n- Bug in :meth:`DataFrame.pivot_table` with ``sort=False`` results in sorted index (:issue:`17041`)\n- Bug in :meth:`concat` when ``axis=1`` and ``sort=False`` where the resulting Index was a :class:`Int64Index` instead of a :class:`RangeIndex` (:issue:`46675`)\n- Bug in :meth:`wide_to_long` raises when ``stubnames`` is missing in columns and ``i`` contains string dtype column (:issue:`46044`)\n- Bug in :meth:`DataFrame.join` with categorical index results in unexpected reordering (:issue:`47812`)\n\nSparse\n^^^^^^\n- Bug in :meth:`Series.where` and :meth:`DataFrame.where` with ``SparseDtype`` failing to retain the array's ``fill_value`` (:issue:`45691`)\n- Bug in :meth:`SparseArray.unique` fails to keep original elements order (:issue:`47809`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n- Bug in :meth:`IntegerArray.searchsorted` and :meth:`FloatingArray.searchsorted` returning inconsistent results when acting on ``np.nan`` (:issue:`45255`)\n\nStyler\n^^^^^^\n- Bug when attempting to apply styling functions to an empty DataFrame subset (:issue:`45313`)\n- Bug in :class:`CSSToExcelConverter` leading to ``TypeError`` when border color provided without border style for ``xlsxwriter`` engine (:issue:`42276`)\n- Bug in :meth:`Styler.set_sticky` leading to white text on white background in dark mode (:issue:`46984`)\n- Bug in :meth:`Styler.to_latex` causing ``UnboundLocalError`` when ``clines=\"all;data\"`` and the ``DataFrame`` has no rows. (:issue:`47203`)\n- Bug in :meth:`Styler.to_excel` when using ``vertical-align: middle;`` with ``xlsxwriter`` engine (:issue:`30107`)\n- Bug when applying styles to a DataFrame with boolean column labels (:issue:`47838`)\n\nMetadata\n^^^^^^^^\n- Fixed metadata propagation in :meth:`DataFrame.melt` (:issue:`28283`)\n- Fixed metadata propagation in :meth:`DataFrame.explode` (:issue:`28283`)\n\nOther\n^^^^^\n\n.. ***DO NOT USE THIS SECTION***\n\n- Bug in :func:`.assert_index_equal` with ``names=True`` and ``check_order=False`` not checking names (:issue:`47328`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_150.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.4.4..v1.5.0\n", "0.2": ".. _whatsnew_0251:\n\nWhat's new in 0.25.1 (August 21, 2019)\n--------------------------------------\n\nThese are the changes in pandas 0.25.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\nIO and LZMA\n~~~~~~~~~~~\n\nSome users may unknowingly have an incomplete Python installation lacking the ``lzma`` module from the standard library. In this case, ``import pandas`` failed due to an ``ImportError`` (:issue:`27575`).\npandas will now warn, rather than raising an ``ImportError`` if the ``lzma`` module is not present. Any subsequent attempt to use ``lzma`` methods will raise a ``RuntimeError``.\nA possible fix for the lack of the ``lzma`` module is to ensure you have the necessary libraries and then re-install Python.\nFor example, on MacOS installing Python with ``pyenv`` may lead to an incomplete Python installation due to unmet system dependencies at compilation time (like ``xz``). Compilation will succeed, but Python might fail at run time. The issue can be solved by installing the necessary dependencies and then re-installing Python.\n\n.. _whatsnew_0251.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n\n- Bug in :meth:`Categorical.fillna` that would replace all values, not just those that are ``NaN`` (:issue:`26215`)\n\nDatetimelike\n^^^^^^^^^^^^\n\n- Bug in :func:`to_datetime` where passing a timezone-naive :class:`DatetimeArray` or :class:`DatetimeIndex` and ``utc=True`` would incorrectly return a timezone-naive result (:issue:`27733`)\n- Bug in :meth:`Period.to_timestamp` where a :class:`Period` outside the :class:`Timestamp` implementation bounds (roughly 1677-09-21 to 2262-04-11) would return an incorrect :class:`Timestamp` instead of raising ``OutOfBoundsDatetime`` (:issue:`19643`)\n- Bug in iterating over :class:`DatetimeIndex` when the underlying data is read-only (:issue:`28055`)\n\nTimezones\n^^^^^^^^^\n\n- Bug in :class:`Index` where a numpy object array with a timezone aware :class:`Timestamp` and ``np.nan`` would not return a :class:`DatetimeIndex` (:issue:`27011`)\n\nNumeric\n^^^^^^^\n\n- Bug in :meth:`Series.interpolate` when using a timezone aware :class:`DatetimeIndex` (:issue:`27548`)\n- Bug when printing negative floating point complex numbers would raise an ``IndexError`` (:issue:`27484`)\n- Bug where :class:`DataFrame` arithmetic operators such as :meth:`DataFrame.mul` with a :class:`Series` with axis=1 would raise an ``AttributeError`` on :class:`DataFrame` larger than the minimum threshold to invoke numexpr (:issue:`27636`)\n- Bug in :class:`DataFrame` arithmetic where missing values in results were incorrectly masked with ``NaN`` instead of ``Inf`` (:issue:`27464`)\n\nConversion\n^^^^^^^^^^\n\n- Improved the warnings for the deprecated methods :meth:`Series.real` and :meth:`Series.imag` (:issue:`27610`)\n\nInterval\n^^^^^^^^\n\n- Bug in :class:`IntervalIndex` where ``dir(obj)`` would raise ``ValueError`` (:issue:`27571`)\n\nIndexing\n^^^^^^^^\n\n- Bug in partial-string indexing returning a NumPy array rather than a ``Series`` when indexing with a scalar like ``.loc['2015']`` (:issue:`27516`)\n- Break reference cycle involving :class:`Index` and other index classes to allow garbage collection of index objects without running the GC. (:issue:`27585`, :issue:`27840`)\n- Fix regression in assigning values to a single column of a DataFrame with a ``MultiIndex`` columns (:issue:`27841`).\n- Fix regression in ``.ix`` fallback with an ``IntervalIndex`` (:issue:`27865`).\n\nMissing\n^^^^^^^\n\n- Bug in :func:`pandas.isnull` or :func:`pandas.isna` when the input is a type e.g. ``type(pandas.Series())`` (:issue:`27482`)\n\nIO\n^^\n\n- Avoid calling ``S3File.s3`` when reading parquet, as this was removed in s3fs version 0.3.0 (:issue:`27756`)\n- Better error message when a negative header is passed in :func:`pandas.read_csv` (:issue:`27779`)\n- Follow the ``min_rows`` display option (introduced in v0.25.0) correctly in the HTML repr in the notebook (:issue:`27991`).\n\nPlotting\n^^^^^^^^\n\n- Added a ``pandas_plotting_backends`` entrypoint group for registering plot backends. See :ref:`extending.plotting-backends` for more (:issue:`26747`).\n- Fixed the re-instatement of Matplotlib datetime converters after calling\n  :meth:`pandas.plotting.deregister_matplotlib_converters` (:issue:`27481`).\n- Fix compatibility issue with matplotlib when passing a pandas ``Index`` to a plot call (:issue:`27775`).\n\nGroupBy/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n- Fixed regression in :meth:`pands.core.groupby.DataFrameGroupBy.quantile` raising when multiple quantiles are given (:issue:`27526`)\n- Bug in :meth:`.DataFrameGroupBy.transform` where applying a timezone conversion lambda function would drop timezone information (:issue:`27496`)\n- Bug in :meth:`.GroupBy.nth` where ``observed=False`` was being ignored for Categorical groupers (:issue:`26385`)\n- Bug in windowing over read-only arrays (:issue:`27766`)\n- Fixed segfault in ``.DataFrameGroupBy.quantile`` when an invalid quantile was passed (:issue:`27470`)\n\nReshaping\n^^^^^^^^^\n\n- A ``KeyError`` is now raised if ``.unstack()`` is called on a :class:`Series` or :class:`DataFrame` with a flat :class:`Index` passing a name which is not the correct one (:issue:`18303`)\n- Bug :meth:`merge_asof` could not merge :class:`Timedelta` objects when passing ``tolerance`` kwarg (:issue:`27642`)\n- Bug in :meth:`DataFrame.crosstab` when ``margins`` set to ``True`` and ``normalize`` is not ``False``, an error is raised. (:issue:`27500`)\n- :meth:`DataFrame.join` now suppresses the ``FutureWarning`` when the sort parameter is specified (:issue:`21952`)\n- Bug in :meth:`DataFrame.join` raising with readonly arrays (:issue:`27943`)\n\nSparse\n^^^^^^\n\n- Bug in reductions for :class:`Series` with Sparse dtypes (:issue:`27080`)\n\nOther\n^^^^^\n\n- Bug in :meth:`Series.replace` and :meth:`DataFrame.replace` when replacing timezone-aware timestamps using a dict-like replacer (:issue:`27720`)\n- Bug in :meth:`Series.rename` when using a custom type indexer. Now any value that isn't callable or dict-like is treated as a scalar. (:issue:`27814`)\n\n.. _whatsnew_0.251.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.25.0..v0.25.1\n", "1.1.4": ".. _whatsnew_114:\n\nWhat's new in 1.1.4 (October 30, 2020)\n--------------------------------------\n\nThese are the changes in pandas 1.1.4. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_114.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :func:`read_csv` raising a ``ValueError`` when ``names`` was of type ``dict_keys`` (:issue:`36928`)\n- Fixed regression in :func:`read_csv` with more than 1M rows and specifying a ``index_col`` argument (:issue:`37094`)\n- Fixed regression where attempting to mutate a :class:`DateOffset` object would no longer raise an ``AttributeError`` (:issue:`36940`)\n- Fixed regression where :meth:`DataFrame.agg` would fail with :exc:`TypeError` when passed positional arguments to be passed on to the aggregation function (:issue:`36948`).\n- Fixed regression in :class:`RollingGroupby` with ``sort=False`` not being respected (:issue:`36889`)\n- Fixed regression in :meth:`Series.astype` converting ``None`` to ``\"nan\"`` when casting to string (:issue:`36904`)\n- Fixed regression in :meth:`Series.rank` method failing for read-only data (:issue:`37290`)\n- Fixed regression in :class:`RollingGroupby` causing a segmentation fault with Index of dtype object (:issue:`36727`)\n- Fixed regression in :meth:`DataFrame.resample(...).apply(...)` raised ``AttributeError`` when input was a :class:`DataFrame` and only a :class:`Series` was evaluated (:issue:`36951`)\n- Fixed regression in ``DataFrame.groupby(..).std()`` with nullable integer dtype (:issue:`37415`)\n- Fixed regression in :class:`PeriodDtype` comparing both equal and unequal to its string representation (:issue:`37265`)\n- Fixed regression where slicing :class:`DatetimeIndex` raised :exc:`AssertionError` on irregular time series with ``pd.NaT`` or on unsorted indices (:issue:`36953` and :issue:`35509`)\n- Fixed regression in certain offsets (:meth:`pd.offsets.Day() <pandas.tseries.offsets.Day>` and below) no longer being hashable (:issue:`37267`)\n- Fixed regression in :class:`StataReader` which required ``chunksize`` to be manually set when using an iterator to read a dataset (:issue:`37280`)\n- Fixed regression in setitem with :meth:`DataFrame.iloc` which raised error when trying to set a value while filtering with a boolean list (:issue:`36741`)\n- Fixed regression in setitem with a Series getting aligned before setting the values (:issue:`37427`)\n- Fixed regression in :attr:`MultiIndex.is_monotonic_increasing` returning wrong results with ``NaN`` in at least one of the levels (:issue:`37220`)\n- Fixed regression in inplace arithmetic operation (`+=`) on a Series not updating the parent DataFrame/Series (:issue:`36373`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_114.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug causing ``groupby(...).sum()`` and similar to not preserve metadata (:issue:`29442`)\n- Bug in :meth:`Series.isin` and :meth:`DataFrame.isin` raising a ``ValueError`` when the target was read-only (:issue:`37174`)\n- Bug in :meth:`.DataFrameGroupBy.fillna` and :meth:`.SeriesGroupBy.fillna` that introduced a performance regression after 1.0.5 (:issue:`36757`)\n- Bug in :meth:`DataFrame.info` was raising a ``KeyError`` when the DataFrame has integer column names (:issue:`37245`)\n- Bug in :meth:`DataFrameGroupby.apply` would drop a :class:`CategoricalIndex` when grouped on (:issue:`35792`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_114.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.1.3..v1.1.4\n", "1.2.1": ".. _whatsnew_121:\n\nWhat's new in 1.2.1 (January 20, 2021)\n--------------------------------------\n\nThese are the changes in pandas 1.2.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_121.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`~DataFrame.to_csv` that created corrupted zip files when there were more rows than ``chunksize`` (:issue:`38714`)\n- Fixed regression in :meth:`~DataFrame.to_csv` opening ``codecs.StreamReaderWriter`` in binary mode instead of in text mode (:issue:`39247`)\n- Fixed regression in :meth:`read_csv` and other read functions were the encoding error policy (``errors``) did not default to ``\"replace\"`` when no encoding was specified (:issue:`38989`)\n- Fixed regression in :func:`read_excel` with non-rawbyte file handles (:issue:`38788`)\n- Fixed regression in :meth:`DataFrame.to_stata` not removing the created file when an error occurred (:issue:`39202`)\n- Fixed regression in ``DataFrame.__setitem__`` raising ``ValueError`` when expanding :class:`DataFrame` and new column is from type ``\"0 - name\"`` (:issue:`39010`)\n- Fixed regression in setting with :meth:`DataFrame.loc`  raising ``ValueError`` when :class:`DataFrame` has unsorted :class:`MultiIndex` columns and indexer is a scalar (:issue:`38601`)\n- Fixed regression in setting with :meth:`DataFrame.loc` raising ``KeyError`` with :class:`MultiIndex` and list-like columns indexer enlarging :class:`DataFrame` (:issue:`39147`)\n- Fixed regression in :meth:`~DataFrame.groupby()` with :class:`Categorical` grouping column not showing unused categories for ``grouped.indices`` (:issue:`38642`)\n- Fixed regression in :meth:`.DataFrameGroupBy.sem` and :meth:`.SeriesGroupBy.sem` where the presence of non-numeric columns would cause an error instead of being dropped (:issue:`38774`)\n- Fixed regression in :meth:`.DataFrameGroupBy.diff` raising for ``int8`` and ``int16`` columns (:issue:`39050`)\n- Fixed regression in :meth:`DataFrame.groupby` when aggregating an ``ExtensionDType`` that could fail for non-numeric values (:issue:`38980`)\n- Fixed regression in :meth:`.Rolling.skew` and :meth:`.Rolling.kurt` modifying the object inplace (:issue:`38908`)\n- Fixed regression in :meth:`DataFrame.any` and :meth:`DataFrame.all` not returning a result for tz-aware ``datetime64`` columns (:issue:`38723`)\n- Fixed regression in :meth:`DataFrame.apply` with ``axis=1`` using str accessor in apply function (:issue:`38979`)\n- Fixed regression in :meth:`DataFrame.replace` raising ``ValueError`` when :class:`DataFrame` has dtype ``bytes`` (:issue:`38900`)\n- Fixed regression in :meth:`Series.fillna` that raised ``RecursionError`` with ``datetime64[ns, UTC]`` dtype (:issue:`38851`)\n- Fixed regression in comparisons between ``NaT`` and ``datetime.date`` objects incorrectly returning ``True`` (:issue:`39151`)\n- Fixed regression in calling NumPy :func:`~numpy.ufunc.accumulate` ufuncs on DataFrames, e.g. ``np.maximum.accumulate(df)`` (:issue:`39259`)\n- Fixed regression in repr of float-like strings of an ``object`` dtype having trailing 0's truncated after the decimal (:issue:`38708`)\n- Fixed regression that raised ``AttributeError`` with PyArrow versions [0.16.0, 1.0.0) (:issue:`38801`)\n- Fixed regression in :func:`pandas.testing.assert_frame_equal` raising ``TypeError`` with ``check_like=True`` when :class:`Index` or columns have mixed dtype (:issue:`39168`)\n\nWe have reverted a commit that resulted in several plotting related regressions in pandas 1.2.0 (:issue:`38969`, :issue:`38736`, :issue:`38865`, :issue:`38947` and :issue:`39126`).\nAs a result, bugs reported as fixed in pandas 1.2.0 related to inconsistent tick labeling in bar plots are again present (:issue:`26186` and :issue:`11465`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_121.ufunc_deprecation:\n\nCalling NumPy ufuncs on non-aligned DataFrames\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBefore pandas 1.2.0, calling a NumPy ufunc on non-aligned DataFrames (or\nDataFrame / Series combination) would ignore the indices, only match\nthe inputs by shape, and use the index/columns of the first DataFrame for\nthe result:\n\n.. code-block:: ipython\n\n    In [1]: df1 = pd.DataFrame({\"a\": [1, 2], \"b\": [3, 4]}, index=[0, 1])\n    In [2]: df2 = pd.DataFrame({\"a\": [1, 2], \"b\": [3, 4]}, index=[1, 2])\n    In [3]: df1\n    Out[3]:\n       a  b\n    0  1  3\n    1  2  4\n    In [4]: df2\n    Out[4]:\n       a  b\n    1  1  3\n    2  2  4\n\n    In [5]: np.add(df1, df2)\n    Out[5]:\n       a  b\n    0  2  6\n    1  4  8\n\nThis contrasts with how other pandas operations work, which first align\nthe inputs:\n\n.. code-block:: ipython\n\n    In [6]: df1 + df2\n    Out[6]:\n         a    b\n    0  NaN  NaN\n    1  3.0  7.0\n    2  NaN  NaN\n\nIn pandas 1.2.0, we refactored how NumPy ufuncs are called on DataFrames, and\nthis started to align the inputs first (:issue:`39184`), as happens in other\npandas operations and as it happens for ufuncs called on Series objects.\n\nFor pandas 1.2.1, we restored the previous behaviour to avoid a breaking\nchange, but the above example of ``np.add(df1, df2)`` with non-aligned inputs\nwill now to raise a warning, and a future pandas 2.0 release will start\naligning the inputs first (:issue:`39184`). Calling a NumPy ufunc on Series\nobjects (eg ``np.add(s1, s2)``) already aligns and continues to do so.\n\nTo avoid the warning and keep the current behaviour of ignoring the indices,\nconvert one of the arguments to a NumPy array:\n\n.. code-block:: ipython\n\n    In [7]: np.add(df1, np.asarray(df2))\n    Out[7]:\n       a  b\n    0  2  6\n    1  4  8\n\nTo obtain the future behaviour and silence the warning, you can align manually\nbefore passing the arguments to the ufunc:\n\n.. code-block:: ipython\n\n    In [8]: df1, df2 = df1.align(df2)\n    In [9]: np.add(df1, df2)\n    Out[9]:\n         a    b\n    0  NaN  NaN\n    1  3.0  7.0\n    2  NaN  NaN\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_121.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\n- Bug in :meth:`read_csv` with ``float_precision=\"high\"`` caused segfault or wrong parsing of long exponent strings. This resulted in a regression in some cases as the default for ``float_precision`` was changed in pandas 1.2.0 (:issue:`38753`)\n- Bug in :func:`read_csv` not closing an opened file handle when a ``csv.Error`` or ``UnicodeDecodeError`` occurred while initializing (:issue:`39024`)\n- Bug in :func:`pandas.testing.assert_index_equal` raising ``TypeError`` with ``check_order=False`` when :class:`Index` has mixed dtype (:issue:`39168`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_121.other:\n\nOther\n~~~~~\n\n- The deprecated attributes ``_AXIS_NAMES`` and ``_AXIS_NUMBERS`` of :class:`DataFrame` and :class:`Series` will no longer show up in ``dir`` or ``inspect.getmembers`` calls (:issue:`38740`)\n- Bumped minimum fastparquet version to 0.4.0 to avoid ``AttributeError`` from numba (:issue:`38344`)\n- Bumped minimum pymysql version to 0.8.1 to avoid test failures (:issue:`38344`)\n- Fixed build failure on MacOS 11 in Python 3.9.1 (:issue:`38766`)\n- Added reference to backwards incompatible ``check_freq`` arg of :func:`testing.assert_frame_equal` and :func:`testing.assert_series_equal` in :ref:`pandas 1.1.0 what's new <whatsnew_110.api_breaking.testing.check_freq>` (:issue:`34050`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_121.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.2.0..v1.2.1\n", "1.0.4": "\n.. _whatsnew_104:\n\nWhat's new in 1.0.4 (May 28, 2020)\n------------------------------------\n\nThese are the changes in pandas 1.0.4. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_104.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fix regression where :meth:`Series.isna` and :meth:`DataFrame.isna` would raise for categorical dtype when ``pandas.options.mode.use_inf_as_na`` was set to ``True`` (:issue:`33594`)\n- Fix regression in :meth:`.DataFrameGroupBy.first`, :meth:`.SeriesGroupBy.first`, :meth:`.DataFrameGroupBy.last`, and :meth:`.SeriesGroupBy.last` where None is not preserved in object dtype (:issue:`32800`)\n- Fix regression in DataFrame reductions using ``numeric_only=True`` and ExtensionArrays (:issue:`33256`).\n- Fix performance regression in ``memory_usage(deep=True)`` for object dtype (:issue:`33012`)\n- Fix regression where :meth:`Categorical.replace` would replace with ``NaN`` whenever the new value and replacement value were equal (:issue:`33288`)\n- Fix regression where an ordered :class:`Categorical` containing only ``NaN`` values would raise rather than returning ``NaN`` when taking the minimum or maximum  (:issue:`33450`)\n- Fix regression in :meth:`DataFrameGroupBy.agg` with dictionary input losing ``ExtensionArray`` dtypes (:issue:`32194`)\n- Fix to preserve the ability to index with the \"nearest\" method with xarray's CFTimeIndex, an :class:`Index` subclass (`pydata/xarray#3751 <https://github.com/pydata/xarray/issues/3751>`_, :issue:`32905`).\n- Fix regression in :meth:`DataFrame.describe` raising ``TypeError: unhashable type: 'dict'`` (:issue:`32409`)\n- Fix regression in :meth:`DataFrame.replace` casts columns to ``object`` dtype if items in ``to_replace`` not in values (:issue:`32988`)\n- Fix regression in :meth:`Series.groupby` would raise ``ValueError`` when grouping by :class:`PeriodIndex` level (:issue:`34010`)\n- Fix regression in :meth:`DataFrameGroupBy.rolling.apply` and :meth:`SeriesGroupBy.rolling.apply` ignoring args and kwargs parameters (:issue:`33433`)\n- Fix regression in error message with ``np.min`` or ``np.max`` on unordered :class:`Categorical` (:issue:`33115`)\n- Fix regression in :meth:`DataFrame.loc` and :meth:`Series.loc` throwing an error when a ``datetime64[ns, tz]`` value is provided (:issue:`32395`)\n\n.. _whatsnew_104.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :meth:`SeriesGroupBy.first`, :meth:`SeriesGroupBy.last`, :meth:`SeriesGroupBy.min`, and :meth:`SeriesGroupBy.max` returning floats when applied to nullable Booleans (:issue:`33071`)\n- Bug in :meth:`Rolling.min` and :meth:`Rolling.max`: Growing memory usage after multiple calls when using a fixed window (:issue:`30726`)\n- Bug in :meth:`~DataFrame.to_parquet` was not raising ``PermissionError`` when writing to a private s3 bucket with invalid creds. (:issue:`27679`)\n- Bug in :meth:`~DataFrame.to_csv` was silently failing when writing to an invalid s3 bucket. (:issue:`32486`)\n- Bug in :meth:`read_parquet` was raising a ``FileNotFoundError`` when passed an s3 directory path. (:issue:`26388`)\n- Bug in :meth:`~DataFrame.to_parquet` was throwing an ``AttributeError`` when writing a partitioned parquet file to s3 (:issue:`27596`)\n- Bug in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` causes the quantiles to be shifted when the ``by`` axis contains ``NaN`` (:issue:`33200`, :issue:`33569`)\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.0.3..v1.0.4\n", "2.1.4": ".. _whatsnew_214:\n\nWhat's new in 2.1.4 (December 8, 2023)\n---------------------------------------\n\nThese are the changes in pandas 2.1.4. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_214.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression when trying to read a pickled pandas :class:`DataFrame` from pandas 1.3 (:issue:`55137`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_214.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :class:`Series` constructor raising DeprecationWarning when ``index`` is a list of :class:`Series` (:issue:`55228`)\n- Bug in :class:`Series` when trying to cast date-like string inputs to :class:`ArrowDtype` of ``pyarrow.timestamp`` (:issue:`56266`)\n- Bug in :class:`Timestamp` construction with ``ts_input=\"now\"`` or ``ts_input=\"today\"`` giving a different unit from :meth:`Timestamp.now` or :meth:`Timestamp.today` (:issue:`55879`)\n- Bug in :meth:`Index.__getitem__` returning wrong result for Arrow dtypes and negative stepsize (:issue:`55832`)\n- Fixed bug in :func:`read_csv` not respecting object dtype when ``infer_string`` option is set (:issue:`56047`)\n- Fixed bug in :func:`to_numeric` converting to extension dtype for ``string[pyarrow_numpy]`` dtype (:issue:`56179`)\n- Fixed bug in :meth:`.DataFrameGroupBy.min` and :meth:`.DataFrameGroupBy.max` not preserving extension dtype for empty object (:issue:`55619`)\n- Fixed bug in :meth:`DataFrame.__setitem__` casting :class:`Index` with object-dtype to PyArrow backed strings when ``infer_string`` option is set (:issue:`55638`)\n- Fixed bug in :meth:`DataFrame.to_hdf` raising when columns have ``StringDtype`` (:issue:`55088`)\n- Fixed bug in :meth:`Index.insert` casting object-dtype to PyArrow backed strings when ``infer_string`` option is set (:issue:`55638`)\n- Fixed bug in :meth:`Series.__ne__` resulting in False for comparison between ``NA`` and string value for ``dtype=\"string[pyarrow_numpy]\"`` (:issue:`56122`)\n- Fixed bug in :meth:`Series.mode` not keeping object dtype when ``infer_string`` is set (:issue:`56183`)\n- Fixed bug in :meth:`Series.reset_index` not preserving object dtype when ``infer_string`` is set (:issue:`56160`)\n- Fixed bug in :meth:`Series.str.split` and :meth:`Series.str.rsplit` when ``pat=None`` for :class:`ArrowDtype` with ``pyarrow.string`` (:issue:`56271`)\n- Fixed bug in :meth:`Series.str.translate` losing object dtype when string option is set (:issue:`56152`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_214.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.1.3..v2.1.4\n", "1.1.2": ".. _whatsnew_112:\n\nWhat's new in 1.1.2 (September 8, 2020)\n---------------------------------------\n\nThese are the changes in pandas 1.1.2. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_112.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Regression in :meth:`DatetimeIndex.intersection` incorrectly raising ``AssertionError`` when intersecting against a list (:issue:`35876`)\n- Fix regression in updating a column inplace (e.g. using ``df['col'].fillna(.., inplace=True)``) (:issue:`35731`)\n- Fix regression in :meth:`DataFrame.append` mixing tz-aware and tz-naive datetime columns (:issue:`35460`)\n- Performance regression for :meth:`RangeIndex.format` (:issue:`35712`)\n- Regression where :meth:`MultiIndex.get_loc` would return a slice spanning the full index when passed an empty list (:issue:`35878`)\n- Fix regression in invalid cache after an indexing operation; this can manifest when setting which does not update the data (:issue:`35521`)\n- Regression in :meth:`DataFrame.replace` where a ``TypeError`` would be raised when attempting to replace elements of type :class:`Interval` (:issue:`35931`)\n- Fix regression in pickle roundtrip of the ``closed`` attribute of :class:`IntervalIndex` (:issue:`35658`)\n- Fixed regression in :meth:`DataFrameGroupBy.agg` where a ``ValueError: buffer source array is read-only`` would be raised when the underlying array is read-only (:issue:`36014`)\n- Fixed regression in :meth:`Series.groupby.rolling` number of levels of :class:`MultiIndex` in input was compressed to one (:issue:`36018`)\n- Fixed regression in :class:`DataFrameGroupBy` on an empty :class:`DataFrame` (:issue:`36197`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_112.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :meth:`DataFrame.eval` with ``object`` dtype column binary operations (:issue:`35794`)\n- Bug in :class:`Series` constructor raising a ``TypeError`` when constructing sparse datetime64 dtypes (:issue:`35762`)\n- Bug in :meth:`DataFrame.apply` with ``result_type=\"reduce\"`` returning with incorrect index (:issue:`35683`)\n- Bug in :meth:`Series.astype` and :meth:`DataFrame.astype` not respecting the ``errors`` argument when set to ``\"ignore\"`` for extension dtypes (:issue:`35471`)\n- Bug in :meth:`DateTimeIndex.format` and :meth:`PeriodIndex.format` with ``name=True`` setting the first item to ``\"None\"`` where it should be ``\"\"`` (:issue:`35712`)\n- Bug in :meth:`Float64Index.__contains__` incorrectly raising ``TypeError`` instead of returning ``False`` (:issue:`35788`)\n- Bug in :class:`Series` constructor incorrectly raising a ``TypeError`` when passed an ordered set (:issue:`36044`)\n- Bug in :meth:`Series.dt.isocalendar` and :meth:`DatetimeIndex.isocalendar` that returned incorrect year for certain dates (:issue:`36032`)\n- Bug in :class:`DataFrame` indexing returning an incorrect :class:`Series` in some cases when the series has been altered and a cache not invalidated (:issue:`33675`)\n- Bug in :meth:`DataFrame.corr` causing subsequent indexing lookups to be incorrect (:issue:`35882`)\n- Bug in :meth:`import_optional_dependency` returning incorrect package names in cases where package name is different from import name (:issue:`35948`)\n- Bug when setting empty :class:`DataFrame` column to a :class:`Series` in preserving name of index in frame (:issue:`31368`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_112.other:\n\nOther\n~~~~~\n- :meth:`factorize` now supports ``na_sentinel=None`` to include NaN in the uniques of the values and remove ``dropna`` keyword which was unintentionally exposed to public facing API in 1.1 version from :meth:`factorize` (:issue:`35667`)\n- :meth:`DataFrame.plot` and :meth:`Series.plot` raise ``UserWarning`` about usage of ``FixedFormatter`` and ``FixedLocator`` (:issue:`35684` and :issue:`35945`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_112.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.1.1..v1.1.2\n", "1.5.2": ".. _whatsnew_152:\n\nWhat's new in 1.5.2 (November 21, 2022)\n---------------------------------------\n\nThese are the changes in pandas 1.5.2. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_152.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`MultiIndex.join` for extension array dtypes (:issue:`49277`)\n- Fixed regression in :meth:`Series.replace` raising ``RecursionError`` with numeric dtype and when specifying ``value=None`` (:issue:`45725`)\n- Fixed regression in arithmetic operations for :class:`DataFrame` with :class:`MultiIndex` columns with different dtypes (:issue:`49769`)\n- Fixed regression in :meth:`DataFrame.plot` preventing :class:`~matplotlib.colors.Colormap` instance\n  from being passed using the ``colormap`` argument if Matplotlib 3.6+ is used (:issue:`49374`)\n- Fixed regression in :func:`date_range` returning an invalid set of periods for ``CustomBusinessDay`` frequency and ``start`` date with timezone (:issue:`49441`)\n- Fixed performance regression in groupby operations (:issue:`49676`)\n- Fixed regression in :class:`Timedelta` constructor returning object of wrong type when subclassing ``Timedelta`` (:issue:`49579`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_152.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in the Copy-on-Write implementation losing track of views in certain chained indexing cases (:issue:`48996`)\n- Fixed memory leak in :meth:`.Styler.to_excel` (:issue:`49751`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_152.other:\n\nOther\n~~~~~\n- Reverted ``color`` as an alias for ``c`` and ``size`` as an alias for ``s`` in function :meth:`DataFrame.plot.scatter` (:issue:`49732`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_152.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.5.1..v1.5.2\n", "2.0.0": ".. _whatsnew_200:\n\nWhat's new in 2.0.0 (April 3, 2023)\n-----------------------------------\n\nThese are the changes in pandas 2.0.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_200.enhancements.optional_dependency_management_pip:\n\nInstalling optional dependencies with pip extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nWhen installing pandas using pip, sets of optional dependencies can also be installed by specifying extras.\n\n.. code-block:: bash\n\n  pip install \"pandas[performance, aws]>=2.0.0\"\n\nThe available extras, found in the :ref:`installation guide<install.dependencies>`, are\n``[all, performance, computation, fss, aws, gcp, excel, parquet, feather, hdf5, spss, postgresql, mysql,\nsql-other, html, xml, plot, output_formatting, clipboard, compression, test]`` (:issue:`39164`).\n\n.. _whatsnew_200.enhancements.index_can_hold_numpy_numeric_dtypes:\n\n:class:`Index` can now hold numpy numeric dtypes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIt is now possible to use any numpy numeric dtype in a :class:`Index` (:issue:`42717`).\n\nPreviously it was only possible to use ``int64``, ``uint64`` & ``float64`` dtypes:\n\n.. code-block:: ipython\n\n    In [1]: pd.Index([1, 2, 3], dtype=np.int8)\n    Out[1]: Int64Index([1, 2, 3], dtype=\"int64\")\n    In [2]: pd.Index([1, 2, 3], dtype=np.uint16)\n    Out[2]: UInt64Index([1, 2, 3], dtype=\"uint64\")\n    In [3]: pd.Index([1, 2, 3], dtype=np.float32)\n    Out[3]: Float64Index([1.0, 2.0, 3.0], dtype=\"float64\")\n\n:class:`Int64Index`, :class:`UInt64Index` & :class:`Float64Index` were deprecated in pandas\nversion 1.4 and have now been removed. Instead :class:`Index` should be used directly, and\ncan it now take all numpy numeric dtypes, i.e.\n``int8``/ ``int16``/``int32``/``int64``/``uint8``/``uint16``/``uint32``/``uint64``/``float32``/``float64`` dtypes:\n\n.. ipython:: python\n\n    pd.Index([1, 2, 3], dtype=np.int8)\n    pd.Index([1, 2, 3], dtype=np.uint16)\n    pd.Index([1, 2, 3], dtype=np.float32)\n\nThe ability for :class:`Index` to hold the numpy numeric dtypes has meant some changes in Pandas\nfunctionality. In particular, operations that previously were forced to create 64-bit indexes,\ncan now create indexes with lower bit sizes, e.g. 32-bit indexes.\n\nBelow is a possibly non-exhaustive list of changes:\n\n1. Instantiating using a numpy numeric array now follows the dtype of the numpy array.\n   Previously, all indexes created from numpy numeric arrays were forced to 64-bit. Now,\n   for example, ``Index(np.array([1, 2, 3]))`` will be ``int32`` on 32-bit systems, where\n   it previously would have been ``int64`` even on 32-bit systems.\n   Instantiating :class:`Index` using a list of numbers will still return 64bit dtypes,\n   e.g. ``Index([1, 2, 3])`` will have a ``int64`` dtype, which is the same as previously.\n2. The various numeric datetime attributes of :class:`DatetimeIndex` (:attr:`~DatetimeIndex.day`,\n   :attr:`~DatetimeIndex.month`, :attr:`~DatetimeIndex.year` etc.) were previously in of\n   dtype ``int64``, while they were ``int32`` for :class:`arrays.DatetimeArray`. They are now\n   ``int32`` on :class:`DatetimeIndex` also:\n\n   .. ipython:: python\n\n       idx = pd.date_range(start='1/1/2018', periods=3, freq='ME')\n       idx.array.year\n       idx.year\n\n3. Level dtypes on Indexes from :meth:`Series.sparse.from_coo` are now of dtype ``int32``,\n   the same as they are on the ``rows``/``cols`` on a scipy sparse matrix. Previously they\n   were of dtype ``int64``.\n\n   .. ipython:: python\n\n       from scipy import sparse\n       A = sparse.coo_matrix(\n           ([3.0, 1.0, 2.0], ([1, 0, 0], [0, 2, 3])), shape=(3, 4)\n       )\n       ser = pd.Series.sparse.from_coo(A)\n       ser.index.dtypes\n\n4. :class:`Index` cannot be instantiated using a float16 dtype. Previously instantiating\n   an :class:`Index` using dtype ``float16`` resulted in a :class:`Float64Index` with a\n   ``float64`` dtype. It now raises a ``NotImplementedError``:\n\n   .. ipython:: python\n       :okexcept:\n\n       pd.Index([1, 2, 3], dtype=np.float16)\n\n\n.. _whatsnew_200.enhancements.io_dtype_backend:\n\nArgument ``dtype_backend``, to return pyarrow-backed or numpy-backed nullable dtypes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe following functions gained a new keyword ``dtype_backend`` (:issue:`36712`)\n\n* :func:`read_csv`\n* :func:`read_clipboard`\n* :func:`read_fwf`\n* :func:`read_excel`\n* :func:`read_html`\n* :func:`read_xml`\n* :func:`read_json`\n* :func:`read_sql`\n* :func:`read_sql_query`\n* :func:`read_sql_table`\n* :func:`read_parquet`\n* :func:`read_orc`\n* :func:`read_feather`\n* :func:`read_spss`\n* :func:`to_numeric`\n* :meth:`DataFrame.convert_dtypes`\n* :meth:`Series.convert_dtypes`\n\nWhen this option is set to ``\"numpy_nullable\"`` it will return a :class:`DataFrame` that is\nbacked by nullable dtypes.\n\nWhen this keyword is set to ``\"pyarrow\"``, then these functions will return pyarrow-backed nullable :class:`ArrowDtype` DataFrames (:issue:`48957`, :issue:`49997`):\n\n* :func:`read_csv`\n* :func:`read_clipboard`\n* :func:`read_fwf`\n* :func:`read_excel`\n* :func:`read_html`\n* :func:`read_xml`\n* :func:`read_json`\n* :func:`read_sql`\n* :func:`read_sql_query`\n* :func:`read_sql_table`\n* :func:`read_parquet`\n* :func:`read_orc`\n* :func:`read_feather`\n* :func:`read_spss`\n* :func:`to_numeric`\n* :meth:`DataFrame.convert_dtypes`\n* :meth:`Series.convert_dtypes`\n\n.. ipython:: python\n\n    import io\n    data = io.StringIO(\"\"\"a,b,c,d,e,f,g,h,i\n        1,2.5,True,a,,,,,\n        3,4.5,False,b,6,7.5,True,a,\n    \"\"\")\n    df = pd.read_csv(data, dtype_backend=\"pyarrow\")\n    df.dtypes\n\n    data.seek(0)\n    df_pyarrow = pd.read_csv(data, dtype_backend=\"pyarrow\", engine=\"pyarrow\")\n    df_pyarrow.dtypes\n\nCopy-on-Write improvements\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n- A new lazy copy mechanism that defers the copy until the object in question is modified\n  was added to the methods listed in\n  :ref:`Copy-on-Write optimizations <copy_on_write.optimizations>`.\n  These methods return views when Copy-on-Write is enabled, which provides a significant\n  performance improvement compared to the regular execution (:issue:`49473`).\n\n- Accessing a single column of a DataFrame as a Series (e.g. ``df[\"col\"]``) now always\n  returns a new object every time it is constructed when Copy-on-Write is enabled (not\n  returning multiple times an identical, cached Series object). This ensures that those\n  Series objects correctly follow the Copy-on-Write rules (:issue:`49450`)\n\n- The :class:`Series` constructor will now create a lazy copy (deferring the copy until\n  a modification to the data happens) when constructing a Series from an existing\n  Series with the default of ``copy=False`` (:issue:`50471`)\n\n- The :class:`DataFrame` constructor will now create a lazy copy (deferring the copy until\n  a modification to the data happens) when constructing from an existing\n  :class:`DataFrame` with the default of ``copy=False`` (:issue:`51239`)\n\n- The :class:`DataFrame` constructor, when constructing a DataFrame from a dictionary\n  of Series objects and specifying ``copy=False``, will now use a lazy copy\n  of those Series objects for the columns of the DataFrame (:issue:`50777`)\n\n- The :class:`DataFrame` constructor, when constructing a DataFrame from a\n  :class:`Series` or :class:`Index` and specifying ``copy=False``, will\n  now respect Copy-on-Write.\n\n- The :class:`DataFrame` and :class:`Series` constructors, when constructing from\n  a NumPy array, will now copy the array by default to avoid mutating\n  the :class:`DataFrame` / :class:`Series`\n  when mutating the array. Specify ``copy=False`` to get the old behavior.\n  When setting ``copy=False`` pandas does not guarantee correct Copy-on-Write\n  behavior when the NumPy array is modified after creation of the\n  :class:`DataFrame` / :class:`Series`.\n\n- The :meth:`DataFrame.from_records` will now respect Copy-on-Write when called\n  with a :class:`DataFrame`.\n\n- Trying to set values using chained assignment (for example, ``df[\"a\"][1:3] = 0``)\n  will now always raise a warning when Copy-on-Write is enabled. In this mode,\n  chained assignment can never work because we are always setting into a temporary\n  object that is the result of an indexing operation (getitem), which under\n  Copy-on-Write always behaves as a copy. Thus, assigning through a chain\n  can never update the original Series or DataFrame. Therefore, an informative\n  warning is raised to the user to avoid silently doing nothing (:issue:`49467`)\n\n- :meth:`DataFrame.replace` will now respect the Copy-on-Write mechanism\n  when ``inplace=True``.\n\n- :meth:`DataFrame.transpose` will now respect the Copy-on-Write mechanism.\n\n- Arithmetic operations that can be inplace, e.g. ``ser *= 2`` will now respect the\n  Copy-on-Write mechanism.\n\n- :meth:`DataFrame.__getitem__` will now respect the Copy-on-Write mechanism when the\n  :class:`DataFrame` has :class:`MultiIndex` columns.\n\n- :meth:`Series.__getitem__` will now respect the Copy-on-Write mechanism when the\n   :class:`Series` has a :class:`MultiIndex`.\n\n- :meth:`Series.view` will now respect the Copy-on-Write mechanism.\n\nCopy-on-Write can be enabled through one of\n\n.. code-block:: python\n\n    pd.set_option(\"mode.copy_on_write\", True)\n\n\n.. code-block:: python\n\n    pd.options.mode.copy_on_write = True\n\nAlternatively, copy on write can be enabled locally through:\n\n.. code-block:: python\n\n    with pd.option_context(\"mode.copy_on_write\", True):\n        ...\n\n.. _whatsnew_200.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n- Added support for ``str`` accessor methods when using :class:`ArrowDtype`  with a ``pyarrow.string`` type (:issue:`50325`)\n- Added support for ``dt`` accessor methods when using :class:`ArrowDtype` with a ``pyarrow.timestamp`` type (:issue:`50954`)\n- :func:`read_sas` now supports using ``encoding='infer'`` to correctly read and use the encoding specified by the sas file. (:issue:`48048`)\n- :meth:`.DataFrameGroupBy.quantile`, :meth:`.SeriesGroupBy.quantile` and :meth:`.DataFrameGroupBy.std` now preserve nullable dtypes instead of casting to numpy dtypes (:issue:`37493`)\n- :meth:`.DataFrameGroupBy.std`, :meth:`.SeriesGroupBy.std` now support datetime64, timedelta64, and :class:`DatetimeTZDtype` dtypes (:issue:`48481`)\n- :meth:`Series.add_suffix`, :meth:`DataFrame.add_suffix`, :meth:`Series.add_prefix` and :meth:`DataFrame.add_prefix` support an ``axis`` argument. If ``axis`` is set, the default behaviour of which axis to consider can be overwritten (:issue:`47819`)\n- :func:`.testing.assert_frame_equal` now shows the first element where the DataFrames differ, analogously to ``pytest``'s output (:issue:`47910`)\n- Added ``index`` parameter to :meth:`DataFrame.to_dict` (:issue:`46398`)\n- Added support for extension array dtypes in :func:`merge` (:issue:`44240`)\n- Added metadata propagation for binary operators on :class:`DataFrame` (:issue:`28283`)\n- Added ``cumsum``, ``cumprod``, ``cummin`` and ``cummax`` to the ``ExtensionArray`` interface via ``_accumulate`` (:issue:`28385`)\n- :class:`.CategoricalConversionWarning`, :class:`.InvalidComparison`, :class:`.InvalidVersion`, :class:`.LossySetitemError`, and :class:`.NoBufferPresent` are now exposed in ``pandas.errors`` (:issue:`27656`)\n- Fix ``test`` optional_extra by adding missing test package ``pytest-asyncio`` (:issue:`48361`)\n- :func:`DataFrame.astype` exception message thrown improved to include column name when type conversion is not possible. (:issue:`47571`)\n- :func:`date_range` now supports a ``unit`` keyword (\"s\", \"ms\", \"us\", or \"ns\") to specify the desired resolution of the output index (:issue:`49106`)\n- :func:`timedelta_range` now supports a ``unit`` keyword (\"s\", \"ms\", \"us\", or \"ns\") to specify the desired resolution of the output index (:issue:`49824`)\n- :meth:`DataFrame.to_json` now supports a ``mode`` keyword with supported inputs 'w' and 'a'. Defaulting to 'w', 'a' can be used when lines=True and orient='records' to append record oriented json lines to an existing json file. (:issue:`35849`)\n- Added ``name`` parameter to :meth:`IntervalIndex.from_breaks`, :meth:`IntervalIndex.from_arrays` and :meth:`IntervalIndex.from_tuples` (:issue:`48911`)\n- Improve exception message when using :func:`.testing.assert_frame_equal` on a :class:`DataFrame` to include the column that is compared (:issue:`50323`)\n- Improved error message for :func:`merge_asof` when join-columns were duplicated (:issue:`50102`)\n- Added support for extension array dtypes to :func:`get_dummies` (:issue:`32430`)\n- Added :meth:`Index.infer_objects` analogous to :meth:`Series.infer_objects` (:issue:`50034`)\n- Added ``copy`` parameter to :meth:`Series.infer_objects` and :meth:`DataFrame.infer_objects`, passing ``False`` will avoid making copies for series or columns that are already non-object or where no better dtype can be inferred (:issue:`50096`)\n- :meth:`DataFrame.plot.hist` now recognizes ``xlabel`` and ``ylabel`` arguments (:issue:`49793`)\n- :meth:`Series.drop_duplicates` has gained ``ignore_index`` keyword to reset index (:issue:`48304`)\n- :meth:`Series.dropna` and :meth:`DataFrame.dropna` has gained ``ignore_index`` keyword to reset index (:issue:`31725`)\n- Improved error message in :func:`to_datetime` for non-ISO8601 formats, informing users about the position of the first error (:issue:`50361`)\n- Improved error message when trying to align :class:`DataFrame` objects (for example, in :func:`DataFrame.compare`) to clarify that \"identically labelled\" refers to both index and columns (:issue:`50083`)\n- Added support for :meth:`Index.min` and :meth:`Index.max` for pyarrow string dtypes (:issue:`51397`)\n- Added :meth:`DatetimeIndex.as_unit` and :meth:`TimedeltaIndex.as_unit` to convert to different resolutions; supported resolutions are \"s\", \"ms\", \"us\", and \"ns\" (:issue:`50616`)\n- Added :meth:`Series.dt.unit` and :meth:`Series.dt.as_unit` to convert to different resolutions; supported resolutions are \"s\", \"ms\", \"us\", and \"ns\" (:issue:`51223`)\n- Added new argument ``dtype`` to :func:`read_sql` to be consistent with :func:`read_sql_query` (:issue:`50797`)\n- :func:`read_csv`, :func:`read_table`, :func:`read_fwf` and :func:`read_excel` now accept ``date_format`` (:issue:`50601`)\n- :func:`to_datetime` now accepts ``\"ISO8601\"`` as an argument to ``format``, which will match any ISO8601 string (but possibly not identically-formatted) (:issue:`50411`)\n- :func:`to_datetime` now accepts ``\"mixed\"`` as an argument to ``format``, which will infer the format for each element individually (:issue:`50972`)\n- Added new argument ``engine`` to :func:`read_json` to support parsing JSON with pyarrow by specifying ``engine=\"pyarrow\"`` (:issue:`48893`)\n- Added support for SQLAlchemy 2.0 (:issue:`40686`)\n- Added support for ``decimal`` parameter when ``engine=\"pyarrow\"`` in :func:`read_csv` (:issue:`51302`)\n- :class:`Index` set operations :meth:`Index.union`, :meth:`Index.intersection`, :meth:`Index.difference`, and :meth:`Index.symmetric_difference` now support ``sort=True``, which will always return a sorted result, unlike the default ``sort=None`` which does not sort in some cases (:issue:`25151`)\n- Added new escape mode \"latex-math\" to avoid escaping \"$\" in formatter (:issue:`50040`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.notable_bug_fixes:\n\nNotable bug fixes\n~~~~~~~~~~~~~~~~~\n\nThese are bug fixes that might have notable behavior changes.\n\n.. _whatsnew_200.notable_bug_fixes.cumsum_cumprod_overflow:\n\n:meth:`.DataFrameGroupBy.cumsum` and :meth:`.DataFrameGroupBy.cumprod` overflow instead of lossy casting to float\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn previous versions we cast to float when applying ``cumsum`` and ``cumprod`` which\nlead to incorrect results even if the result could be hold by ``int64`` dtype.\nAdditionally, the aggregation overflows consistent with numpy and the regular\n:meth:`DataFrame.cumprod` and :meth:`DataFrame.cumsum` methods when the limit of\n``int64`` is reached (:issue:`37493`).\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [1]: df = pd.DataFrame({\"key\": [\"b\"] * 7, \"value\": 625})\n    In [2]: df.groupby(\"key\")[\"value\"].cumprod()[5]\n    Out[2]: 5.960464477539062e+16\n\nWe return incorrect results with the 6th value.\n\n*New Behavior*\n\n.. ipython:: python\n\n    df = pd.DataFrame({\"key\": [\"b\"] * 7, \"value\": 625})\n    df.groupby(\"key\")[\"value\"].cumprod()\n\nWe overflow with the 7th value, but the 6th value is still correct.\n\n.. _whatsnew_200.notable_bug_fixes.groupby_nth_filter:\n\n:meth:`.DataFrameGroupBy.nth` and :meth:`.SeriesGroupBy.nth` now behave as filtrations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn previous versions of pandas, :meth:`.DataFrameGroupBy.nth` and\n:meth:`.SeriesGroupBy.nth` acted as if they were aggregations. However, for most\ninputs ``n``, they may return either zero or multiple rows per group. This means\nthat they are filtrations, similar to e.g. :meth:`.DataFrameGroupBy.head`. pandas\nnow treats them as filtrations (:issue:`13666`).\n\n.. ipython:: python\n\n    df = pd.DataFrame({\"a\": [1, 1, 2, 1, 2], \"b\": [np.nan, 2.0, 3.0, 4.0, 5.0]})\n    gb = df.groupby(\"a\")\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [5]: gb.nth(n=1)\n    Out[5]:\n       A    B\n    1  1  2.0\n    4  2  5.0\n\n*New Behavior*\n\n.. ipython:: python\n\n    gb.nth(n=1)\n\nIn particular, the index of the result is derived from the input by selecting\nthe appropriate rows. Also, when ``n`` is larger than the group, no rows instead of\n``NaN`` is returned.\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [5]: gb.nth(n=3, dropna=\"any\")\n    Out[5]:\n        B\n    A\n    1 NaN\n    2 NaN\n\n*New Behavior*\n\n.. ipython:: python\n\n    gb.nth(n=3, dropna=\"any\")\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.api_breaking:\n\nBackwards incompatible API changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_200.api_breaking.unsupported_datetimelike_dtype_arg:\n\nConstruction with datetime64 or timedelta64 dtype with unsupported resolution\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIn past versions, when constructing a :class:`Series` or :class:`DataFrame` and\npassing a \"datetime64\" or \"timedelta64\" dtype with unsupported resolution\n(i.e. anything other than \"ns\"), pandas would silently replace the given dtype\nwith its nanosecond analogue:\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [5]: pd.Series([\"2016-01-01\"], dtype=\"datetime64[s]\")\n   Out[5]:\n   0   2016-01-01\n   dtype: datetime64[ns]\n\n   In [6] pd.Series([\"2016-01-01\"], dtype=\"datetime64[D]\")\n   Out[6]:\n   0   2016-01-01\n   dtype: datetime64[ns]\n\nIn pandas 2.0 we support resolutions \"s\", \"ms\", \"us\", and \"ns\". When passing\na supported dtype (e.g. \"datetime64[s]\"), the result now has exactly\nthe requested dtype:\n\n*New behavior*:\n\n.. ipython:: python\n\n   pd.Series([\"2016-01-01\"], dtype=\"datetime64[s]\")\n\nWith an un-supported dtype, pandas now raises instead of silently swapping in\na supported dtype:\n\n*New behavior*:\n\n.. ipython:: python\n   :okexcept:\n\n   pd.Series([\"2016-01-01\"], dtype=\"datetime64[D]\")\n\n.. _whatsnew_200.api_breaking.value_counts:\n\nValue counts sets the resulting name to ``count``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIn past versions, when running :meth:`Series.value_counts`, the result would inherit\nthe original object's name, and the result index would be nameless. This would cause\nconfusion when resetting the index, and the column names would not correspond with the\ncolumn values.\nNow, the result name will be ``'count'`` (or ``'proportion'`` if ``normalize=True`` was passed),\nand the index will be named after the original object (:issue:`49497`).\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [8]: pd.Series(['quetzal', 'quetzal', 'elk'], name='animal').value_counts()\n\n    Out[2]:\n    quetzal    2\n    elk        1\n    Name: animal, dtype: int64\n\n*New behavior*:\n\n.. ipython:: python\n\n    pd.Series(['quetzal', 'quetzal', 'elk'], name='animal').value_counts()\n\nLikewise for other ``value_counts`` methods (for example, :meth:`DataFrame.value_counts`).\n\n.. _whatsnew_200.api_breaking.astype_to_unsupported_datetimelike:\n\nDisallow astype conversion to non-supported datetime64/timedelta64 dtypes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIn previous versions, converting a :class:`Series` or :class:`DataFrame`\nfrom ``datetime64[ns]`` to a different ``datetime64[X]`` dtype would return\nwith ``datetime64[ns]`` dtype instead of the requested dtype. In pandas 2.0,\nsupport is added for \"datetime64[s]\", \"datetime64[ms]\", and \"datetime64[us]\" dtypes,\nso converting to those dtypes gives exactly the requested dtype:\n\n*Previous behavior*:\n\n.. ipython:: python\n\n   idx = pd.date_range(\"2016-01-01\", periods=3)\n   ser = pd.Series(idx)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [4]: ser.astype(\"datetime64[s]\")\n   Out[4]:\n   0   2016-01-01\n   1   2016-01-02\n   2   2016-01-03\n   dtype: datetime64[ns]\n\nWith the new behavior, we get exactly the requested dtype:\n\n*New behavior*:\n\n.. ipython:: python\n\n   ser.astype(\"datetime64[s]\")\n\nFor non-supported resolutions e.g. \"datetime64[D]\", we raise instead of silently\nignoring the requested dtype:\n\n*New behavior*:\n\n.. ipython:: python\n   :okexcept:\n\n   ser.astype(\"datetime64[D]\")\n\nFor conversion from ``timedelta64[ns]`` dtypes, the old behavior converted\nto a floating point format.\n\n*Previous behavior*:\n\n.. ipython:: python\n\n   idx = pd.timedelta_range(\"1 Day\", periods=3)\n   ser = pd.Series(idx)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [7]: ser.astype(\"timedelta64[s]\")\n   Out[7]:\n   0     86400.0\n   1    172800.0\n   2    259200.0\n   dtype: float64\n\n   In [8]: ser.astype(\"timedelta64[D]\")\n   Out[8]:\n   0    1.0\n   1    2.0\n   2    3.0\n   dtype: float64\n\nThe new behavior, as for datetime64, either gives exactly the requested dtype or raises:\n\n*New behavior*:\n\n.. ipython:: python\n   :okexcept:\n\n   ser.astype(\"timedelta64[s]\")\n   ser.astype(\"timedelta64[D]\")\n\n.. _whatsnew_200.api_breaking.default_to_stdlib_tzinfos:\n\nUTC and fixed-offset timezones default to standard-library tzinfo objects\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIn previous versions, the default ``tzinfo`` object used to represent UTC\nwas ``pytz.UTC``. In pandas 2.0, we default to ``datetime.timezone.utc`` instead.\nSimilarly, for timezones represent fixed UTC offsets, we use ``datetime.timezone``\nobjects instead of ``pytz.FixedOffset`` objects. See (:issue:`34916`)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [2]: ts = pd.Timestamp(\"2016-01-01\", tz=\"UTC\")\n   In [3]: type(ts.tzinfo)\n   Out[3]: pytz.UTC\n\n   In [4]: ts2 = pd.Timestamp(\"2016-01-01 04:05:06-07:00\")\n   In [3]: type(ts2.tzinfo)\n   Out[5]: pytz._FixedOffset\n\n*New behavior*:\n\n.. ipython:: python\n\n   ts = pd.Timestamp(\"2016-01-01\", tz=\"UTC\")\n   type(ts.tzinfo)\n\n   ts2 = pd.Timestamp(\"2016-01-01 04:05:06-07:00\")\n   type(ts2.tzinfo)\n\nFor timezones that are neither UTC nor fixed offsets, e.g. \"US/Pacific\", we\ncontinue to default to ``pytz`` objects.\n\n.. _whatsnew_200.api_breaking.zero_len_indexes:\n\nEmpty DataFrames/Series will now default to have a ``RangeIndex``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nBefore, constructing an empty (where ``data`` is ``None`` or an empty list-like argument) :class:`Series` or :class:`DataFrame` without\nspecifying the axes (``index=None``, ``columns=None``) would return the axes as empty :class:`Index` with object dtype.\n\nNow, the axes return an empty :class:`RangeIndex` (:issue:`49572`).\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [8]: pd.Series().index\n   Out[8]:\n   Index([], dtype='object')\n\n   In [9] pd.DataFrame().axes\n   Out[9]:\n   [Index([], dtype='object'), Index([], dtype='object')]\n\n*New behavior*:\n\n.. ipython:: python\n\n   pd.Series().index\n   pd.DataFrame().axes\n\n.. _whatsnew_200.api_breaking.to_latex:\n\nDataFrame to LaTeX has a new render engine\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe existing :meth:`DataFrame.to_latex` has been restructured to utilise the\nextended implementation previously available under :meth:`.Styler.to_latex`.\nThe arguments signature is similar, albeit ``col_space`` has been removed since\nit is ignored by LaTeX engines. This render engine also requires ``jinja2`` as a\ndependency which needs to be installed, since rendering is based upon jinja2 templates.\n\nThe pandas latex options below are no longer used and have been removed. The generic\nmax rows and columns arguments remain but for this functionality should be replaced\nby the Styler equivalents.\nThe alternative options giving similar functionality are indicated below:\n\n- ``display.latex.escape``: replaced with ``styler.format.escape``,\n- ``display.latex.longtable``: replaced with ``styler.latex.environment``,\n- ``display.latex.multicolumn``, ``display.latex.multicolumn_format`` and\n  ``display.latex.multirow``: replaced with ``styler.sparse.rows``,\n  ``styler.sparse.columns``, ``styler.latex.multirow_align`` and\n  ``styler.latex.multicol_align``,\n- ``display.latex.repr``: replaced with ``styler.render.repr``,\n- ``display.max_rows`` and ``display.max_columns``: replace with\n  ``styler.render.max_rows``, ``styler.render.max_columns`` and\n  ``styler.render.max_elements``.\n\nNote that due to this change some defaults have also changed:\n\n- ``multirow`` now defaults to *True*.\n- ``multirow_align`` defaults to *\"r\"* instead of *\"l\"*.\n- ``multicol_align`` defaults to *\"r\"* instead of *\"l\"*.\n- ``escape`` now defaults to *False*.\n\nNote that the behaviour of ``_repr_latex_`` is also changed. Previously\nsetting ``display.latex.repr`` would generate LaTeX only when using nbconvert for a\nJupyterNotebook, and not when the user is running the notebook. Now the\n``styler.render.repr`` option allows control of the specific output\nwithin JupyterNotebooks for operations (not just on nbconvert). See :issue:`39911`.\n\n.. _whatsnew_200.api_breaking.deps:\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSome minimum supported versions of dependencies were updated.\nIf installed, we now require:\n\n+-------------------+-----------------+----------+---------+\n| Package           | Minimum Version | Required | Changed |\n+===================+=================+==========+=========+\n| mypy (dev)        | 1.0             |          |    X    |\n+-------------------+-----------------+----------+---------+\n| pytest (dev)      | 7.0.0           |          |    X    |\n+-------------------+-----------------+----------+---------+\n| pytest-xdist (dev)| 2.2.0           |          |    X    |\n+-------------------+-----------------+----------+---------+\n| hypothesis (dev)  | 6.34.2          |          |    X    |\n+-------------------+-----------------+----------+---------+\n| python-dateutil   | 2.8.2           |    X     |    X    |\n+-------------------+-----------------+----------+---------+\n| tzdata            | 2022.1          |    X     |    X    |\n+-------------------+-----------------+----------+---------+\n\nFor `optional libraries <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\nThe following table lists the lowest version per library that is currently being tested throughout the development of pandas.\nOptional libraries below the lowest tested version may still work, but are not considered supported.\n\n+-----------------+-----------------+---------+\n| Package         | Minimum Version | Changed |\n+=================+=================+=========+\n| pyarrow         | 7.0.0           |    X    |\n+-----------------+-----------------+---------+\n| matplotlib      | 3.6.1           |    X    |\n+-----------------+-----------------+---------+\n| fastparquet     | 0.6.3           |    X    |\n+-----------------+-----------------+---------+\n| xarray          | 0.21.0          |    X    |\n+-----------------+-----------------+---------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\nDatetimes are now parsed with a consistent format\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn the past, :func:`to_datetime` guessed the format for each element independently. This was appropriate for some cases where elements had mixed date formats - however, it would regularly cause problems when users expected a consistent format but the function would switch formats between elements. As of version 2.0.0, parsing will use a consistent format, determined by the first non-NA value (unless the user specifies a format, in which case that is used).\n\n*Old behavior*:\n\n.. code-block:: ipython\n\n   In [1]: ser = pd.Series(['13-01-2000', '12-01-2000'])\n   In [2]: pd.to_datetime(ser)\n   Out[2]:\n   0   2000-01-13\n   1   2000-12-01\n   dtype: datetime64[ns]\n\n*New behavior*:\n\n.. ipython:: python\n    :okwarning:\n\n     ser = pd.Series(['13-01-2000', '12-01-2000'])\n     pd.to_datetime(ser)\n\nNote that this affects :func:`read_csv` as well.\n\nIf you still need to parse dates with inconsistent formats, you can use\n``format='mixed'`` (possibly alongside ``dayfirst``) ::\n\n     ser = pd.Series(['13-01-2000', '12 January 2000'])\n     pd.to_datetime(ser, format='mixed', dayfirst=True)\n\nor, if your formats are all ISO8601 (but possibly not identically-formatted) ::\n\n     ser = pd.Series(['2020-01-01', '2020-01-01 03:00'])\n     pd.to_datetime(ser, format='ISO8601')\n\n.. _whatsnew_200.api_breaking.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n- The ``freq``, ``tz``, ``nanosecond``, and ``unit`` keywords in the :class:`Timestamp` constructor are now keyword-only (:issue:`45307`, :issue:`32526`)\n- Passing ``nanoseconds`` greater than 999 or less than 0 in :class:`Timestamp` now raises a ``ValueError`` (:issue:`48538`, :issue:`48255`)\n- :func:`read_csv`: specifying an incorrect number of columns with ``index_col`` of now raises ``ParserError`` instead of ``IndexError`` when using the c parser.\n- Default value of ``dtype`` in :func:`get_dummies` is changed to ``bool`` from ``uint8`` (:issue:`45848`)\n- :meth:`DataFrame.astype`, :meth:`Series.astype`, and :meth:`DatetimeIndex.astype` casting datetime64 data to any of \"datetime64[s]\", \"datetime64[ms]\", \"datetime64[us]\" will return an object with the given resolution instead of coercing back to \"datetime64[ns]\" (:issue:`48928`)\n- :meth:`DataFrame.astype`, :meth:`Series.astype`, and :meth:`DatetimeIndex.astype` casting timedelta64 data to any of \"timedelta64[s]\", \"timedelta64[ms]\", \"timedelta64[us]\" will return an object with the given resolution instead of coercing to \"float64\" dtype (:issue:`48963`)\n- :meth:`DatetimeIndex.astype`, :meth:`TimedeltaIndex.astype`, :meth:`PeriodIndex.astype` :meth:`Series.astype`, :meth:`DataFrame.astype` with ``datetime64``, ``timedelta64`` or :class:`PeriodDtype` dtypes no longer allow converting to integer dtypes other than \"int64\", do ``obj.astype('int64', copy=False).astype(dtype)`` instead (:issue:`49715`)\n- :meth:`Index.astype` now allows casting from ``float64`` dtype to datetime-like dtypes, matching :class:`Series` behavior (:issue:`49660`)\n- Passing data with dtype of \"timedelta64[s]\", \"timedelta64[ms]\", or \"timedelta64[us]\" to :class:`TimedeltaIndex`, :class:`Series`, or :class:`DataFrame` constructors will now retain that dtype instead of casting to \"timedelta64[ns]\"; timedelta64 data with lower resolution will be cast to the lowest supported resolution \"timedelta64[s]\" (:issue:`49014`)\n- Passing ``dtype`` of \"timedelta64[s]\", \"timedelta64[ms]\", or \"timedelta64[us]\" to :class:`TimedeltaIndex`, :class:`Series`, or :class:`DataFrame` constructors will now retain that dtype instead of casting to \"timedelta64[ns]\"; passing a dtype with lower resolution for :class:`Series` or :class:`DataFrame` will be cast to the lowest supported resolution \"timedelta64[s]\" (:issue:`49014`)\n- Passing a ``np.datetime64`` object with non-nanosecond resolution to :class:`Timestamp` will retain the input resolution if it is \"s\", \"ms\", \"us\", or \"ns\"; otherwise it will be cast to the closest supported resolution (:issue:`49008`)\n- Passing ``datetime64`` values with resolution other than nanosecond to :func:`to_datetime` will retain the input resolution if it is \"s\", \"ms\", \"us\", or \"ns\"; otherwise it will be cast to the closest supported resolution (:issue:`50369`)\n- Passing integer values and a non-nanosecond datetime64 dtype (e.g. \"datetime64[s]\") :class:`DataFrame`, :class:`Series`, or :class:`Index` will treat the values as multiples of the dtype's unit, matching the behavior of e.g. ``Series(np.array(values, dtype=\"M8[s]\"))`` (:issue:`51092`)\n- Passing a string in ISO-8601 format to :class:`Timestamp` will retain the resolution of the parsed input if it is \"s\", \"ms\", \"us\", or \"ns\"; otherwise it will be cast to the closest supported resolution (:issue:`49737`)\n- The ``other`` argument in :meth:`DataFrame.mask` and :meth:`Series.mask` now defaults to ``no_default`` instead of ``np.nan`` consistent with :meth:`DataFrame.where` and :meth:`Series.where`. Entries will be filled with the corresponding NULL value (``np.nan`` for numpy dtypes, ``pd.NA`` for extension dtypes). (:issue:`49111`)\n- Changed behavior of :meth:`Series.quantile` and :meth:`DataFrame.quantile` with :class:`SparseDtype` to retain sparse dtype (:issue:`49583`)\n- When creating a :class:`Series` with a object-dtype :class:`Index` of datetime objects, pandas no longer silently converts the index to a :class:`DatetimeIndex` (:issue:`39307`, :issue:`23598`)\n- :func:`pandas.testing.assert_index_equal` with parameter ``exact=\"equiv\"`` now considers two indexes equal when both are either a :class:`RangeIndex` or :class:`Index` with an ``int64`` dtype. Previously it meant either a :class:`RangeIndex` or a :class:`Int64Index` (:issue:`51098`)\n- :meth:`Series.unique` with dtype \"timedelta64[ns]\" or \"datetime64[ns]\" now returns :class:`TimedeltaArray` or :class:`DatetimeArray` instead of ``numpy.ndarray`` (:issue:`49176`)\n- :func:`to_datetime` and :class:`DatetimeIndex` now allow sequences containing both ``datetime`` objects and numeric entries, matching :class:`Series` behavior (:issue:`49037`, :issue:`50453`)\n- :func:`pandas.api.types.is_string_dtype` now only returns ``True`` for array-likes with ``dtype=object`` when the elements are inferred to be strings (:issue:`15585`)\n- Passing a sequence containing ``datetime`` objects and ``date`` objects to :class:`Series` constructor will return with ``object`` dtype instead of ``datetime64[ns]`` dtype, consistent with :class:`Index` behavior (:issue:`49341`)\n- Passing strings that cannot be parsed as datetimes to :class:`Series` or :class:`DataFrame` with ``dtype=\"datetime64[ns]\"`` will raise instead of silently ignoring the keyword and returning ``object`` dtype (:issue:`24435`)\n- Passing a sequence containing a type that cannot be converted to :class:`Timedelta` to :func:`to_timedelta` or to the :class:`Series` or :class:`DataFrame` constructor with ``dtype=\"timedelta64[ns]\"`` or to :class:`TimedeltaIndex` now raises ``TypeError`` instead of ``ValueError`` (:issue:`49525`)\n- Changed behavior of :class:`Index` constructor with sequence containing at least one ``NaT`` and everything else either ``None`` or ``NaN`` to infer ``datetime64[ns]`` dtype instead of ``object``, matching :class:`Series` behavior (:issue:`49340`)\n- :func:`read_stata` with parameter ``index_col`` set to ``None`` (the default) will now set the index on the returned :class:`DataFrame` to a :class:`RangeIndex` instead of a :class:`Int64Index` (:issue:`49745`)\n- Changed behavior of :class:`Index`, :class:`Series`, and :class:`DataFrame` arithmetic methods when working with object-dtypes, the results no longer do type inference on the result of the array operations, use ``result.infer_objects(copy=False)`` to do type inference on the result (:issue:`49999`, :issue:`49714`)\n- Changed behavior of :class:`Index` constructor with an object-dtype ``numpy.ndarray`` containing all-``bool`` values or all-complex values, this will now retain object dtype, consistent with the :class:`Series` behavior (:issue:`49594`)\n- Changed behavior of :meth:`Series.astype` from object-dtype containing ``bytes`` objects to string dtypes; this now does ``val.decode()`` on bytes objects instead of ``str(val)``, matching :meth:`Index.astype` behavior (:issue:`45326`)\n- Added ``\"None\"`` to default ``na_values`` in :func:`read_csv` (:issue:`50286`)\n- Changed behavior of :class:`Series` and :class:`DataFrame` constructors when given an integer dtype and floating-point data that is not round numbers, this now raises ``ValueError`` instead of silently retaining the float dtype; do ``Series(data)`` or ``DataFrame(data)`` to get the old behavior, and ``Series(data).astype(dtype)`` or ``DataFrame(data).astype(dtype)`` to get the specified dtype (:issue:`49599`)\n- Changed behavior of :meth:`DataFrame.shift` with ``axis=1``, an integer ``fill_value``, and homogeneous datetime-like dtype, this now fills new columns with integer dtypes instead of casting to datetimelike (:issue:`49842`)\n- Files are now closed when encountering an exception in :func:`read_json` (:issue:`49921`)\n- Changed behavior of :func:`read_csv`, :func:`read_json` & :func:`read_fwf`, where the index will now always be a :class:`RangeIndex`, when no index is specified. Previously the index would be a :class:`Index` with dtype ``object`` if the new DataFrame/Series has length 0 (:issue:`49572`)\n- :meth:`DataFrame.values`, :meth:`DataFrame.to_numpy`, :meth:`DataFrame.xs`, :meth:`DataFrame.reindex`, :meth:`DataFrame.fillna`, and :meth:`DataFrame.replace` no longer silently consolidate the underlying arrays; do ``df = df.copy()`` to ensure consolidation (:issue:`49356`)\n- Creating a new DataFrame using a full slice on both axes with :attr:`~DataFrame.loc`\n  or :attr:`~DataFrame.iloc` (thus, ``df.loc[:, :]`` or ``df.iloc[:, :]``) now returns a\n  new DataFrame (shallow copy) instead of the original DataFrame, consistent with other\n  methods to get a full slice (for example ``df.loc[:]`` or ``df[:]``) (:issue:`49469`)\n- The :class:`Series` and :class:`DataFrame` constructors will now return a shallow copy\n  (i.e. share data, but not attributes) when passed a Series and DataFrame,\n  respectively, and with the default of ``copy=False`` (and if no other keyword triggers\n  a copy). Previously, the new Series or DataFrame would share the index attribute (e.g.\n  ``df.index = ...`` would also update the index of the parent or child) (:issue:`49523`)\n- Disallow computing ``cumprod`` for :class:`Timedelta` object; previously this returned incorrect values (:issue:`50246`)\n- :class:`DataFrame` objects read from a :class:`HDFStore` file without an index now have a :class:`RangeIndex` instead of an ``int64`` index (:issue:`51076`)\n- Instantiating an :class:`Index` with an numeric numpy dtype with data containing :class:`NA` and/or :class:`NaT` now raises a ``ValueError``. Previously a ``TypeError`` was raised (:issue:`51050`)\n- Loading a JSON file with duplicate columns using ``read_json(orient='split')`` renames columns to avoid duplicates, as :func:`read_csv` and the other readers do (:issue:`50370`)\n- The levels of the index of the :class:`Series` returned from ``Series.sparse.from_coo`` now always have dtype ``int32``. Previously they had dtype ``int64`` (:issue:`50926`)\n- :func:`to_datetime` with ``unit`` of either \"Y\" or \"M\" will now raise if a sequence contains a non-round ``float`` value, matching the ``Timestamp`` behavior (:issue:`50301`)\n- The methods :meth:`Series.round`, :meth:`DataFrame.__invert__`, :meth:`Series.__invert__`, :meth:`DataFrame.swapaxes`, :meth:`DataFrame.first`, :meth:`DataFrame.last`, :meth:`Series.first`, :meth:`Series.last` and :meth:`DataFrame.align` will now always return new objects (:issue:`51032`)\n- :class:`DataFrame` and :class:`DataFrameGroupBy` aggregations (e.g. \"sum\") with object-dtype columns no longer infer non-object dtypes for their results, explicitly call ``result.infer_objects(copy=False)`` on the result to obtain the old behavior (:issue:`51205`, :issue:`49603`)\n- Division by zero with :class:`ArrowDtype` dtypes returns ``-inf``, ``nan``, or ``inf`` depending on the numerator, instead of raising (:issue:`51541`)\n- Added :func:`pandas.api.types.is_any_real_numeric_dtype` to check for real numeric dtypes (:issue:`51152`)\n- :meth:`~arrays.ArrowExtensionArray.value_counts` now returns data with :class:`ArrowDtype` with ``pyarrow.int64`` type instead of ``\"Int64\"`` type (:issue:`51462`)\n- :func:`factorize` and :func:`unique` preserve the original dtype when passed numpy timedelta64 or datetime64 with non-nanosecond resolution (:issue:`48670`)\n\n.. note::\n\n    A current PDEP proposes the deprecation and removal of the keywords ``inplace`` and ``copy``\n    for all but a small subset of methods from the pandas API. The current discussion takes place\n    at `here <https://github.com/pandas-dev/pandas/pull/51466>`_. The keywords won't be necessary\n    anymore in the context of Copy-on-Write. If this proposal is accepted, both\n    keywords would be deprecated in the next release of pandas and removed in pandas 3.0.\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n- Deprecated parsing datetime strings with system-local timezone to ``tzlocal``, pass a ``tz`` keyword or explicitly call ``tz_localize`` instead (:issue:`50791`)\n- Deprecated argument ``infer_datetime_format`` in :func:`to_datetime` and :func:`read_csv`, as a strict version of it is now the default (:issue:`48621`)\n- Deprecated behavior of :func:`to_datetime` with ``unit`` when parsing strings, in a future version these will be parsed as datetimes (matching unit-less behavior) instead of cast to floats. To retain the old behavior, cast strings to numeric types before calling :func:`to_datetime` (:issue:`50735`)\n- Deprecated :func:`pandas.io.sql.execute` (:issue:`50185`)\n- :meth:`Index.is_boolean` has been deprecated. Use :func:`pandas.api.types.is_bool_dtype` instead (:issue:`50042`)\n- :meth:`Index.is_integer` has been deprecated. Use :func:`pandas.api.types.is_integer_dtype` instead (:issue:`50042`)\n- :meth:`Index.is_floating` has been deprecated. Use :func:`pandas.api.types.is_float_dtype` instead (:issue:`50042`)\n- :meth:`Index.holds_integer` has been deprecated. Use :func:`pandas.api.types.infer_dtype` instead (:issue:`50243`)\n- :meth:`Index.is_numeric` has been deprecated. Use :func:`pandas.api.types.is_any_real_numeric_dtype` instead (:issue:`50042`,:issue:`51152`)\n- :meth:`Index.is_categorical` has been deprecated. Use :func:`pandas.api.types.is_categorical_dtype` instead (:issue:`50042`)\n- :meth:`Index.is_object` has been deprecated. Use :func:`pandas.api.types.is_object_dtype` instead (:issue:`50042`)\n- :meth:`Index.is_interval` has been deprecated. Use :func:`pandas.api.types.is_interval_dtype` instead (:issue:`50042`)\n- Deprecated argument ``date_parser`` in :func:`read_csv`, :func:`read_table`, :func:`read_fwf`, and :func:`read_excel` in favour of ``date_format`` (:issue:`50601`)\n- Deprecated ``all`` and ``any`` reductions with ``datetime64`` and :class:`DatetimeTZDtype` dtypes, use e.g. ``(obj != pd.Timestamp(0), tz=obj.tz).all()`` instead (:issue:`34479`)\n- Deprecated unused arguments ``*args`` and ``**kwargs`` in :class:`Resampler` (:issue:`50977`)\n- Deprecated calling ``float`` or ``int`` on a single element :class:`Series` to return a ``float`` or ``int`` respectively. Extract the element before calling ``float`` or ``int`` instead (:issue:`51101`)\n- Deprecated :meth:`Grouper.groups`, use :meth:`Groupby.groups` instead (:issue:`51182`)\n- Deprecated :meth:`Grouper.grouper`, use :meth:`Groupby.grouper` instead (:issue:`51182`)\n- Deprecated :meth:`Grouper.obj`, use :meth:`Groupby.obj` instead (:issue:`51206`)\n- Deprecated :meth:`Grouper.indexer`, use :meth:`Resampler.indexer` instead (:issue:`51206`)\n- Deprecated :meth:`Grouper.ax`, use :meth:`Resampler.ax` instead (:issue:`51206`)\n- Deprecated keyword ``use_nullable_dtypes`` in :func:`read_parquet`, use ``dtype_backend`` instead (:issue:`51853`)\n- Deprecated :meth:`Series.pad` in favor of :meth:`Series.ffill` (:issue:`33396`)\n- Deprecated :meth:`Series.backfill` in favor of :meth:`Series.bfill` (:issue:`33396`)\n- Deprecated :meth:`DataFrame.pad` in favor of :meth:`DataFrame.ffill` (:issue:`33396`)\n- Deprecated :meth:`DataFrame.backfill` in favor of :meth:`DataFrame.bfill` (:issue:`33396`)\n- Deprecated :meth:`~pandas.io.stata.StataReader.close`. Use :class:`~pandas.io.stata.StataReader` as a context manager instead (:issue:`49228`)\n- Deprecated producing a scalar when iterating over a :class:`.DataFrameGroupBy` or a :class:`.SeriesGroupBy` that has been grouped by a ``level`` parameter that is a list of length 1; a tuple of length one will be returned instead (:issue:`51583`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.prior_deprecations:\n\nRemoval of prior version deprecations/changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n- Removed :class:`Int64Index`, :class:`UInt64Index` and :class:`Float64Index`. See also :ref:`here <whatsnew_200.enhancements.index_can_hold_numpy_numeric_dtypes>` for more information (:issue:`42717`)\n- Removed deprecated :attr:`Timestamp.freq`, :attr:`Timestamp.freqstr` and argument ``freq`` from the :class:`Timestamp` constructor and :meth:`Timestamp.fromordinal` (:issue:`14146`)\n- Removed deprecated :class:`CategoricalBlock`, :meth:`Block.is_categorical`, require datetime64 and timedelta64 values to be wrapped in :class:`DatetimeArray` or :class:`TimedeltaArray` before passing to :meth:`Block.make_block_same_class`, require ``DatetimeTZBlock.values`` to have the correct ndim when passing to the :class:`BlockManager` constructor, and removed the \"fastpath\" keyword from the :class:`SingleBlockManager` constructor (:issue:`40226`, :issue:`40571`)\n- Removed deprecated global option ``use_inf_as_null`` in favor of ``use_inf_as_na`` (:issue:`17126`)\n- Removed deprecated module ``pandas.core.index`` (:issue:`30193`)\n- Removed deprecated alias ``pandas.core.tools.datetimes.to_time``, import the function directly from ``pandas.core.tools.times`` instead (:issue:`34145`)\n- Removed deprecated alias ``pandas.io.json.json_normalize``, import the function directly from ``pandas.json_normalize`` instead (:issue:`27615`)\n- Removed deprecated :meth:`Categorical.to_dense`, use ``np.asarray(cat)`` instead (:issue:`32639`)\n- Removed deprecated :meth:`Categorical.take_nd` (:issue:`27745`)\n- Removed deprecated :meth:`Categorical.mode`, use ``Series(cat).mode()`` instead (:issue:`45033`)\n- Removed deprecated :meth:`Categorical.is_dtype_equal` and :meth:`CategoricalIndex.is_dtype_equal` (:issue:`37545`)\n- Removed deprecated :meth:`CategoricalIndex.take_nd` (:issue:`30702`)\n- Removed deprecated :meth:`Index.is_type_compatible` (:issue:`42113`)\n- Removed deprecated :meth:`Index.is_mixed`, check ``index.inferred_type`` directly instead (:issue:`32922`)\n- Removed deprecated :func:`pandas.api.types.is_categorical`; use :func:`pandas.api.types.is_categorical_dtype` instead  (:issue:`33385`)\n- Removed deprecated :meth:`Index.asi8` (:issue:`37877`)\n- Enforced deprecation changing behavior when passing ``datetime64[ns]`` dtype data and timezone-aware dtype to :class:`Series`, interpreting the values as wall-times instead of UTC times, matching :class:`DatetimeIndex` behavior (:issue:`41662`)\n- Enforced deprecation changing behavior when applying a numpy ufunc on multiple non-aligned (on the index or columns) :class:`DataFrame` that will now align the inputs first (:issue:`39239`)\n- Removed deprecated :meth:`DataFrame._AXIS_NUMBERS`, :meth:`DataFrame._AXIS_NAMES`, :meth:`Series._AXIS_NUMBERS`, :meth:`Series._AXIS_NAMES` (:issue:`33637`)\n- Removed deprecated :meth:`Index.to_native_types`, use ``obj.astype(str)`` instead (:issue:`36418`)\n- Removed deprecated :meth:`Series.iteritems`, :meth:`DataFrame.iteritems`, use ``obj.items`` instead (:issue:`45321`)\n- Removed deprecated :meth:`DataFrame.lookup` (:issue:`35224`)\n- Removed deprecated :meth:`Series.append`, :meth:`DataFrame.append`, use :func:`concat` instead (:issue:`35407`)\n- Removed deprecated :meth:`Series.iteritems`, :meth:`DataFrame.iteritems` and :meth:`HDFStore.iteritems` use ``obj.items`` instead (:issue:`45321`)\n- Removed deprecated :meth:`DatetimeIndex.union_many` (:issue:`45018`)\n- Removed deprecated ``weekofyear`` and ``week`` attributes of :class:`DatetimeArray`, :class:`DatetimeIndex` and ``dt`` accessor in favor of ``isocalendar().week`` (:issue:`33595`)\n- Removed deprecated :meth:`RangeIndex._start`, :meth:`RangeIndex._stop`, :meth:`RangeIndex._step`, use ``start``, ``stop``, ``step`` instead (:issue:`30482`)\n- Removed deprecated :meth:`DatetimeIndex.to_perioddelta`, Use ``dtindex - dtindex.to_period(freq).to_timestamp()`` instead (:issue:`34853`)\n- Removed deprecated :meth:`.Styler.hide_index` and :meth:`.Styler.hide_columns` (:issue:`49397`)\n- Removed deprecated :meth:`.Styler.set_na_rep` and :meth:`.Styler.set_precision` (:issue:`49397`)\n- Removed deprecated :meth:`.Styler.where` (:issue:`49397`)\n- Removed deprecated :meth:`.Styler.render` (:issue:`49397`)\n- Removed deprecated argument ``col_space`` in :meth:`DataFrame.to_latex` (:issue:`47970`)\n- Removed deprecated argument ``null_color`` in :meth:`.Styler.highlight_null` (:issue:`49397`)\n- Removed deprecated argument ``check_less_precise`` in :meth:`.testing.assert_frame_equal`, :meth:`.testing.assert_extension_array_equal`, :meth:`.testing.assert_series_equal`,  :meth:`.testing.assert_index_equal` (:issue:`30562`)\n- Removed deprecated ``null_counts`` argument in :meth:`DataFrame.info`. Use ``show_counts`` instead (:issue:`37999`)\n- Removed deprecated :meth:`Index.is_monotonic`, and :meth:`Series.is_monotonic`; use ``obj.is_monotonic_increasing`` instead (:issue:`45422`)\n- Removed deprecated :meth:`Index.is_all_dates` (:issue:`36697`)\n- Enforced deprecation disallowing passing a timezone-aware :class:`Timestamp` and ``dtype=\"datetime64[ns]\"`` to :class:`Series` or :class:`DataFrame` constructors (:issue:`41555`)\n- Enforced deprecation disallowing passing a sequence of timezone-aware values and ``dtype=\"datetime64[ns]\"`` to to :class:`Series` or :class:`DataFrame` constructors (:issue:`41555`)\n- Enforced deprecation disallowing ``numpy.ma.mrecords.MaskedRecords`` in the :class:`DataFrame` constructor; pass ``\"{name: data[name] for name in data.dtype.names}`` instead (:issue:`40363`)\n- Enforced deprecation disallowing unit-less \"datetime64\" dtype in :meth:`Series.astype` and :meth:`DataFrame.astype` (:issue:`47844`)\n- Enforced deprecation disallowing using ``.astype`` to convert a ``datetime64[ns]`` :class:`Series`, :class:`DataFrame`, or :class:`DatetimeIndex` to timezone-aware dtype, use ``obj.tz_localize`` or ``ser.dt.tz_localize`` instead (:issue:`39258`)\n- Enforced deprecation disallowing using ``.astype`` to convert a timezone-aware :class:`Series`, :class:`DataFrame`, or :class:`DatetimeIndex` to timezone-naive ``datetime64[ns]`` dtype, use ``obj.tz_localize(None)`` or ``obj.tz_convert(\"UTC\").tz_localize(None)`` instead (:issue:`39258`)\n- Enforced deprecation disallowing passing non boolean argument to sort in :func:`concat` (:issue:`44629`)\n- Removed Date parser functions :func:`~pandas.io.date_converters.parse_date_time`,\n  :func:`~pandas.io.date_converters.parse_date_fields`, :func:`~pandas.io.date_converters.parse_all_fields`\n  and :func:`~pandas.io.date_converters.generic_parser` (:issue:`24518`)\n- Removed argument ``index`` from the :class:`core.arrays.SparseArray` constructor (:issue:`43523`)\n- Remove argument ``squeeze`` from :meth:`DataFrame.groupby` and :meth:`Series.groupby` (:issue:`32380`)\n- Removed deprecated ``apply``, ``apply_index``, ``__call__``, ``onOffset``, and ``isAnchored`` attributes from :class:`DateOffset` (:issue:`34171`)\n- Removed ``keep_tz`` argument in :meth:`DatetimeIndex.to_series` (:issue:`29731`)\n- Remove arguments ``names`` and ``dtype`` from :meth:`Index.copy` and ``levels`` and ``codes`` from :meth:`MultiIndex.copy` (:issue:`35853`, :issue:`36685`)\n- Remove argument ``inplace`` from :meth:`MultiIndex.set_levels` and :meth:`MultiIndex.set_codes` (:issue:`35626`)\n- Removed arguments ``verbose`` and ``encoding`` from :meth:`DataFrame.to_excel` and :meth:`Series.to_excel` (:issue:`47912`)\n- Removed argument ``line_terminator`` from :meth:`DataFrame.to_csv` and :meth:`Series.to_csv`, use ``lineterminator`` instead (:issue:`45302`)\n- Removed argument ``inplace`` from :meth:`DataFrame.set_axis` and :meth:`Series.set_axis`, use ``obj = obj.set_axis(..., copy=False)`` instead (:issue:`48130`)\n- Disallow passing positional arguments to :meth:`MultiIndex.set_levels` and :meth:`MultiIndex.set_codes` (:issue:`41485`)\n- Disallow parsing to Timedelta strings with components with units \"Y\", \"y\", or \"M\", as these do not represent unambiguous durations (:issue:`36838`)\n- Removed :meth:`MultiIndex.is_lexsorted` and :meth:`MultiIndex.lexsort_depth` (:issue:`38701`)\n- Removed argument ``how`` from :meth:`PeriodIndex.astype`, use :meth:`PeriodIndex.to_timestamp` instead (:issue:`37982`)\n- Removed argument ``try_cast`` from :meth:`DataFrame.mask`, :meth:`DataFrame.where`, :meth:`Series.mask` and :meth:`Series.where` (:issue:`38836`)\n- Removed argument ``tz`` from :meth:`Period.to_timestamp`, use ``obj.to_timestamp(...).tz_localize(tz)`` instead (:issue:`34522`)\n- Removed argument ``sort_columns`` in :meth:`DataFrame.plot` and :meth:`Series.plot` (:issue:`47563`)\n- Removed argument ``is_copy`` from :meth:`DataFrame.take` and :meth:`Series.take` (:issue:`30615`)\n- Removed argument ``kind`` from :meth:`Index.get_slice_bound`, :meth:`Index.slice_indexer` and :meth:`Index.slice_locs` (:issue:`41378`)\n- Removed arguments ``prefix``, ``squeeze``, ``error_bad_lines`` and ``warn_bad_lines`` from :func:`read_csv` (:issue:`40413`, :issue:`43427`)\n- Removed arguments ``squeeze`` from :func:`read_excel` (:issue:`43427`)\n- Removed argument ``datetime_is_numeric`` from :meth:`DataFrame.describe` and :meth:`Series.describe` as datetime data will always be summarized as numeric data (:issue:`34798`)\n- Disallow passing list ``key`` to :meth:`Series.xs` and :meth:`DataFrame.xs`, pass a tuple instead (:issue:`41789`)\n- Disallow subclass-specific keywords (e.g. \"freq\", \"tz\", \"names\", \"closed\") in the :class:`Index` constructor (:issue:`38597`)\n- Removed argument ``inplace`` from :meth:`Categorical.remove_unused_categories` (:issue:`37918`)\n- Disallow passing non-round floats to :class:`Timestamp` with ``unit=\"M\"`` or ``unit=\"Y\"`` (:issue:`47266`)\n- Remove keywords ``convert_float`` and ``mangle_dupe_cols`` from :func:`read_excel` (:issue:`41176`)\n- Remove keyword ``mangle_dupe_cols`` from :func:`read_csv` and :func:`read_table` (:issue:`48137`)\n- Removed ``errors`` keyword from :meth:`DataFrame.where`, :meth:`Series.where`, :meth:`DataFrame.mask` and :meth:`Series.mask` (:issue:`47728`)\n- Disallow passing non-keyword arguments to :func:`read_excel` except ``io`` and ``sheet_name`` (:issue:`34418`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.drop` and :meth:`Series.drop` except ``labels`` (:issue:`41486`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.fillna` and :meth:`Series.fillna` except ``value`` (:issue:`41485`)\n- Disallow passing non-keyword arguments to :meth:`StringMethods.split` and :meth:`StringMethods.rsplit` except for ``pat`` (:issue:`47448`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.set_index` except ``keys`` (:issue:`41495`)\n- Disallow passing non-keyword arguments to :meth:`Resampler.interpolate` except ``method`` (:issue:`41699`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.reset_index` and :meth:`Series.reset_index` except ``level`` (:issue:`41496`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.dropna` and :meth:`Series.dropna` (:issue:`41504`)\n- Disallow passing non-keyword arguments to :meth:`ExtensionArray.argsort` (:issue:`46134`)\n- Disallow passing non-keyword arguments to :meth:`Categorical.sort_values` (:issue:`47618`)\n- Disallow passing non-keyword arguments to :meth:`Index.drop_duplicates` and :meth:`Series.drop_duplicates` (:issue:`41485`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.drop_duplicates` except for ``subset`` (:issue:`41485`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.sort_index` and :meth:`Series.sort_index` (:issue:`41506`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.interpolate` and :meth:`Series.interpolate` except for ``method`` (:issue:`41510`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.any` and :meth:`Series.any` (:issue:`44896`)\n- Disallow passing non-keyword arguments to :meth:`Index.set_names` except for ``names`` (:issue:`41551`)\n- Disallow passing non-keyword arguments to :meth:`Index.join` except for ``other`` (:issue:`46518`)\n- Disallow passing non-keyword arguments to :func:`concat` except for ``objs`` (:issue:`41485`)\n- Disallow passing non-keyword arguments to :func:`pivot` except for ``data`` (:issue:`48301`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.pivot` (:issue:`48301`)\n- Disallow passing non-keyword arguments to :func:`read_html` except for ``io`` (:issue:`27573`)\n- Disallow passing non-keyword arguments to :func:`read_json` except for ``path_or_buf`` (:issue:`27573`)\n- Disallow passing non-keyword arguments to :func:`read_sas` except for ``filepath_or_buffer`` (:issue:`47154`)\n- Disallow passing non-keyword arguments to :func:`read_stata` except for ``filepath_or_buffer`` (:issue:`48128`)\n- Disallow passing non-keyword arguments to :func:`read_csv` except ``filepath_or_buffer`` (:issue:`41485`)\n- Disallow passing non-keyword arguments to :func:`read_table` except ``filepath_or_buffer`` (:issue:`41485`)\n- Disallow passing non-keyword arguments to :func:`read_fwf` except ``filepath_or_buffer`` (:issue:`44710`)\n- Disallow passing non-keyword arguments to :func:`read_xml` except for ``path_or_buffer`` (:issue:`45133`)\n- Disallow passing non-keyword arguments to :meth:`Series.mask` and :meth:`DataFrame.mask` except ``cond`` and ``other`` (:issue:`41580`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.to_stata` except for ``path`` (:issue:`48128`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.where` and :meth:`Series.where` except for ``cond`` and ``other`` (:issue:`41523`)\n- Disallow passing non-keyword arguments to :meth:`Series.set_axis` and :meth:`DataFrame.set_axis` except for ``labels`` (:issue:`41491`)\n- Disallow passing non-keyword arguments to :meth:`Series.rename_axis` and :meth:`DataFrame.rename_axis` except for ``mapper`` (:issue:`47587`)\n- Disallow passing non-keyword arguments to :meth:`Series.clip` and :meth:`DataFrame.clip` except ``lower`` and ``upper`` (:issue:`41511`)\n- Disallow passing non-keyword arguments to :meth:`Series.bfill`, :meth:`Series.ffill`, :meth:`DataFrame.bfill` and :meth:`DataFrame.ffill` (:issue:`41508`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.replace`, :meth:`Series.replace` except for ``to_replace`` and ``value`` (:issue:`47587`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.sort_values` except for ``by`` (:issue:`41505`)\n- Disallow passing non-keyword arguments to :meth:`Series.sort_values` (:issue:`41505`)\n- Disallow passing non-keyword arguments to :meth:`DataFrame.reindex` except for ``labels`` (:issue:`17966`)\n- Disallow :meth:`Index.reindex` with non-unique :class:`Index` objects (:issue:`42568`)\n- Disallowed constructing :class:`Categorical` with scalar ``data`` (:issue:`38433`)\n- Disallowed constructing :class:`CategoricalIndex` without passing ``data`` (:issue:`38944`)\n- Removed :meth:`.Rolling.validate`, :meth:`.Expanding.validate`, and :meth:`.ExponentialMovingWindow.validate` (:issue:`43665`)\n- Removed :attr:`Rolling.win_type` returning ``\"freq\"`` (:issue:`38963`)\n- Removed :attr:`Rolling.is_datetimelike` (:issue:`38963`)\n- Removed the ``level`` keyword in :class:`DataFrame` and :class:`Series` aggregations; use ``groupby`` instead (:issue:`39983`)\n- Removed deprecated :meth:`Timedelta.delta`, :meth:`Timedelta.is_populated`, and :attr:`Timedelta.freq` (:issue:`46430`, :issue:`46476`)\n- Removed deprecated :attr:`NaT.freq` (:issue:`45071`)\n- Removed deprecated :meth:`Categorical.replace`, use :meth:`Series.replace` instead (:issue:`44929`)\n- Removed the ``numeric_only`` keyword from :meth:`Categorical.min` and :meth:`Categorical.max` in favor of ``skipna`` (:issue:`48821`)\n- Changed behavior of :meth:`DataFrame.median` and :meth:`DataFrame.mean` with ``numeric_only=None`` to not exclude datetime-like columns THIS NOTE WILL BE IRRELEVANT ONCE ``numeric_only=None`` DEPRECATION IS ENFORCED (:issue:`29941`)\n- Removed :func:`is_extension_type` in favor of :func:`is_extension_array_dtype` (:issue:`29457`)\n- Removed ``.ExponentialMovingWindow.vol`` (:issue:`39220`)\n- Removed :meth:`Index.get_value` and :meth:`Index.set_value` (:issue:`33907`, :issue:`28621`)\n- Removed :meth:`Series.slice_shift` and :meth:`DataFrame.slice_shift` (:issue:`37601`)\n- Remove :meth:`DataFrameGroupBy.pad` and :meth:`DataFrameGroupBy.backfill` (:issue:`45076`)\n- Remove ``numpy`` argument from :func:`read_json` (:issue:`30636`)\n- Disallow passing abbreviations for ``orient`` in :meth:`DataFrame.to_dict` (:issue:`32516`)\n- Disallow partial slicing on an non-monotonic :class:`DatetimeIndex` with keys which are not in Index. This now raises a ``KeyError`` (:issue:`18531`)\n- Removed ``get_offset`` in favor of :func:`to_offset` (:issue:`30340`)\n- Removed the ``warn`` keyword in :func:`infer_freq` (:issue:`45947`)\n- Removed the ``include_start`` and ``include_end`` arguments in :meth:`DataFrame.between_time` in favor of ``inclusive`` (:issue:`43248`)\n- Removed the ``closed`` argument in :meth:`date_range` and :meth:`bdate_range` in favor of ``inclusive`` argument (:issue:`40245`)\n- Removed the ``center`` keyword in :meth:`DataFrame.expanding` (:issue:`20647`)\n- Removed the ``truediv`` keyword from :func:`eval` (:issue:`29812`)\n- Removed the ``method`` and ``tolerance`` arguments in :meth:`Index.get_loc`. Use ``index.get_indexer([label], method=..., tolerance=...)`` instead (:issue:`42269`)\n- Removed the ``pandas.datetime`` submodule (:issue:`30489`)\n- Removed the ``pandas.np`` submodule (:issue:`30296`)\n- Removed ``pandas.util.testing`` in favor of ``pandas.testing`` (:issue:`30745`)\n- Removed :meth:`Series.str.__iter__` (:issue:`28277`)\n- Removed ``pandas.SparseArray`` in favor of :class:`arrays.SparseArray` (:issue:`30642`)\n- Removed ``pandas.SparseSeries`` and ``pandas.SparseDataFrame``, including pickle support. (:issue:`30642`)\n- Enforced disallowing passing an integer ``fill_value`` to :meth:`DataFrame.shift` and :meth:`Series.shift`` with datetime64, timedelta64, or period dtypes (:issue:`32591`)\n- Enforced disallowing a string column label into ``times`` in :meth:`DataFrame.ewm` (:issue:`43265`)\n- Enforced disallowing passing ``True`` and ``False`` into ``inclusive`` in :meth:`Series.between` in favor of ``\"both\"`` and ``\"neither\"`` respectively (:issue:`40628`)\n- Enforced disallowing using ``usecols`` with out of bounds indices for ``read_csv`` with ``engine=\"c\"`` (:issue:`25623`)\n- Enforced disallowing the use of ``**kwargs`` in :class:`.ExcelWriter`; use the keyword argument ``engine_kwargs`` instead (:issue:`40430`)\n- Enforced disallowing a tuple of column labels into :meth:`.DataFrameGroupBy.__getitem__` (:issue:`30546`)\n- Enforced disallowing missing labels when indexing with a sequence of labels on a level of a :class:`MultiIndex`. This now raises a ``KeyError`` (:issue:`42351`)\n- Enforced disallowing setting values with ``.loc`` using a positional slice. Use ``.loc`` with labels or ``.iloc`` with positions instead (:issue:`31840`)\n- Enforced disallowing positional indexing with a ``float`` key even if that key is a round number, manually cast to integer instead (:issue:`34193`)\n- Enforced disallowing using a :class:`DataFrame` indexer with ``.iloc``, use ``.loc`` instead for automatic alignment (:issue:`39022`)\n- Enforced disallowing ``set`` or ``dict`` indexers in ``__getitem__`` and ``__setitem__`` methods (:issue:`42825`)\n- Enforced disallowing indexing on a :class:`Index` or positional indexing on a :class:`Series` producing multi-dimensional objects e.g. ``obj[:, None]``, convert to numpy before indexing instead (:issue:`35141`)\n- Enforced disallowing ``dict`` or ``set`` objects in ``suffixes`` in :func:`merge` (:issue:`34810`)\n- Enforced disallowing :func:`merge` to produce duplicated columns through the ``suffixes`` keyword and already existing columns (:issue:`22818`)\n- Enforced disallowing using :func:`merge` or :func:`join` on a different number of levels (:issue:`34862`)\n- Enforced disallowing ``value_name`` argument in :func:`DataFrame.melt` to match an element in the :class:`DataFrame` columns (:issue:`35003`)\n- Enforced disallowing passing ``showindex`` into ``**kwargs`` in :func:`DataFrame.to_markdown` and :func:`Series.to_markdown` in favor of ``index`` (:issue:`33091`)\n- Removed setting Categorical._codes directly (:issue:`41429`)\n- Removed setting Categorical.categories directly (:issue:`47834`)\n- Removed argument ``inplace`` from :meth:`Categorical.add_categories`, :meth:`Categorical.remove_categories`, :meth:`Categorical.set_categories`, :meth:`Categorical.rename_categories`, :meth:`Categorical.reorder_categories`, :meth:`Categorical.set_ordered`, :meth:`Categorical.as_ordered`, :meth:`Categorical.as_unordered` (:issue:`37981`, :issue:`41118`, :issue:`41133`, :issue:`47834`)\n- Enforced :meth:`Rolling.count` with ``min_periods=None`` to default to the size of the window (:issue:`31302`)\n- Renamed ``fname`` to ``path`` in :meth:`DataFrame.to_parquet`, :meth:`DataFrame.to_stata` and :meth:`DataFrame.to_feather` (:issue:`30338`)\n- Enforced disallowing indexing a :class:`Series` with a single item list with a slice (e.g. ``ser[[slice(0, 2)]]``). Either convert the list to tuple, or pass the slice directly instead (:issue:`31333`)\n- Changed behavior indexing on a :class:`DataFrame` with a :class:`DatetimeIndex` index using a string indexer, previously this operated as a slice on rows, now it operates like any other column key; use ``frame.loc[key]`` for the old behavior (:issue:`36179`)\n- Enforced the ``display.max_colwidth`` option to not accept negative integers (:issue:`31569`)\n- Removed the ``display.column_space`` option in favor of ``df.to_string(col_space=...)`` (:issue:`47280`)\n- Removed the deprecated method ``mad`` from pandas classes (:issue:`11787`)\n- Removed the deprecated method ``tshift`` from pandas classes (:issue:`11631`)\n- Changed behavior of empty data passed into :class:`Series`; the default dtype will be ``object`` instead of ``float64`` (:issue:`29405`)\n- Changed the behavior of :meth:`DatetimeIndex.union`, :meth:`DatetimeIndex.intersection`, and :meth:`DatetimeIndex.symmetric_difference` with mismatched timezones to convert to UTC instead of casting to object dtype (:issue:`39328`)\n- Changed the behavior of :func:`to_datetime` with argument \"now\" with ``utc=False`` to match ``Timestamp(\"now\")`` (:issue:`18705`)\n- Changed the behavior of indexing on a timezone-aware :class:`DatetimeIndex` with a timezone-naive ``datetime`` object or vice-versa; these now behave like any other non-comparable type by raising ``KeyError`` (:issue:`36148`)\n- Changed the behavior of :meth:`Index.reindex`, :meth:`Series.reindex`, and :meth:`DataFrame.reindex` with a ``datetime64`` dtype and a ``datetime.date`` object for ``fill_value``; these are no longer considered equivalent to ``datetime.datetime`` objects so the reindex casts to object dtype (:issue:`39767`)\n- Changed behavior of :meth:`SparseArray.astype` when given a dtype that is not explicitly ``SparseDtype``, cast to the exact requested dtype rather than silently using a ``SparseDtype`` instead (:issue:`34457`)\n- Changed behavior of :meth:`Index.ravel` to return a view on the original :class:`Index` instead of a ``np.ndarray`` (:issue:`36900`)\n- Changed behavior of :meth:`Series.to_frame` and :meth:`Index.to_frame` with explicit ``name=None`` to use ``None`` for the column name instead of the index's name or default ``0`` (:issue:`45523`)\n- Changed behavior of :func:`concat` with one array of ``bool``-dtype and another of integer dtype, this now returns ``object`` dtype instead of integer dtype; explicitly cast the bool object to integer before concatenating to get the old behavior (:issue:`45101`)\n- Changed behavior of :class:`DataFrame` constructor given floating-point ``data`` and an integer ``dtype``, when the data cannot be cast losslessly, the floating point dtype is retained, matching :class:`Series` behavior (:issue:`41170`)\n- Changed behavior of :class:`Index` constructor when given a ``np.ndarray`` with object-dtype containing numeric entries; this now retains object dtype rather than inferring a numeric dtype, consistent with :class:`Series` behavior (:issue:`42870`)\n- Changed behavior of :meth:`Index.__and__`, :meth:`Index.__or__` and :meth:`Index.__xor__` to behave as logical operations (matching :class:`Series` behavior) instead of aliases for set operations (:issue:`37374`)\n- Changed behavior of :class:`DataFrame` constructor when passed a list whose first element is a :class:`Categorical`, this now treats the elements as rows casting to ``object`` dtype, consistent with behavior for other types (:issue:`38845`)\n- Changed behavior of :class:`DataFrame` constructor when passed a ``dtype`` (other than int) that the data cannot be cast to; it now raises instead of silently ignoring the dtype (:issue:`41733`)\n- Changed the behavior of :class:`Series` constructor, it will no longer infer a datetime64 or timedelta64 dtype from string entries (:issue:`41731`)\n- Changed behavior of :class:`Timestamp` constructor with a ``np.datetime64`` object and a ``tz`` passed to interpret the input as a wall-time as opposed to a UTC time (:issue:`42288`)\n- Changed behavior of :meth:`Timestamp.utcfromtimestamp` to return a timezone-aware object satisfying ``Timestamp.utcfromtimestamp(val).timestamp() == val`` (:issue:`45083`)\n- Changed behavior of :class:`Index` constructor when passed a ``SparseArray`` or ``SparseDtype`` to retain that dtype instead of casting to ``numpy.ndarray`` (:issue:`43930`)\n- Changed behavior of setitem-like operations (``__setitem__``, ``fillna``, ``where``, ``mask``, ``replace``, ``insert``, fill_value for ``shift``) on an object with :class:`DatetimeTZDtype` when using a value with a non-matching timezone, the value will be cast to the object's timezone instead of casting both to object-dtype (:issue:`44243`)\n- Changed behavior of :class:`Index`, :class:`Series`, :class:`DataFrame` constructors with floating-dtype data and a :class:`DatetimeTZDtype`, the data are now interpreted as UTC-times instead of wall-times, consistent with how integer-dtype data are treated (:issue:`45573`)\n- Changed behavior of :class:`Series` and :class:`DataFrame` constructors with integer dtype and floating-point data containing ``NaN``, this now raises ``IntCastingNaNError`` (:issue:`40110`)\n- Changed behavior of :class:`Series` and :class:`DataFrame` constructors with an integer ``dtype`` and values that are too large to losslessly cast to this dtype, this now raises ``ValueError`` (:issue:`41734`)\n- Changed behavior of :class:`Series` and :class:`DataFrame` constructors with an integer ``dtype`` and values having either ``datetime64`` or ``timedelta64`` dtypes, this now raises ``TypeError``, use ``values.view(\"int64\")`` instead (:issue:`41770`)\n- Removed the deprecated ``base`` and ``loffset`` arguments from :meth:`pandas.DataFrame.resample`, :meth:`pandas.Series.resample` and :class:`pandas.Grouper`. Use ``offset`` or ``origin`` instead (:issue:`31809`)\n- Changed behavior of :meth:`Series.fillna` and :meth:`DataFrame.fillna` with ``timedelta64[ns]`` dtype and an incompatible ``fill_value``; this now casts to ``object`` dtype instead of raising, consistent with the behavior with other dtypes (:issue:`45746`)\n- Change the default argument of ``regex`` for :meth:`Series.str.replace` from ``True`` to ``False``. Additionally, a single character ``pat`` with ``regex=True`` is now treated as a regular expression instead of a string literal. (:issue:`36695`, :issue:`24804`)\n- Changed behavior of :meth:`DataFrame.any` and :meth:`DataFrame.all` with ``bool_only=True``; object-dtype columns with all-bool values will no longer be included, manually cast to ``bool`` dtype first (:issue:`46188`)\n- Changed behavior of :meth:`DataFrame.max`, :class:`DataFrame.min`, :class:`DataFrame.mean`, :class:`DataFrame.median`, :class:`DataFrame.skew`, :class:`DataFrame.kurt` with ``axis=None`` to return a scalar applying the aggregation across both axes (:issue:`45072`)\n- Changed behavior of comparison of a :class:`Timestamp` with a ``datetime.date`` object; these now compare as un-equal and raise on inequality comparisons, matching the ``datetime.datetime`` behavior (:issue:`36131`)\n- Changed behavior of comparison of ``NaT`` with a ``datetime.date`` object; these now raise on inequality comparisons (:issue:`39196`)\n- Enforced deprecation of silently dropping columns that raised a ``TypeError`` in :class:`Series.transform` and :class:`DataFrame.transform` when used with a list or dictionary (:issue:`43740`)\n- Changed behavior of :meth:`DataFrame.apply` with list-like so that any partial failure will raise an error (:issue:`43740`)\n- Changed behaviour of :meth:`DataFrame.to_latex` to now use the Styler implementation via :meth:`.Styler.to_latex` (:issue:`47970`)\n- Changed behavior of :meth:`Series.__setitem__` with an integer key and a :class:`Float64Index` when the key is not present in the index; previously we treated the key as positional (behaving like ``series.iloc[key] = val``), now we treat it is a label (behaving like ``series.loc[key] = val``), consistent with :meth:`Series.__getitem__`` behavior (:issue:`33469`)\n- Removed ``na_sentinel`` argument from :func:`factorize`, :meth:`.Index.factorize`, and :meth:`.ExtensionArray.factorize` (:issue:`47157`)\n- Changed behavior of :meth:`Series.diff` and :meth:`DataFrame.diff` with :class:`ExtensionDtype` dtypes whose arrays do not implement ``diff``, these now raise ``TypeError`` rather than casting to numpy (:issue:`31025`)\n- Enforced deprecation of calling numpy \"ufunc\"s on :class:`DataFrame` with ``method=\"outer\"``; this now raises ``NotImplementedError`` (:issue:`36955`)\n- Enforced deprecation disallowing passing ``numeric_only=True`` to :class:`Series` reductions (``rank``, ``any``, ``all``, ...) with non-numeric dtype (:issue:`47500`)\n- Changed behavior of :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` so that ``group_keys`` is respected even if a transformer is detected (:issue:`34998`)\n- Comparisons between a :class:`DataFrame` and a :class:`Series` where the frame's columns do not match the series's index raise ``ValueError`` instead of automatically aligning, do ``left, right = left.align(right, axis=1, copy=False)`` before comparing (:issue:`36795`)\n- Enforced deprecation ``numeric_only=None`` (the default) in DataFrame reductions that would silently drop columns that raised; ``numeric_only`` now defaults to ``False`` (:issue:`41480`)\n- Changed default of ``numeric_only`` to ``False`` in all DataFrame methods with that argument (:issue:`46096`, :issue:`46906`)\n- Changed default of ``numeric_only`` to ``False`` in :meth:`Series.rank` (:issue:`47561`)\n- Enforced deprecation of silently dropping nuisance columns in groupby and resample operations when ``numeric_only=False`` (:issue:`41475`)\n- Enforced deprecation of silently dropping nuisance columns in :class:`Rolling`, :class:`Expanding`, and :class:`ExponentialMovingWindow` ops. This will now raise a :class:`.errors.DataError` (:issue:`42834`)\n- Changed behavior in setting values with ``df.loc[:, foo] = bar`` or ``df.iloc[:, foo] = bar``, these now always attempt to set values inplace before falling back to casting (:issue:`45333`)\n- Changed default of ``numeric_only`` in various :class:`.DataFrameGroupBy` methods; all methods now default to ``numeric_only=False`` (:issue:`46072`)\n- Changed default of ``numeric_only`` to ``False`` in :class:`.Resampler` methods (:issue:`47177`)\n- Using the method :meth:`.DataFrameGroupBy.transform` with a callable that returns DataFrames will align to the input's index (:issue:`47244`)\n- When providing a list of columns of length one to :meth:`DataFrame.groupby`, the keys that are returned by iterating over the resulting :class:`DataFrameGroupBy` object will now be tuples of length one (:issue:`47761`)\n- Removed deprecated methods :meth:`ExcelWriter.write_cells`, :meth:`ExcelWriter.save`, :meth:`ExcelWriter.cur_sheet`, :meth:`ExcelWriter.handles`, :meth:`ExcelWriter.path` (:issue:`45795`)\n- The :class:`ExcelWriter` attribute ``book`` can no longer be set; it is still available to be accessed and mutated (:issue:`48943`)\n- Removed unused ``*args`` and ``**kwargs`` in :class:`Rolling`, :class:`Expanding`, and :class:`ExponentialMovingWindow` ops (:issue:`47851`)\n- Removed the deprecated argument ``line_terminator`` from :meth:`DataFrame.to_csv` (:issue:`45302`)\n- Removed the deprecated argument ``label`` from :func:`lreshape` (:issue:`30219`)\n- Arguments after ``expr`` in :meth:`DataFrame.eval` and :meth:`DataFrame.query` are keyword-only (:issue:`47587`)\n- Removed :meth:`Index._get_attributes_dict` (:issue:`50648`)\n- Removed :meth:`Series.__array_wrap__` (:issue:`50648`)\n- Changed behavior of :meth:`.DataFrame.value_counts` to return a :class:`Series` with :class:`MultiIndex` for any list-like(one element or not) but an :class:`Index` for a single label (:issue:`50829`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- Performance improvement in :meth:`.DataFrameGroupBy.median` and :meth:`.SeriesGroupBy.median` and :meth:`.DataFrameGroupBy.cumprod` for nullable dtypes (:issue:`37493`)\n- Performance improvement in :meth:`.DataFrameGroupBy.all`, :meth:`.DataFrameGroupBy.any`, :meth:`.SeriesGroupBy.all`, and :meth:`.SeriesGroupBy.any` for object dtype (:issue:`50623`)\n- Performance improvement in :meth:`MultiIndex.argsort` and :meth:`MultiIndex.sort_values` (:issue:`48406`)\n- Performance improvement in :meth:`MultiIndex.size` (:issue:`48723`)\n- Performance improvement in :meth:`MultiIndex.union` without missing values and without duplicates (:issue:`48505`, :issue:`48752`)\n- Performance improvement in :meth:`MultiIndex.difference` (:issue:`48606`)\n- Performance improvement in :class:`MultiIndex` set operations with sort=None (:issue:`49010`)\n- Performance improvement in :meth:`.DataFrameGroupBy.mean`, :meth:`.SeriesGroupBy.mean`, :meth:`.DataFrameGroupBy.var`, and :meth:`.SeriesGroupBy.var` for extension array dtypes (:issue:`37493`)\n- Performance improvement in :meth:`MultiIndex.isin` when ``level=None`` (:issue:`48622`, :issue:`49577`)\n- Performance improvement in :meth:`MultiIndex.putmask` (:issue:`49830`)\n- Performance improvement in :meth:`Index.union` and :meth:`MultiIndex.union` when index contains duplicates (:issue:`48900`)\n- Performance improvement in :meth:`Series.rank` for pyarrow-backed dtypes (:issue:`50264`)\n- Performance improvement in :meth:`Series.searchsorted` for pyarrow-backed dtypes (:issue:`50447`)\n- Performance improvement in :meth:`Series.fillna` for extension array dtypes (:issue:`49722`, :issue:`50078`)\n- Performance improvement in :meth:`Index.join`, :meth:`Index.intersection` and :meth:`Index.union` for masked and arrow dtypes when :class:`Index` is monotonic (:issue:`50310`, :issue:`51365`)\n- Performance improvement for :meth:`Series.value_counts` with nullable dtype (:issue:`48338`)\n- Performance improvement for :class:`Series` constructor passing integer numpy array with nullable dtype (:issue:`48338`)\n- Performance improvement for :class:`DatetimeIndex` constructor passing a list (:issue:`48609`)\n- Performance improvement in :func:`merge` and :meth:`DataFrame.join` when joining on a sorted :class:`MultiIndex` (:issue:`48504`)\n- Performance improvement in :func:`to_datetime` when parsing strings with timezone offsets (:issue:`50107`)\n- Performance improvement in :meth:`DataFrame.loc` and :meth:`Series.loc` for tuple-based indexing of a :class:`MultiIndex` (:issue:`48384`)\n- Performance improvement for :meth:`Series.replace` with categorical dtype (:issue:`49404`)\n- Performance improvement for :meth:`MultiIndex.unique` (:issue:`48335`)\n- Performance improvement for indexing operations with nullable and arrow dtypes (:issue:`49420`, :issue:`51316`)\n- Performance improvement for :func:`concat` with extension array backed indexes (:issue:`49128`, :issue:`49178`)\n- Performance improvement for :func:`api.types.infer_dtype` (:issue:`51054`)\n- Reduce memory usage of :meth:`DataFrame.to_pickle`/:meth:`Series.to_pickle` when using BZ2 or LZMA (:issue:`49068`)\n- Performance improvement for :class:`~arrays.StringArray` constructor passing a numpy array with type ``np.str_`` (:issue:`49109`)\n- Performance improvement in :meth:`~arrays.IntervalArray.from_tuples` (:issue:`50620`)\n- Performance improvement in :meth:`~arrays.ArrowExtensionArray.factorize` (:issue:`49177`)\n- Performance improvement in :meth:`~arrays.ArrowExtensionArray.__setitem__` (:issue:`50248`, :issue:`50632`)\n- Performance improvement in :class:`~arrays.ArrowExtensionArray` comparison methods when array contains NA (:issue:`50524`)\n- Performance improvement in :meth:`~arrays.ArrowExtensionArray.to_numpy` (:issue:`49973`, :issue:`51227`)\n- Performance improvement when parsing strings to :class:`BooleanDtype` (:issue:`50613`)\n- Performance improvement in :meth:`DataFrame.join` when joining on a subset of a :class:`MultiIndex` (:issue:`48611`)\n- Performance improvement for :meth:`MultiIndex.intersection` (:issue:`48604`)\n- Performance improvement in :meth:`DataFrame.__setitem__` (:issue:`46267`)\n- Performance improvement in ``var`` and ``std`` for nullable dtypes (:issue:`48379`).\n- Performance improvement when iterating over pyarrow and nullable dtypes (:issue:`49825`, :issue:`49851`)\n- Performance improvements to :func:`read_sas` (:issue:`47403`, :issue:`47405`, :issue:`47656`, :issue:`48502`)\n- Memory improvement in :meth:`RangeIndex.sort_values` (:issue:`48801`)\n- Performance improvement in :meth:`Series.to_numpy` if ``copy=True`` by avoiding copying twice (:issue:`24345`)\n- Performance improvement in :meth:`Series.rename` with :class:`MultiIndex` (:issue:`21055`)\n- Performance improvement in :class:`DataFrameGroupBy` and :class:`SeriesGroupBy` when ``by`` is a categorical type and ``sort=False`` (:issue:`48976`)\n- Performance improvement in :class:`DataFrameGroupBy` and :class:`SeriesGroupBy` when ``by`` is a categorical type and ``observed=False`` (:issue:`49596`)\n- Performance improvement in :func:`read_stata` with parameter ``index_col`` set to ``None`` (the default). Now the index will be a :class:`RangeIndex` instead of :class:`Int64Index` (:issue:`49745`)\n- Performance improvement in :func:`merge` when not merging on the index - the new index will now be :class:`RangeIndex` instead of :class:`Int64Index` (:issue:`49478`)\n- Performance improvement in :meth:`DataFrame.to_dict` and :meth:`Series.to_dict` when using any non-object dtypes (:issue:`46470`)\n- Performance improvement in :func:`read_html` when there are multiple tables (:issue:`49929`)\n- Performance improvement in :class:`Period` constructor when constructing from a string or integer (:issue:`38312`)\n- Performance improvement in :func:`to_datetime` when using ``'%Y%m%d'`` format (:issue:`17410`)\n- Performance improvement in :func:`to_datetime` when format is given or can be inferred (:issue:`50465`)\n- Performance improvement in :meth:`Series.median` for nullable dtypes (:issue:`50838`)\n- Performance improvement in :func:`read_csv` when passing :func:`to_datetime` lambda-function to ``date_parser`` and inputs have mixed timezone offsetes (:issue:`35296`)\n- Performance improvement in :func:`isna` and :func:`isnull` (:issue:`50658`)\n- Performance improvement in :meth:`.SeriesGroupBy.value_counts` with categorical dtype (:issue:`46202`)\n- Fixed a reference leak in :func:`read_hdf` (:issue:`37441`)\n- Fixed a memory leak in :meth:`DataFrame.to_json` and :meth:`Series.to_json` when serializing datetimes and timedeltas (:issue:`40443`)\n- Decreased memory usage in many :class:`DataFrameGroupBy` methods (:issue:`51090`)\n- Performance improvement in :meth:`DataFrame.round` for an integer ``decimal`` parameter (:issue:`17254`)\n- Performance improvement in :meth:`DataFrame.replace` and :meth:`Series.replace` when using a large dict for ``to_replace`` (:issue:`6697`)\n- Memory improvement in :class:`StataReader` when reading seekable files (:issue:`48922`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n- Bug in :meth:`Categorical.set_categories` losing dtype information (:issue:`48812`)\n- Bug in :meth:`Series.replace` with categorical dtype when ``to_replace`` values overlap with new values (:issue:`49404`)\n- Bug in :meth:`Series.replace` with categorical dtype losing nullable dtypes of underlying categories (:issue:`49404`)\n- Bug in :meth:`DataFrame.groupby` and :meth:`Series.groupby` would reorder categories when used as a grouper (:issue:`48749`)\n- Bug in :class:`Categorical` constructor when constructing from a :class:`Categorical` object and ``dtype=\"category\"`` losing ordered-ness (:issue:`49309`)\n- Bug in :meth:`.SeriesGroupBy.min`, :meth:`.SeriesGroupBy.max`, :meth:`.DataFrameGroupBy.min`, and :meth:`.DataFrameGroupBy.max` with unordered :class:`CategoricalDtype` with no groups failing to raise ``TypeError`` (:issue:`51034`)\n\nDatetimelike\n^^^^^^^^^^^^\n- Bug in :func:`pandas.infer_freq`, raising ``TypeError`` when inferred on :class:`RangeIndex` (:issue:`47084`)\n- Bug in :func:`to_datetime` incorrectly raising ``OverflowError`` with string arguments corresponding to large integers (:issue:`50533`)\n- Bug in :func:`to_datetime` was raising on invalid offsets with ``errors='coerce'`` and ``infer_datetime_format=True`` (:issue:`48633`)\n- Bug in :class:`DatetimeIndex` constructor failing to raise when ``tz=None`` is explicitly specified in conjunction with timezone-aware ``dtype`` or data (:issue:`48659`)\n- Bug in subtracting a ``datetime`` scalar from :class:`DatetimeIndex` failing to retain the original ``freq`` attribute (:issue:`48818`)\n- Bug in ``pandas.tseries.holiday.Holiday`` where a half-open date interval causes inconsistent return types from :meth:`USFederalHolidayCalendar.holidays` (:issue:`49075`)\n- Bug in rendering :class:`DatetimeIndex` and :class:`Series` and :class:`DataFrame` with timezone-aware dtypes with ``dateutil`` or ``zoneinfo`` timezones near daylight-savings transitions (:issue:`49684`)\n- Bug in :func:`to_datetime` was raising ``ValueError`` when parsing :class:`Timestamp`, ``datetime.datetime``, ``datetime.date``, or ``np.datetime64`` objects when non-ISO8601 ``format`` was passed (:issue:`49298`, :issue:`50036`)\n- Bug in :func:`to_datetime` was raising ``ValueError`` when parsing empty string and non-ISO8601 format was passed. Now, empty strings will be parsed as :class:`NaT`, for compatibility with how is done for ISO8601 formats (:issue:`50251`)\n- Bug in :class:`Timestamp` was showing ``UserWarning``, which was not actionable by users, when parsing non-ISO8601 delimited date strings (:issue:`50232`)\n- Bug in :func:`to_datetime` was showing misleading ``ValueError`` when parsing dates with format containing ISO week directive and ISO weekday directive (:issue:`50308`)\n- Bug in :meth:`Timestamp.round` when the ``freq`` argument has zero-duration (e.g. \"0ns\") returning incorrect results instead of raising (:issue:`49737`)\n- Bug in :func:`to_datetime` was not raising ``ValueError`` when invalid format was passed and ``errors`` was ``'ignore'`` or ``'coerce'`` (:issue:`50266`)\n- Bug in :class:`DateOffset` was throwing ``TypeError`` when constructing with milliseconds and another super-daily argument (:issue:`49897`)\n- Bug in :func:`to_datetime` was not raising ``ValueError`` when parsing string with decimal date with format ``'%Y%m%d'`` (:issue:`50051`)\n- Bug in :func:`to_datetime` was not converting ``None`` to ``NaT`` when parsing mixed-offset date strings with ISO8601 format (:issue:`50071`)\n- Bug in :func:`to_datetime` was not returning input when parsing out-of-bounds date string with ``errors='ignore'`` and ``format='%Y%m%d'`` (:issue:`14487`)\n- Bug in :func:`to_datetime` was converting timezone-naive ``datetime.datetime`` to timezone-aware when parsing with timezone-aware strings, ISO8601 format, and ``utc=False`` (:issue:`50254`)\n- Bug in :func:`to_datetime` was throwing ``ValueError`` when parsing dates with ISO8601 format where some values were not zero-padded (:issue:`21422`)\n- Bug in :func:`to_datetime` was giving incorrect results when using ``format='%Y%m%d'`` and ``errors='ignore'`` (:issue:`26493`)\n- Bug in :func:`to_datetime` was failing to parse date strings ``'today'`` and ``'now'`` if ``format`` was not ISO8601 (:issue:`50359`)\n- Bug in :func:`Timestamp.utctimetuple` raising a ``TypeError`` (:issue:`32174`)\n- Bug in :func:`to_datetime` was raising ``ValueError`` when parsing mixed-offset :class:`Timestamp` with ``errors='ignore'`` (:issue:`50585`)\n- Bug in :func:`to_datetime` was incorrectly handling floating-point inputs within 1 ``unit`` of the overflow boundaries (:issue:`50183`)\n- Bug in :func:`to_datetime` with unit of \"Y\" or \"M\" giving incorrect results, not matching pointwise :class:`Timestamp` results (:issue:`50870`)\n- Bug in :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` with datetime or timedelta dtypes incorrectly raising ``ValueError`` (:issue:`11312`)\n- Bug in :func:`to_datetime` was not returning input with ``errors='ignore'`` when input was out-of-bounds (:issue:`50587`)\n- Bug in :func:`DataFrame.from_records` when given a :class:`DataFrame` input with timezone-aware datetime64 columns incorrectly dropping the timezone-awareness (:issue:`51162`)\n- Bug in :func:`to_datetime` was raising ``decimal.InvalidOperation`` when parsing date strings with ``errors='coerce'`` (:issue:`51084`)\n- Bug in :func:`to_datetime` with both ``unit`` and ``origin`` specified returning incorrect results (:issue:`42624`)\n- Bug in :meth:`Series.astype` and :meth:`DataFrame.astype` when converting an object-dtype object containing timezone-aware datetimes or strings to ``datetime64[ns]`` incorrectly localizing as UTC instead of raising ``TypeError`` (:issue:`50140`)\n- Bug in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` with datetime or timedelta dtypes giving incorrect results for groups containing ``NaT`` (:issue:`51373`)\n- Bug in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` incorrectly raising with :class:`PeriodDtype` or :class:`DatetimeTZDtype` (:issue:`51373`)\n\nTimedelta\n^^^^^^^^^\n- Bug in :func:`to_timedelta` raising error when input has nullable dtype ``Float64`` (:issue:`48796`)\n- Bug in :class:`Timedelta` constructor incorrectly raising instead of returning ``NaT`` when given a ``np.timedelta64(\"nat\")`` (:issue:`48898`)\n- Bug in :class:`Timedelta` constructor failing to raise when passed both a :class:`Timedelta` object and keywords (e.g. days, seconds) (:issue:`48898`)\n- Bug in :class:`Timedelta` comparisons with very large ``datetime.timedelta`` objects incorrect raising ``OutOfBoundsTimedelta`` (:issue:`49021`)\n\nTimezones\n^^^^^^^^^\n- Bug in :meth:`Series.astype` and :meth:`DataFrame.astype` with object-dtype containing multiple timezone-aware ``datetime`` objects with heterogeneous timezones to a :class:`DatetimeTZDtype` incorrectly raising (:issue:`32581`)\n- Bug in :func:`to_datetime` was failing to parse date strings with timezone name when ``format`` was specified with ``%Z`` (:issue:`49748`)\n- Better error message when passing invalid values to ``ambiguous`` parameter in :meth:`Timestamp.tz_localize` (:issue:`49565`)\n- Bug in string parsing incorrectly allowing a :class:`Timestamp` to be constructed with an invalid timezone, which would raise when trying to print (:issue:`50668`)\n- Corrected TypeError message in :func:`objects_to_datetime64ns` to inform that DatetimeIndex has mixed timezones (:issue:`50974`)\n\nNumeric\n^^^^^^^\n- Bug in :meth:`DataFrame.add` cannot apply ufunc when inputs contain mixed DataFrame type and Series type (:issue:`39853`)\n- Bug in arithmetic operations on :class:`Series` not propagating mask when combining masked dtypes and numpy dtypes (:issue:`45810`, :issue:`42630`)\n- Bug in :meth:`DataFrame.sem` and :meth:`Series.sem` where an erroneous ``TypeError`` would always raise when using data backed by an :class:`ArrowDtype` (:issue:`49759`)\n- Bug in :meth:`Series.__add__` casting to object for list and masked :class:`Series` (:issue:`22962`)\n- Bug in :meth:`~arrays.ArrowExtensionArray.mode` where ``dropna=False`` was not respected when there was ``NA`` values (:issue:`50982`)\n- Bug in :meth:`DataFrame.query` with ``engine=\"numexpr\"`` and column names are ``min`` or ``max`` would raise a ``TypeError`` (:issue:`50937`)\n- Bug in :meth:`DataFrame.min` and :meth:`DataFrame.max` with tz-aware data containing ``pd.NaT`` and ``axis=1`` would return incorrect results (:issue:`51242`)\n\nConversion\n^^^^^^^^^^\n- Bug in constructing :class:`Series` with ``int64`` dtype from a string list raising instead of casting (:issue:`44923`)\n- Bug in constructing :class:`Series` with masked dtype and boolean values with ``NA`` raising (:issue:`42137`)\n- Bug in :meth:`DataFrame.eval` incorrectly raising an ``AttributeError`` when there are negative values in function call (:issue:`46471`)\n- Bug in :meth:`Series.convert_dtypes` not converting dtype to nullable dtype when :class:`Series` contains ``NA`` and has dtype ``object`` (:issue:`48791`)\n- Bug where any :class:`ExtensionDtype` subclass with ``kind=\"M\"`` would be interpreted as a timezone type (:issue:`34986`)\n- Bug in :class:`.arrays.ArrowExtensionArray` that would raise ``NotImplementedError`` when passed a sequence of strings or binary (:issue:`49172`)\n- Bug in :meth:`Series.astype` raising ``pyarrow.ArrowInvalid`` when converting from a non-pyarrow string dtype to a pyarrow numeric type (:issue:`50430`)\n- Bug in :meth:`DataFrame.astype` modifying input array inplace when converting to ``string`` and ``copy=False`` (:issue:`51073`)\n- Bug in :meth:`Series.to_numpy` converting to NumPy array before applying ``na_value`` (:issue:`48951`)\n- Bug in :meth:`DataFrame.astype` not copying data when converting to pyarrow dtype (:issue:`50984`)\n- Bug in :func:`to_datetime` was not respecting ``exact`` argument when ``format`` was an ISO8601 format (:issue:`12649`)\n- Bug in :meth:`TimedeltaArray.astype` raising ``TypeError`` when converting to a pyarrow duration type (:issue:`49795`)\n- Bug in :meth:`DataFrame.eval` and :meth:`DataFrame.query` raising for extension array dtypes (:issue:`29618`, :issue:`50261`, :issue:`31913`)\n- Bug in :meth:`Series` not copying data when created from :class:`Index` and ``dtype`` is equal to ``dtype`` from :class:`Index` (:issue:`52008`)\n\nStrings\n^^^^^^^\n- Bug in :func:`pandas.api.types.is_string_dtype` that would not return ``True`` for :class:`StringDtype` or :class:`ArrowDtype` with ``pyarrow.string()`` (:issue:`15585`)\n- Bug in converting string dtypes to \"datetime64[ns]\" or \"timedelta64[ns]\" incorrectly raising ``TypeError`` (:issue:`36153`)\n- Bug in setting values in a string-dtype column with an array, mutating the array as side effect when it contains missing values (:issue:`51299`)\n\nInterval\n^^^^^^^^\n- Bug in :meth:`IntervalIndex.is_overlapping` incorrect output if interval has duplicate left boundaries (:issue:`49581`)\n- Bug in :meth:`Series.infer_objects` failing to infer :class:`IntervalDtype` for an object series of :class:`Interval` objects (:issue:`50090`)\n- Bug in :meth:`Series.shift` with :class:`IntervalDtype` and invalid null ``fill_value`` failing to raise ``TypeError`` (:issue:`51258`)\n\nIndexing\n^^^^^^^^\n- Bug in :meth:`DataFrame.__setitem__` raising when indexer is a :class:`DataFrame` with ``boolean`` dtype (:issue:`47125`)\n- Bug in :meth:`DataFrame.reindex` filling with wrong values when indexing columns and index for ``uint`` dtypes (:issue:`48184`)\n- Bug in :meth:`DataFrame.loc` when setting :class:`DataFrame` with different dtypes coercing values to single dtype (:issue:`50467`)\n- Bug in :meth:`DataFrame.sort_values` where ``None`` was not returned when ``by`` is empty list and ``inplace=True`` (:issue:`50643`)\n- Bug in :meth:`DataFrame.loc` coercing dtypes when setting values with a list indexer (:issue:`49159`)\n- Bug in :meth:`Series.loc` raising error for out of bounds end of slice indexer (:issue:`50161`)\n- Bug in :meth:`DataFrame.loc` raising ``ValueError`` with all ``False`` ``bool`` indexer and empty object (:issue:`51450`)\n- Bug in :meth:`DataFrame.loc` raising ``ValueError`` with ``bool`` indexer and :class:`MultiIndex` (:issue:`47687`)\n- Bug in :meth:`DataFrame.loc` raising ``IndexError`` when setting values for a pyarrow-backed column with a non-scalar indexer (:issue:`50085`)\n- Bug in :meth:`DataFrame.__getitem__`, :meth:`Series.__getitem__`, :meth:`DataFrame.__setitem__` and :meth:`Series.__setitem__`\n  when indexing on indexes with extension float dtypes (:class:`Float64` & :class:`Float64`) or complex dtypes using integers (:issue:`51053`)\n- Bug in :meth:`DataFrame.loc` modifying object when setting incompatible value with an empty indexer (:issue:`45981`)\n- Bug in :meth:`DataFrame.__setitem__` raising ``ValueError`` when right hand side is :class:`DataFrame` with :class:`MultiIndex` columns (:issue:`49121`)\n- Bug in :meth:`DataFrame.reindex` casting dtype to ``object`` when :class:`DataFrame` has single extension array column when re-indexing ``columns`` and ``index`` (:issue:`48190`)\n- Bug in :meth:`DataFrame.iloc` raising ``IndexError`` when indexer is a :class:`Series` with numeric extension array dtype (:issue:`49521`)\n- Bug in :func:`~DataFrame.describe` when formatting percentiles in the resulting index showed more decimals than needed (:issue:`46362`)\n- Bug in :meth:`DataFrame.compare` does not recognize differences when comparing ``NA`` with value in nullable dtypes (:issue:`48939`)\n- Bug in :meth:`Series.rename` with :class:`MultiIndex` losing extension array dtypes (:issue:`21055`)\n- Bug in :meth:`DataFrame.isetitem` coercing extension array dtypes in :class:`DataFrame` to object (:issue:`49922`)\n- Bug in :meth:`Series.__getitem__` returning corrupt object when selecting from an empty pyarrow backed object (:issue:`51734`)\n- Bug in :class:`BusinessHour` would cause creation of :class:`DatetimeIndex` to fail when no opening hour was included in the index (:issue:`49835`)\n\nMissing\n^^^^^^^\n- Bug in :meth:`Index.equals` raising ``TypeError`` when :class:`Index` consists of tuples that contain ``NA`` (:issue:`48446`)\n- Bug in :meth:`Series.map` caused incorrect result when data has NaNs and defaultdict mapping was used (:issue:`48813`)\n- Bug in :class:`NA` raising a ``TypeError`` instead of return :class:`NA` when performing a binary operation with a ``bytes`` object (:issue:`49108`)\n- Bug in :meth:`DataFrame.update` with ``overwrite=False`` raising ``TypeError`` when ``self`` has column with ``NaT`` values and column not present in ``other`` (:issue:`16713`)\n- Bug in :meth:`Series.replace` raising ``RecursionError`` when replacing value in object-dtype :class:`Series` containing ``NA`` (:issue:`47480`)\n- Bug in :meth:`Series.replace` raising ``RecursionError`` when replacing value in numeric :class:`Series` with ``NA`` (:issue:`50758`)\n\nMultiIndex\n^^^^^^^^^^\n- Bug in :meth:`MultiIndex.get_indexer` not matching ``NaN`` values (:issue:`29252`, :issue:`37222`, :issue:`38623`, :issue:`42883`, :issue:`43222`, :issue:`46173`, :issue:`48905`)\n- Bug in :meth:`MultiIndex.argsort` raising ``TypeError`` when index contains :attr:`NA` (:issue:`48495`)\n- Bug in :meth:`MultiIndex.difference` losing extension array dtype (:issue:`48606`)\n- Bug in :class:`MultiIndex.set_levels` raising ``IndexError`` when setting empty level (:issue:`48636`)\n- Bug in :meth:`MultiIndex.unique` losing extension array dtype (:issue:`48335`)\n- Bug in :meth:`MultiIndex.intersection` losing extension array (:issue:`48604`)\n- Bug in :meth:`MultiIndex.union` losing extension array (:issue:`48498`, :issue:`48505`, :issue:`48900`)\n- Bug in :meth:`MultiIndex.union` not sorting when sort=None and index contains missing values (:issue:`49010`)\n- Bug in :meth:`MultiIndex.append` not checking names for equality (:issue:`48288`)\n- Bug in :meth:`MultiIndex.symmetric_difference` losing extension array (:issue:`48607`)\n- Bug in :meth:`MultiIndex.join` losing dtypes when :class:`MultiIndex` has duplicates (:issue:`49830`)\n- Bug in :meth:`MultiIndex.putmask` losing extension array (:issue:`49830`)\n- Bug in :meth:`MultiIndex.value_counts` returning a :class:`Series` indexed by flat index of tuples instead of a :class:`MultiIndex` (:issue:`49558`)\n\nI/O\n^^^\n- Bug in :func:`read_sas` caused fragmentation of :class:`DataFrame` and raised :class:`.errors.PerformanceWarning` (:issue:`48595`)\n- Improved error message in :func:`read_excel` by including the offending sheet name when an exception is raised while reading a file (:issue:`48706`)\n- Bug when a pickling a subset PyArrow-backed data that would serialize the entire data instead of the subset (:issue:`42600`)\n- Bug in :func:`read_sql_query` ignoring ``dtype`` argument when ``chunksize`` is specified and result is empty (:issue:`50245`)\n- Bug in :func:`read_csv` for a single-line csv with fewer columns than ``names`` raised :class:`.errors.ParserError` with ``engine=\"c\"`` (:issue:`47566`)\n- Bug in :func:`read_json` raising with ``orient=\"table\"`` and ``NA`` value (:issue:`40255`)\n- Bug in displaying ``string`` dtypes not showing storage option (:issue:`50099`)\n- Bug in :meth:`DataFrame.to_string` with ``header=False`` that printed the index name on the same line as the first row of the data (:issue:`49230`)\n- Bug in :meth:`DataFrame.to_string` ignoring float formatter for extension arrays (:issue:`39336`)\n- Fixed memory leak which stemmed from the initialization of the internal JSON module (:issue:`49222`)\n- Fixed issue where :func:`json_normalize` would incorrectly remove leading characters from column names that matched the ``sep`` argument (:issue:`49861`)\n- Bug in :func:`read_csv` unnecessarily overflowing for extension array dtype when containing ``NA`` (:issue:`32134`)\n- Bug in :meth:`DataFrame.to_dict` not converting ``NA`` to ``None`` (:issue:`50795`)\n- Bug in :meth:`DataFrame.to_json` where it would segfault when failing to encode a string (:issue:`50307`)\n- Bug in :meth:`DataFrame.to_html` with ``na_rep`` set when the :class:`DataFrame` contains non-scalar data (:issue:`47103`)\n- Bug in :func:`read_xml` where file-like objects failed when iterparse is used (:issue:`50641`)\n- Bug in :func:`read_csv` when ``engine=\"pyarrow\"`` where ``encoding`` parameter was not handled correctly (:issue:`51302`)\n- Bug in :func:`read_xml` ignored repeated elements when iterparse is used (:issue:`51183`)\n- Bug in :class:`ExcelWriter` leaving file handles open if an exception occurred during instantiation (:issue:`51443`)\n- Bug in :meth:`DataFrame.to_parquet` where non-string index or columns were raising a ``ValueError`` when ``engine=\"pyarrow\"`` (:issue:`52036`)\n\nPeriod\n^^^^^^\n- Bug in :meth:`Period.strftime` and :meth:`PeriodIndex.strftime`, raising ``UnicodeDecodeError`` when a locale-specific directive was passed (:issue:`46319`)\n- Bug in adding a :class:`Period` object to an array of :class:`DateOffset` objects incorrectly raising ``TypeError`` (:issue:`50162`)\n- Bug in :class:`Period` where passing a string with finer resolution than nanosecond would result in a ``KeyError`` instead of dropping the extra precision (:issue:`50417`)\n- Bug in parsing strings representing Week-periods e.g. \"2017-01-23/2017-01-29\" as minute-frequency instead of week-frequency (:issue:`50803`)\n- Bug in :meth:`.DataFrameGroupBy.sum`, :meth:`.DataFrameGroupByGroupBy.cumsum`, :meth:`.DataFrameGroupByGroupBy.prod`, :meth:`.DataFrameGroupByGroupBy.cumprod` with :class:`PeriodDtype` failing to raise ``TypeError`` (:issue:`51040`)\n- Bug in parsing empty string with :class:`Period` incorrectly raising ``ValueError`` instead of returning ``NaT`` (:issue:`51349`)\n\nPlotting\n^^^^^^^^\n- Bug in :meth:`DataFrame.plot.hist`, not dropping elements of ``weights`` corresponding to ``NaN`` values in ``data`` (:issue:`48884`)\n- ``ax.set_xlim`` was sometimes raising ``UserWarning`` which users couldn't address due to ``set_xlim`` not accepting parsing arguments - the converter now uses :func:`Timestamp` instead (:issue:`49148`)\n\nGroupby/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n- Bug in :class:`.ExponentialMovingWindow` with ``online`` not raising a ``NotImplementedError`` for unsupported operations (:issue:`48834`)\n- Bug in :meth:`.DataFrameGroupBy.sample` raises ``ValueError`` when the object is empty (:issue:`48459`)\n- Bug in :meth:`Series.groupby` raises ``ValueError`` when an entry of the index is equal to the name of the index (:issue:`48567`)\n- Bug in :meth:`.DataFrameGroupBy.resample` produces inconsistent results when passing empty DataFrame (:issue:`47705`)\n- Bug in :class:`.DataFrameGroupBy` and :class:`.SeriesGroupBy` would not include unobserved categories in result when grouping by categorical indexes (:issue:`49354`)\n- Bug in :class:`.DataFrameGroupBy` and :class:`.SeriesGroupBy` would change result order depending on the input index when grouping by categoricals (:issue:`49223`)\n- Bug in :class:`.DataFrameGroupBy` and :class:`.SeriesGroupBy` when grouping on categorical data would sort result values even when used with ``sort=False`` (:issue:`42482`)\n- Bug in :meth:`.DataFrameGroupBy.apply` and :class:`.SeriesGroupBy.apply` with ``as_index=False`` would not attempt the computation without using the grouping keys when using them failed with a ``TypeError`` (:issue:`49256`)\n- Bug in :meth:`.DataFrameGroupBy.describe` would describe the group keys (:issue:`49256`)\n- Bug in :meth:`.SeriesGroupBy.describe` with ``as_index=False`` would have the incorrect shape (:issue:`49256`)\n- Bug in :class:`.DataFrameGroupBy` and :class:`.SeriesGroupBy` with ``dropna=False`` would drop NA values when the grouper was categorical (:issue:`36327`)\n- Bug in :meth:`.SeriesGroupBy.nunique` would incorrectly raise when the grouper was an empty categorical and ``observed=True`` (:issue:`21334`)\n- Bug in :meth:`.SeriesGroupBy.nth` would raise when grouper contained NA values after subsetting from a :class:`DataFrameGroupBy` (:issue:`26454`)\n- Bug in :meth:`DataFrame.groupby` would not include a :class:`.Grouper` specified by ``key`` in the result when ``as_index=False`` (:issue:`50413`)\n- Bug in :meth:`.DataFrameGroupBy.value_counts` would raise when used with a :class:`.TimeGrouper` (:issue:`50486`)\n- Bug in :meth:`.Resampler.size` caused a wide :class:`DataFrame` to be returned instead of a :class:`Series` with :class:`MultiIndex` (:issue:`46826`)\n- Bug in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` would raise incorrectly when grouper had ``axis=1`` for ``\"idxmin\"`` and ``\"idxmax\"`` arguments (:issue:`45986`)\n- Bug in :class:`.DataFrameGroupBy` would raise when used with an empty DataFrame, categorical grouper, and ``dropna=False`` (:issue:`50634`)\n- Bug in :meth:`.SeriesGroupBy.value_counts` did not respect ``sort=False`` (:issue:`50482`)\n- Bug in :meth:`.DataFrameGroupBy.resample` raises ``KeyError`` when getting the result from a key list when resampling on time index (:issue:`50840`)\n- Bug in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` would raise incorrectly when grouper had ``axis=1`` for ``\"ngroup\"`` argument (:issue:`45986`)\n- Bug in :meth:`.DataFrameGroupBy.describe` produced incorrect results when data had duplicate columns (:issue:`50806`)\n- Bug in :meth:`.DataFrameGroupBy.agg` with ``engine=\"numba\"`` failing to respect ``as_index=False`` (:issue:`51228`)\n- Bug in :meth:`.DataFrameGroupBy.agg`, :meth:`.SeriesGroupBy.agg`, and :meth:`.Resampler.agg` would ignore arguments when passed a list of functions (:issue:`50863`)\n- Bug in :meth:`.DataFrameGroupBy.ohlc` ignoring ``as_index=False`` (:issue:`51413`)\n- Bug in :meth:`DataFrameGroupBy.agg` after subsetting columns (e.g. ``.groupby(...)[[\"a\", \"b\"]]``) would not include groupings in the result (:issue:`51186`)\n\nReshaping\n^^^^^^^^^\n- Bug in :meth:`DataFrame.pivot_table` raising ``TypeError`` for nullable dtype and ``margins=True`` (:issue:`48681`)\n- Bug in :meth:`DataFrame.unstack` and :meth:`Series.unstack` unstacking wrong level of :class:`MultiIndex` when :class:`MultiIndex` has mixed names (:issue:`48763`)\n- Bug in :meth:`DataFrame.melt` losing extension array dtype (:issue:`41570`)\n- Bug in :meth:`DataFrame.pivot` not respecting ``None`` as column name (:issue:`48293`)\n- Bug in :meth:`DataFrame.join` when ``left_on`` or ``right_on`` is or includes a :class:`CategoricalIndex` incorrectly raising ``AttributeError`` (:issue:`48464`)\n- Bug in :meth:`DataFrame.pivot_table` raising ``ValueError`` with parameter ``margins=True`` when result is an empty :class:`DataFrame` (:issue:`49240`)\n- Clarified error message in :func:`merge` when passing invalid ``validate`` option (:issue:`49417`)\n- Bug in :meth:`DataFrame.explode` raising ``ValueError`` on multiple columns with ``NaN`` values or empty lists (:issue:`46084`)\n- Bug in :meth:`DataFrame.transpose` with ``IntervalDtype`` column with ``timedelta64[ns]`` endpoints (:issue:`44917`)\n- Bug in :meth:`DataFrame.agg` and :meth:`Series.agg` would ignore arguments when passed a list of functions (:issue:`50863`)\n\nSparse\n^^^^^^\n- Bug in :meth:`Series.astype` when converting a ``SparseDtype`` with ``datetime64[ns]`` subtype to ``int64`` dtype raising, inconsistent with the non-sparse behavior (:issue:`49631`,:issue:`50087`)\n- Bug in :meth:`Series.astype` when converting a from ``datetime64[ns]`` to ``Sparse[datetime64[ns]]`` incorrectly raising (:issue:`50082`)\n- Bug in :meth:`Series.sparse.to_coo` raising ``SystemError`` when :class:`MultiIndex` contains a ``ExtensionArray`` (:issue:`50996`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n- Bug in :meth:`Series.mean` overflowing unnecessarily with nullable integers (:issue:`48378`)\n- Bug in :meth:`Series.tolist` for nullable dtypes returning numpy scalars instead of python scalars (:issue:`49890`)\n- Bug in :meth:`Series.round` for pyarrow-backed dtypes raising ``AttributeError`` (:issue:`50437`)\n- Bug when concatenating an empty DataFrame with an ExtensionDtype to another DataFrame with the same ExtensionDtype, the resulting dtype turned into object (:issue:`48510`)\n- Bug in :meth:`array.PandasArray.to_numpy` raising with ``NA`` value when ``na_value`` is specified (:issue:`40638`)\n- Bug in :meth:`api.types.is_numeric_dtype` where a custom :class:`ExtensionDtype` would not return ``True`` if ``_is_numeric`` returned ``True`` (:issue:`50563`)\n- Bug in :meth:`api.types.is_integer_dtype`, :meth:`api.types.is_unsigned_integer_dtype`, :meth:`api.types.is_signed_integer_dtype`, :meth:`api.types.is_float_dtype` where a custom :class:`ExtensionDtype` would not return ``True`` if ``kind`` returned the corresponding NumPy type (:issue:`50667`)\n- Bug in :class:`Series` constructor unnecessarily overflowing for nullable unsigned integer dtypes (:issue:`38798`, :issue:`25880`)\n- Bug in setting non-string value into ``StringArray`` raising ``ValueError`` instead of ``TypeError`` (:issue:`49632`)\n- Bug in :meth:`DataFrame.reindex` not honoring the default ``copy=True`` keyword in case of columns with ExtensionDtype (and as a result also selecting multiple columns with getitem (``[]``) didn't correctly result in a copy) (:issue:`51197`)\n- Bug in :class:`~arrays.ArrowExtensionArray` logical operations ``&`` and ``|`` raising ``KeyError`` (:issue:`51688`)\n\nStyler\n^^^^^^\n- Fix :meth:`~pandas.io.formats.style.Styler.background_gradient` for nullable dtype :class:`Series` with ``NA`` values (:issue:`50712`)\n\nMetadata\n^^^^^^^^\n- Fixed metadata propagation in :meth:`DataFrame.corr` and :meth:`DataFrame.cov` (:issue:`28283`)\n\nOther\n^^^^^\n- Bug in incorrectly accepting dtype strings containing \"[pyarrow]\" more than once (:issue:`51548`)\n- Bug in :meth:`Series.searchsorted` inconsistent behavior when accepting :class:`DataFrame` as parameter ``value`` (:issue:`49620`)\n- Bug in :func:`array` failing to raise on :class:`DataFrame` inputs (:issue:`51167`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_200.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.5.0rc0..v2.0.0\n", "0.8.1": ".. _whatsnew_0801:\n\nVersion 0.8.1 (July 22, 2012)\n-----------------------------\n\n{{ header }}\n\n\nThis release includes a few new features, performance enhancements, and over 30\nbug fixes from 0.8.0.  New features include notably NA friendly string\nprocessing functionality and a series of new plot types and options.\n\nNew features\n~~~~~~~~~~~~\n\n  - Add :ref:`vectorized string processing methods <text.string_methods>`\n    accessible via Series.str (:issue:`620`)\n  - Add option to disable adjustment in EWMA (:issue:`1584`)\n  - :ref:`Radviz plot <visualization.radviz>` (:issue:`1566`)\n  - :ref:`Parallel coordinates plot <visualization.parallel_coordinates>`\n  - :ref:`Bootstrap plot <visualization.bootstrap>`\n  - Per column styles and secondary y-axis plotting (:issue:`1559`)\n  - New datetime converters millisecond plotting  (:issue:`1599`)\n  - Add option to disable \"sparse\" display of hierarchical indexes (:issue:`1538`)\n  - Series/DataFrame's ``set_index`` method can :ref:`append levels\n    <indexing.set_index>` to an existing Index/MultiIndex (:issue:`1569`, :issue:`1577`)\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n  - Improved implementation of rolling min and max (thanks to `Bottleneck\n    <https://bottleneck.readthedocs.io>`__ !)\n  - Add accelerated ``'median'`` GroupBy option (:issue:`1358`)\n  - Significantly improve the performance of parsing ISO8601-format date\n    strings with ``DatetimeIndex`` or ``to_datetime`` (:issue:`1571`)\n  - Improve the performance of GroupBy on single-key aggregations and use with\n    Categorical types\n  - Significant datetime parsing performance improvements\n\n\n\n.. _whatsnew_0.8.1.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.8.0..v0.8.1\n", "1.3.4": ".. _whatsnew_134:\n\nWhat's new in 1.3.4 (October 17, 2021)\n--------------------------------------\n\nThese are the changes in pandas 1.3.4. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_134.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`DataFrame.convert_dtypes` incorrectly converts byte strings to strings (:issue:`43183`)\n- Fixed regression in :meth:`.DataFrameGroupBy.agg` and :meth:`.SeriesGroupBy.agg` were failing silently with mixed data types along ``axis=1`` and :class:`MultiIndex` (:issue:`43209`)\n- Fixed regression in :func:`merge` with integer and ``NaN`` keys failing with ``outer`` merge (:issue:`43550`)\n- Fixed regression in :meth:`DataFrame.corr` raising ``ValueError`` with ``method=\"spearman\"`` on 32-bit platforms (:issue:`43588`)\n- Fixed performance regression in :meth:`MultiIndex.equals` (:issue:`43549`)\n- Fixed performance regression in :meth:`.DataFrameGroupBy.first`, :meth:`.SeriesGroupBy.first`, :meth:`.DataFrameGroupBy.last`, and :meth:`.SeriesGroupBy.last` with :class:`StringDtype` (:issue:`41596`)\n- Fixed regression in :meth:`Series.cat.reorder_categories` failing to update the categories on the ``Series`` (:issue:`43232`)\n- Fixed regression in :meth:`Series.cat.categories` setter failing to update the categories on the ``Series`` (:issue:`43334`)\n- Fixed regression in :func:`read_csv` raising ``UnicodeDecodeError`` exception when ``memory_map=True`` (:issue:`43540`)\n- Fixed regression in :meth:`DataFrame.explode` raising ``AssertionError`` when ``column`` is any scalar which is not a string (:issue:`43314`)\n- Fixed regression in :meth:`Series.aggregate` attempting to pass ``args`` and ``kwargs`` multiple times to the user supplied ``func`` in certain cases (:issue:`43357`)\n- Fixed regression when iterating over a :class:`DataFrame.groupby.rolling` object causing the resulting DataFrames to have an incorrect index if the input groupings were not sorted (:issue:`43386`)\n- Fixed regression in :meth:`DataFrame.groupby.rolling.cov` and :meth:`DataFrame.groupby.rolling.corr` computing incorrect results if the input groupings were not sorted (:issue:`43386`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_134.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fixed bug in :meth:`pandas.DataFrame.groupby.rolling` and :class:`pandas.api.indexers.FixedForwardWindowIndexer` leading to segfaults and window endpoints being mixed across groups (:issue:`43267`)\n- Fixed bug in :meth:`.DataFrameGroupBy.mean` and :meth:`.SeriesGroupBy.mean` with datetimelike values including ``NaT`` values returning incorrect results (:issue:`43132`)\n- Fixed bug in :meth:`Series.aggregate` not passing the first ``args`` to the user supplied ``func`` in certain cases (:issue:`43357`)\n- Fixed memory leaks in :meth:`Series.rolling.quantile` and :meth:`Series.rolling.median` (:issue:`43339`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_134.other:\n\nOther\n~~~~~\n- The minimum version of Cython needed to compile pandas is now ``0.29.24`` (:issue:`43729`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_134.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.3.3..v1.3.4\n", "0.7.2": ".. _whatsnew_0702:\n\nVersion 0.7.2 (March 16, 2012)\n------------------------------\n\n{{ header }}\n\n\nThis release targets bugs in 0.7.1, and adds a few minor features.\n\nNew features\n~~~~~~~~~~~~\n\n  - Add additional tie-breaking methods in DataFrame.rank (:issue:`874`)\n  - Add ascending parameter to rank in Series, DataFrame (:issue:`875`)\n  - Add coerce_float option to DataFrame.from_records (:issue:`893`)\n  - Add sort_columns parameter to allow unsorted plots (:issue:`918`)\n  - Enable column access via attributes on GroupBy (:issue:`882`)\n  - Can pass dict of values to DataFrame.fillna (:issue:`661`)\n  - Can select multiple hierarchical groups by passing list of values in .ix\n    (:issue:`134`)\n  - Add ``axis`` option to DataFrame.fillna (:issue:`174`)\n  - Add level keyword to ``drop`` for dropping values from a level (:issue:`159`)\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n  - Use khash for Series.value_counts, add raw function to algorithms.py (:issue:`861`)\n  - Intercept __builtin__.sum in groupby (:issue:`885`)\n\n\n\n.. _whatsnew_0.7.2.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.7.1..v0.7.2\n", "1.4.3": ".. _whatsnew_143:\n\nWhat's new in 1.4.3 (June 23, 2022)\n-----------------------------------\n\nThese are the changes in pandas 1.4.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_143.concat:\n\nBehavior of ``concat`` with empty or all-NA DataFrame columns\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe behavior change in version 1.4.0 to stop ignoring the data type\nof empty or all-NA columns with float or object dtype in :func:`concat`\n(:ref:`whatsnew_140.notable_bug_fixes.concat_with_empty_or_all_na`) has been\nreverted (:issue:`45637`).\n\n\n.. _whatsnew_143.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`DataFrame.replace` when the replacement value was explicitly ``None`` when passed in a dictionary to ``to_replace`` also casting other columns to object dtype even when there were no values to replace (:issue:`46634`)\n- Fixed regression in :meth:`DataFrame.to_csv` raising error when :class:`DataFrame` contains extension dtype categorical column (:issue:`46297`, :issue:`46812`)\n- Fixed regression in representation of ``dtypes`` attribute of :class:`MultiIndex` (:issue:`46900`)\n- Fixed regression when setting values with :meth:`DataFrame.loc` updating :class:`RangeIndex` when index was set as new column and column was updated afterwards (:issue:`47128`)\n- Fixed regression in :meth:`DataFrame.fillna` and :meth:`DataFrame.update` creating a copy when updating inplace (:issue:`47188`)\n- Fixed regression in :meth:`DataFrame.nsmallest` led to wrong results when the sorting column has ``np.nan`` values (:issue:`46589`)\n- Fixed regression in :func:`read_fwf` raising ``ValueError`` when ``widths`` was specified with ``usecols`` (:issue:`46580`)\n- Fixed regression in :func:`concat` not sorting columns for mixed column names (:issue:`47127`)\n- Fixed regression in :meth:`.Groupby.transform` and :meth:`.Groupby.agg` failing with ``engine=\"numba\"`` when the index was a :class:`MultiIndex` (:issue:`46867`)\n- Fixed regression in ``NaN`` comparison for :class:`Index` operations where the same object was compared (:issue:`47105`)\n- Fixed regression is :meth:`.Styler.to_latex` and :meth:`.Styler.to_html` where ``buf`` failed in combination with ``encoding`` (:issue:`47053`)\n- Fixed regression in :func:`read_csv` with ``index_col=False`` identifying first row as index names when ``header=None`` (:issue:`46955`)\n- Fixed regression in :meth:`.DataFrameGroupBy.agg` when used with list-likes or dict-likes and ``axis=1`` that would give incorrect results; now raises ``NotImplementedError`` (:issue:`46995`)\n- Fixed regression in :meth:`DataFrame.resample` and :meth:`DataFrame.rolling` when used with list-likes or dict-likes and ``axis=1`` that would raise an unintuitive error message; now raises ``NotImplementedError`` (:issue:`46904`)\n- Fixed regression in :func:`testing.assert_index_equal` when ``check_order=False`` and :class:`Index` has extension or object dtype (:issue:`47207`)\n- Fixed regression in :func:`read_excel` returning ints as floats on certain input sheets (:issue:`46988`)\n- Fixed regression in :meth:`DataFrame.shift` when ``axis`` is ``columns`` and ``fill_value`` is absent, ``freq`` is ignored (:issue:`47039`)\n- Fixed regression in :meth:`DataFrame.to_json` causing a segmentation violation when :class:`DataFrame` is created with an ``index`` parameter of the type :class:`PeriodIndex` (:issue:`46683`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_143.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :func:`pandas.eval`, :meth:`DataFrame.eval` and :meth:`DataFrame.query` where passing empty ``local_dict`` or ``global_dict`` was treated as passing ``None`` (:issue:`47084`)\n- Most I/O methods no longer suppress ``OSError`` and ``ValueError`` when closing file handles (:issue:`47136`)\n- Improving error message raised by :meth:`DataFrame.from_dict` when passing an invalid ``orient`` parameter (:issue:`47450`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_143.other:\n\nOther\n~~~~~\n- The minimum version of Cython needed to compile pandas is now ``0.29.30`` (:issue:`41935`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_143.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.4.2..v1.4.3\n", "0.9.0": ".. _whatsnew_0900:\n\n{{ header }}\n\n\nVersion 0.9.0 (October 7, 2012)\n-------------------------------\n\nThis is a major release from 0.8.1 and includes several new features and\nenhancements along with a large number of bug fixes. New features include\nvectorized unicode encoding/decoding for ``Series.str``, ``to_latex`` method to\nDataFrame, more flexible parsing of boolean values, and enabling the download of\noptions data from Yahoo! Finance.\n\nNew features\n~~~~~~~~~~~~\n\n  - Add ``encode`` and ``decode`` for unicode handling to :ref:`vectorized\n    string processing methods <text.string_methods>` in Series.str  (:issue:`1706`)\n  - Add ``DataFrame.to_latex`` method (:issue:`1735`)\n  - Add convenient expanding window equivalents of all rolling_* ops (:issue:`1785`)\n  - Add Options class to pandas.io.data for fetching options data from Yahoo!\n    Finance (:issue:`1748`, :issue:`1739`)\n  - More flexible parsing of boolean values (Yes, No, TRUE, FALSE, etc)\n    (:issue:`1691`, :issue:`1295`)\n  - Add ``level`` parameter to ``Series.reset_index``\n  - ``TimeSeries.between_time`` can now select times across midnight (:issue:`1871`)\n  - Series constructor can now handle generator as input (:issue:`1679`)\n  - ``DataFrame.dropna`` can now take multiple axes (tuple/list) as input\n    (:issue:`924`)\n  - Enable ``skip_footer`` parameter in ``ExcelFile.parse`` (:issue:`1843`)\n\nAPI changes\n~~~~~~~~~~~\n\n  - The default column names when ``header=None`` and no columns names passed to\n    functions like ``read_csv`` has changed to be more Pythonic and amenable to\n    attribute access:\n\n.. ipython:: python\n\n   import io\n\n   data = \"\"\"\n   0,0,1\n   1,1,0\n   0,1,0\n   \"\"\"\n   df = pd.read_csv(io.StringIO(data), header=None)\n   df\n\n\n- Creating a Series from another Series, passing an index, will cause reindexing\n  to happen inside rather than treating the Series like an ndarray. Technically\n  improper usages like ``Series(df[col1], index=df[col2])`` that worked before\n  \"by accident\" (this was never intended) will lead to all NA Series in some\n  cases. To be perfectly clear:\n\n.. ipython:: python\n\n   s1 = pd.Series([1, 2, 3])\n   s1\n\n   s2 = pd.Series(s1, index=[\"foo\", \"bar\", \"baz\"])\n   s2\n\n- Deprecated ``day_of_year`` API removed from PeriodIndex, use ``dayofyear``\n  (:issue:`1723`)\n\n- Don't modify NumPy suppress printoption to True at import time\n\n- The internal HDF5 data arrangement for DataFrames has been transposed.  Legacy\n  files will still be readable by HDFStore (:issue:`1834`, :issue:`1824`)\n\n- Legacy cruft removed: pandas.stats.misc.quantileTS\n\n- Use ISO8601 format for Period repr: monthly, daily, and on down (:issue:`1776`)\n\n- Empty DataFrame columns are now created as object dtype. This will prevent a\n  class of TypeErrors that was occurring in code where the dtype of a column\n  would depend on the presence of data or not (e.g. a SQL query having results)\n  (:issue:`1783`)\n\n- Setting parts of DataFrame/Panel using ix now aligns input Series/DataFrame\n  (:issue:`1630`)\n\n- ``first`` and ``last`` methods in ``GroupBy`` no longer drop non-numeric\n  columns (:issue:`1809`)\n\n- Resolved inconsistencies in specifying custom NA values in text parser.\n  ``na_values`` of type dict no longer override default NAs unless\n  ``keep_default_na`` is set to false explicitly (:issue:`1657`)\n\n- ``DataFrame.dot`` will not do data alignment, and also work with Series\n  (:issue:`1915`)\n\n\nSee the :ref:`full release notes\n<release>` or issue tracker\non GitHub for a complete list.\n\n\n\n.. _whatsnew_0.9.0.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.8.1..v0.9.0\n", "2.1.2": ".. _whatsnew_212:\n\nWhat's new in 2.1.2 (October 26, 2023)\n---------------------------------------\n\nThese are the changes in pandas 2.1.2. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_212.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\n- Reverted deprecation of ``fill_method=None`` in :meth:`DataFrame.pct_change`, :meth:`Series.pct_change`, :meth:`DataFrameGroupBy.pct_change`, and :meth:`SeriesGroupBy.pct_change`; the values ``'backfill'``, ``'bfill'``, ``'pad'``, and ``'ffill'`` are still deprecated (:issue:`53491`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_212.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`DataFrame.join` where result has missing values and dtype is arrow backed string (:issue:`55348`)\n- Fixed regression in :meth:`~DataFrame.rolling` where non-nanosecond index or ``on`` column would produce incorrect results (:issue:`55026`, :issue:`55106`, :issue:`55299`)\n- Fixed regression in :meth:`DataFrame.resample` which was extrapolating back to ``origin`` when ``origin`` was outside its bounds (:issue:`55064`)\n- Fixed regression in :meth:`DataFrame.sort_index` which was not sorting correctly when the index was a sliced :class:`MultiIndex` (:issue:`55379`)\n- Fixed regression in :meth:`DataFrameGroupBy.agg` and :meth:`SeriesGroupBy.agg` where if the option ``compute.use_numba`` was set to True, groupby methods not supported by the numba engine would raise a ``TypeError`` (:issue:`55520`)\n- Fixed performance regression with wide DataFrames, typically involving methods where all columns were accessed individually (:issue:`55256`, :issue:`55245`)\n- Fixed regression in :func:`merge_asof` raising ``TypeError`` for ``by`` with datetime and timedelta dtypes (:issue:`55453`)\n- Fixed regression in :func:`read_parquet` when reading a file with a string column consisting of more than 2 GB of string data and using the ``\"string\"`` dtype (:issue:`55606`)\n- Fixed regression in :meth:`DataFrame.to_sql` not roundtripping datetime columns correctly for sqlite when using ``detect_types`` (:issue:`55554`)\n- Fixed regression in construction of certain DataFrame or Series subclasses (:issue:`54922`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_212.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fixed bug in :class:`.DataFrameGroupBy` reductions not preserving object dtype when ``infer_string`` is set (:issue:`55620`)\n- Fixed bug in :meth:`.SeriesGroupBy.value_counts` returning incorrect dtype for string columns (:issue:`55627`)\n- Fixed bug in :meth:`Categorical.equals` if other has arrow backed string dtype (:issue:`55364`)\n- Fixed bug in :meth:`DataFrame.__setitem__` not inferring string dtype for zero-dimensional array with ``infer_string=True`` (:issue:`55366`)\n- Fixed bug in :meth:`DataFrame.idxmin` and :meth:`DataFrame.idxmax` raising for arrow dtypes (:issue:`55368`)\n- Fixed bug in :meth:`DataFrame.interpolate` raising incorrect error message (:issue:`55347`)\n- Fixed bug in :meth:`Index.insert` raising when inserting ``None`` into :class:`Index` with ``dtype=\"string[pyarrow_numpy]\"`` (:issue:`55365`)\n- Fixed bug in :meth:`Series.all`  and :meth:`Series.any` not treating missing values correctly for ``dtype=\"string[pyarrow_numpy]\"`` (:issue:`55367`)\n- Fixed bug in :meth:`Series.floordiv` for :class:`ArrowDtype` (:issue:`55561`)\n- Fixed bug in :meth:`Series.mode` not sorting values for arrow backed string dtype (:issue:`55621`)\n- Fixed bug in :meth:`Series.rank` for ``string[pyarrow_numpy]`` dtype (:issue:`55362`)\n- Fixed bug in :meth:`Series.str.extractall` for :class:`ArrowDtype` dtype being converted to object (:issue:`53846`)\n- Fixed bug where PDEP-6 warning about setting an item of an incompatible dtype was being shown when creating a new conditional column (:issue:`55025`)\n- Silence ``Period[B]`` warnings introduced by :issue:`53446` during normal plotting activity (:issue:`55138`)\n- Fixed bug in :class:`Series` constructor not inferring string dtype when ``NA`` is the first value and ``infer_string`` is set (:issue:` 55655`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_212.other:\n\nOther\n~~~~~\n- Fixed non-working installation of optional dependency group ``output_formatting``. Replacing underscore ``_`` with a dash ``-`` fixes broken dependency resolution. A correct way to use now is ``pip install pandas[output-formatting]``.\n-\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_212.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.1.1..v2.1.2\n", "1.3.0": ".. _whatsnew_130:\n\nWhat's new in 1.3.0 (July 2, 2021)\n----------------------------------\n\nThese are the changes in pandas 1.3.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. warning::\n\n   When reading new Excel 2007+ (``.xlsx``) files, the default argument\n   ``engine=None`` to :func:`read_excel` will now result in using the\n   `openpyxl <https://openpyxl.readthedocs.io/en/stable/>`_ engine in all cases\n   when the option :attr:`io.excel.xlsx.reader` is set to ``\"auto\"``.\n   Previously, some cases would use the\n   `xlrd <https://xlrd.readthedocs.io/en/latest/>`_ engine instead. See\n   :ref:`What's new 1.2.0 <whatsnew_120>` for background on this change.\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_130.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_130.enhancements.read_csv_json_http_headers:\n\nCustom HTTP(s) headers when reading csv or json files\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen reading from a remote URL that is not handled by fsspec (e.g. HTTP and\nHTTPS) the dictionary passed to ``storage_options`` will be used to create the\nheaders included in the request.  This can be used to control the User-Agent\nheader or send other custom headers (:issue:`36688`).\nFor example:\n\n.. code-block:: ipython\n\n    In [1]: headers = {\"User-Agent\": \"pandas\"}\n    In [2]: df = pd.read_csv(\n       ...:     \"https://download.bls.gov/pub/time.series/cu/cu.item\",\n       ...:     sep=\"\\t\",\n       ...:     storage_options=headers\n       ...: )\n\n.. _whatsnew_130.enhancements.read_to_xml:\n\nRead and write XML documents\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe added I/O support to read and render shallow versions of `XML`_ documents with\n:func:`read_xml` and :meth:`DataFrame.to_xml`. Using `lxml`_ as parser,\nboth XPath 1.0 and XSLT 1.0 are available. (:issue:`27554`)\n\n.. _XML: https://www.w3.org/standards/xml/core\n.. _lxml: https://lxml.de\n\n.. code-block:: ipython\n\n    In [1]: xml = \"\"\"<?xml version='1.0' encoding='utf-8'?>\n       ...: <data>\n       ...:  <row>\n       ...:     <shape>square</shape>\n       ...:     <degrees>360</degrees>\n       ...:     <sides>4.0</sides>\n       ...:  </row>\n       ...:  <row>\n       ...:     <shape>circle</shape>\n       ...:     <degrees>360</degrees>\n       ...:     <sides/>\n       ...:  </row>\n       ...:  <row>\n       ...:     <shape>triangle</shape>\n       ...:     <degrees>180</degrees>\n       ...:     <sides>3.0</sides>\n       ...:  </row>\n       ...:  </data>\"\"\"\n\n    In [2]: df = pd.read_xml(xml)\n    In [3]: df\n    Out[3]:\n          shape  degrees  sides\n    0    square      360    4.0\n    1    circle      360    NaN\n    2  triangle      180    3.0\n\n    In [4]: df.to_xml()\n    Out[4]:\n    <?xml version='1.0' encoding='utf-8'?>\n    <data>\n      <row>\n        <index>0</index>\n        <shape>square</shape>\n        <degrees>360</degrees>\n        <sides>4.0</sides>\n      </row>\n      <row>\n        <index>1</index>\n        <shape>circle</shape>\n        <degrees>360</degrees>\n        <sides/>\n      </row>\n      <row>\n        <index>2</index>\n        <shape>triangle</shape>\n        <degrees>180</degrees>\n        <sides>3.0</sides>\n      </row>\n    </data>\n\nFor more, see :ref:`io.xml` in the user guide on IO tools.\n\n.. _whatsnew_130.enhancements.styler:\n\nStyler enhancements\n^^^^^^^^^^^^^^^^^^^\n\nWe provided some focused development on :class:`.Styler`. See also the `Styler documentation <../user_guide/style.ipynb>`_\nwhich has been revised and improved (:issue:`39720`, :issue:`39317`, :issue:`40493`).\n\n - The method :meth:`.Styler.set_table_styles` can now accept more natural CSS language for arguments, such as ``'color:red;'`` instead of ``[('color', 'red')]`` (:issue:`39563`)\n - The methods :meth:`.Styler.highlight_null`, :meth:`.Styler.highlight_min`, and :meth:`.Styler.highlight_max` now allow custom CSS highlighting instead of the default background coloring (:issue:`40242`)\n - :meth:`.Styler.apply` now accepts functions that return an ``ndarray`` when ``axis=None``, making it now consistent with the ``axis=0`` and ``axis=1`` behavior (:issue:`39359`)\n - When incorrectly formatted CSS is given via :meth:`.Styler.apply` or :meth:`.Styler.applymap`, an error is now raised upon rendering (:issue:`39660`)\n - :meth:`.Styler.format` now accepts the keyword argument ``escape`` for optional HTML and LaTeX escaping (:issue:`40388`, :issue:`41619`)\n - :meth:`.Styler.background_gradient` has gained the argument ``gmap`` to supply a specific gradient map for shading (:issue:`22727`)\n - :meth:`.Styler.clear` now clears :attr:`Styler.hidden_index` and :attr:`Styler.hidden_columns` as well (:issue:`40484`)\n - Added the method :meth:`.Styler.highlight_between` (:issue:`39821`)\n - Added the method :meth:`.Styler.highlight_quantile` (:issue:`40926`)\n - Added the method :meth:`.Styler.text_gradient` (:issue:`41098`)\n - Added the method :meth:`.Styler.set_tooltips` to allow hover tooltips; this can be used enhance interactive displays (:issue:`21266`, :issue:`40284`)\n - Added the parameter ``precision`` to the method :meth:`.Styler.format` to control the display of floating point numbers (:issue:`40134`)\n - :class:`.Styler` rendered HTML output now follows the `w3 HTML Style Guide <https://www.w3schools.com/html/html5_syntax.asp>`_ (:issue:`39626`)\n - Many features of the :class:`.Styler` class are now either partially or fully usable on a DataFrame with a non-unique indexes or columns (:issue:`41143`)\n - One has greater control of the display through separate sparsification of the index or columns using the :ref:`new styler options <options.available>`, which are also usable via :func:`option_context` (:issue:`41142`)\n - Added the option ``styler.render.max_elements`` to avoid browser overload when styling large DataFrames (:issue:`40712`)\n - Added the method :meth:`.Styler.to_latex` (:issue:`21673`, :issue:`42320`), which also allows some limited CSS conversion (:issue:`40731`)\n - Added the method :meth:`.Styler.to_html` (:issue:`13379`)\n - Added the method :meth:`.Styler.set_sticky` to make index and column headers permanently visible in scrolling HTML frames (:issue:`29072`)\n\n.. _whatsnew_130.enhancements.dataframe_honors_copy_with_dict:\n\nDataFrame constructor honors ``copy=False`` with dict\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen passing a dictionary to :class:`DataFrame` with ``copy=False``,\na copy will no longer be made (:issue:`32960`).\n\n.. ipython:: python\n\n    arr = np.array([1, 2, 3])\n    df = pd.DataFrame({\"A\": arr, \"B\": arr.copy()}, copy=False)\n    df\n\n``df[\"A\"]`` remains a view on ``arr``:\n\n.. ipython:: python\n\n    arr[0] = 0\n    assert df.iloc[0, 0] == 0\n\nThe default behavior when not passing ``copy`` will remain unchanged, i.e.\na copy will be made.\n\n.. _whatsnew_130.enhancements.arrow_string:\n\nPyArrow backed string data type\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've enhanced the :class:`StringDtype`, an extension type dedicated to string data.\n(:issue:`39908`)\n\nIt is now possible to specify a ``storage`` keyword option to :class:`StringDtype`. Use\npandas options or specify the dtype using ``dtype='string[pyarrow]'`` to allow the\nStringArray to be backed by a PyArrow array instead of a NumPy array of Python objects.\n\nThe PyArrow backed StringArray requires pyarrow 1.0.0 or greater to be installed.\n\n.. warning::\n\n   ``string[pyarrow]`` is currently considered experimental. The implementation\n   and parts of the API may change without warning.\n\n.. ipython:: python\n\n   pd.Series(['abc', None, 'def'], dtype=pd.StringDtype(storage=\"pyarrow\"))\n\nYou can use the alias ``\"string[pyarrow]\"`` as well.\n\n.. ipython:: python\n\n   s = pd.Series(['abc', None, 'def'], dtype=\"string[pyarrow]\")\n   s\n\nYou can also create a PyArrow backed string array using pandas options.\n\n.. ipython:: python\n\n    with pd.option_context(\"string_storage\", \"pyarrow\"):\n        s = pd.Series(['abc', None, 'def'], dtype=\"string\")\n    s\n\nThe usual string accessor methods work. Where appropriate, the return type of the Series\nor columns of a DataFrame will also have string dtype.\n\n.. ipython:: python\n\n   s.str.upper()\n   s.str.split('b', expand=True).dtypes\n\nString accessor methods returning integers will return a value with :class:`Int64Dtype`\n\n.. ipython:: python\n\n   s.str.count(\"a\")\n\n.. _whatsnew_130.enhancements.centered_datetimelike_rolling_window:\n\nCentered datetime-like rolling windows\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen performing rolling calculations on DataFrame and Series\nobjects with a datetime-like index, a centered datetime-like window can now be\nused (:issue:`38780`).\nFor example:\n\n.. ipython:: python\n\n    df = pd.DataFrame(\n        {\"A\": [0, 1, 2, 3, 4]}, index=pd.date_range(\"2020\", periods=5, freq=\"1D\")\n    )\n    df\n    df.rolling(\"2D\", center=True).mean()\n\n\n.. _whatsnew_130.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n\n- :meth:`DataFrame.rolling`, :meth:`Series.rolling`, :meth:`DataFrame.expanding`, and :meth:`Series.expanding` now support a ``method`` argument with a ``'table'`` option that performs the windowing operation over an entire :class:`DataFrame`. See :ref:`Window Overview <window.overview>` for performance and functional benefits (:issue:`15095`, :issue:`38995`)\n- :class:`.ExponentialMovingWindow` now support a ``online`` method that can perform ``mean`` calculations in an online fashion. See :ref:`Window Overview <window.overview>` (:issue:`41673`)\n- Added :meth:`MultiIndex.dtypes` (:issue:`37062`)\n- Added ``end`` and ``end_day`` options for the ``origin`` argument in :meth:`DataFrame.resample` (:issue:`37804`)\n- Improved error message when ``usecols`` and ``names`` do not match for :func:`read_csv` and ``engine=\"c\"`` (:issue:`29042`)\n- Improved consistency of error messages when passing an invalid ``win_type`` argument in :ref:`Window methods <api.window>` (:issue:`15969`)\n- :func:`read_sql_query` now accepts a ``dtype`` argument to cast the columnar data from the SQL database based on user input (:issue:`10285`)\n- :func:`read_csv` now raising ``ParserWarning`` if length of header or given names does not match length of data when ``usecols`` is not specified (:issue:`21768`)\n- Improved integer type mapping from pandas to SQLAlchemy when using :meth:`DataFrame.to_sql` (:issue:`35076`)\n- :func:`to_numeric` now supports downcasting of nullable ``ExtensionDtype`` objects (:issue:`33013`)\n- Added support for dict-like names in :class:`MultiIndex.set_names` and :class:`MultiIndex.rename` (:issue:`20421`)\n- :func:`read_excel` can now auto-detect .xlsb files and older .xls files (:issue:`35416`, :issue:`41225`)\n- :class:`ExcelWriter` now accepts an ``if_sheet_exists`` parameter to control the behavior of append mode when writing to existing sheets (:issue:`40230`)\n- :meth:`.Rolling.sum`, :meth:`.Expanding.sum`, :meth:`.Rolling.mean`, :meth:`.Expanding.mean`, :meth:`.ExponentialMovingWindow.mean`, :meth:`.Rolling.median`, :meth:`.Expanding.median`, :meth:`.Rolling.max`, :meth:`.Expanding.max`, :meth:`.Rolling.min`, and :meth:`.Expanding.min` now support `Numba <http://numba.pydata.org/>`_ execution with the ``engine`` keyword (:issue:`38895`, :issue:`41267`)\n- :meth:`DataFrame.apply` can now accept NumPy unary operators as strings, e.g. ``df.apply(\"sqrt\")``, which was already the case for :meth:`Series.apply` (:issue:`39116`)\n- :meth:`DataFrame.apply` can now accept non-callable DataFrame properties as strings, e.g. ``df.apply(\"size\")``, which was already the case for :meth:`Series.apply` (:issue:`39116`)\n- :meth:`DataFrame.applymap` can now accept kwargs to pass on to the user-provided ``func`` (:issue:`39987`)\n- Passing a :class:`DataFrame` indexer to ``iloc`` is now disallowed for :meth:`Series.__getitem__` and :meth:`DataFrame.__getitem__` (:issue:`39004`)\n- :meth:`Series.apply` can now accept list-like or dictionary-like arguments that aren't lists or dictionaries, e.g. ``ser.apply(np.array([\"sum\", \"mean\"]))``, which was already the case for :meth:`DataFrame.apply` (:issue:`39140`)\n- :meth:`DataFrame.plot.scatter` can now accept a categorical column for the argument ``c`` (:issue:`12380`, :issue:`31357`)\n- :meth:`Series.loc` now raises a helpful error message when the Series has a :class:`MultiIndex` and the indexer has too many dimensions (:issue:`35349`)\n- :func:`read_stata` now supports reading data from compressed files (:issue:`26599`)\n- Added support for parsing ``ISO 8601``-like timestamps with negative signs to :class:`Timedelta` (:issue:`37172`)\n- Added support for unary operators in :class:`FloatingArray` (:issue:`38749`)\n- :class:`RangeIndex` can now be constructed by passing a ``range`` object directly e.g. ``pd.RangeIndex(range(3))`` (:issue:`12067`)\n- :meth:`Series.round` and :meth:`DataFrame.round` now work with nullable integer and floating dtypes (:issue:`38844`)\n- :meth:`read_csv` and :meth:`read_json` expose the argument ``encoding_errors`` to control how encoding errors are handled (:issue:`39450`)\n- :meth:`.DataFrameGroupBy.any`, :meth:`.SeriesGroupBy.any`, :meth:`.DataFrameGroupBy.all`, and :meth:`.SeriesGroupBy.all` use Kleene logic with nullable data types (:issue:`37506`)\n- :meth:`.DataFrameGroupBy.any`, :meth:`.SeriesGroupBy.any`, :meth:`.DataFrameGroupBy.all`, and :meth:`.SeriesGroupBy.all` return a ``BooleanDtype`` for columns with nullable data types (:issue:`33449`)\n- :meth:`.DataFrameGroupBy.any`, :meth:`.SeriesGroupBy.any`, :meth:`.DataFrameGroupBy.all`, and :meth:`.SeriesGroupBy.all` raising with ``object`` data containing ``pd.NA`` even when ``skipna=True`` (:issue:`37501`)\n- :meth:`.DataFrameGroupBy.rank` and :meth:`.SeriesGroupBy.rank` now supports object-dtype data (:issue:`38278`)\n- Constructing a :class:`DataFrame` or :class:`Series` with the ``data`` argument being a Python iterable that is *not* a NumPy ``ndarray`` consisting of NumPy scalars will now result in a dtype with a precision the maximum of the NumPy scalars; this was already the case when ``data`` is a NumPy ``ndarray`` (:issue:`40908`)\n- Add keyword ``sort`` to :func:`pivot_table` to allow non-sorting of the result (:issue:`39143`)\n- Add keyword ``dropna`` to :meth:`DataFrame.value_counts` to allow counting rows that include ``NA`` values (:issue:`41325`)\n- :meth:`Series.replace` will now cast results to ``PeriodDtype`` where possible instead of ``object`` dtype (:issue:`41526`)\n- Improved error message in ``corr`` and ``cov`` methods on :class:`.Rolling`, :class:`.Expanding`, and :class:`.ExponentialMovingWindow` when ``other`` is not a :class:`DataFrame` or :class:`Series` (:issue:`41741`)\n- :meth:`Series.between` can now accept ``left`` or ``right`` as arguments to ``inclusive`` to include only the left or right boundary (:issue:`40245`)\n- :meth:`DataFrame.explode` now supports exploding multiple columns. Its ``column`` argument now also accepts a list of str or tuples for exploding on multiple columns at the same time (:issue:`39240`)\n- :meth:`DataFrame.sample` now accepts the ``ignore_index`` argument to reset the index after sampling, similar to :meth:`DataFrame.drop_duplicates` and :meth:`DataFrame.sort_values` (:issue:`38581`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_130.notable_bug_fixes:\n\nNotable bug fixes\n~~~~~~~~~~~~~~~~~\n\nThese are bug fixes that might have notable behavior changes.\n\n.. _whatsnew_130.notable_bug_fixes.categorical_unique_maintains_dtype:\n\n``Categorical.unique`` now always maintains same dtype as original\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously, when calling :meth:`Categorical.unique` with categorical data, unused categories in the new array\nwould be removed, making the dtype of the new array different than the\noriginal (:issue:`18291`)\n\nAs an example of this, given:\n\n.. ipython:: python\n\n        dtype = pd.CategoricalDtype(['bad', 'neutral', 'good'], ordered=True)\n        cat = pd.Categorical(['good', 'good', 'bad', 'bad'], dtype=dtype)\n        original = pd.Series(cat)\n        unique = original.unique()\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [1]: unique\n    ['good', 'bad']\n    Categories (2, object): ['bad' < 'good']\n    In [2]: original.dtype == unique.dtype\n    False\n\n*New behavior*:\n\n.. ipython:: python\n\n        unique\n        original.dtype == unique.dtype\n\n.. _whatsnew_130.notable_bug_fixes.combine_first_preserves_dtype:\n\nPreserve dtypes in :meth:`DataFrame.combine_first`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`DataFrame.combine_first` will now preserve dtypes (:issue:`7509`)\n\n.. ipython:: python\n\n   df1 = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [1, 2, 3]}, index=[0, 1, 2])\n   df1\n   df2 = pd.DataFrame({\"B\": [4, 5, 6], \"C\": [1, 2, 3]}, index=[2, 3, 4])\n   df2\n   combined = df1.combine_first(df2)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [1]: combined.dtypes\n   Out[2]:\n   A    float64\n   B    float64\n   C    float64\n   dtype: object\n\n*New behavior*:\n\n.. ipython:: python\n\n   combined.dtypes\n\n.. _whatsnew_130.notable_bug_fixes.groupby_preserves_dtype:\n\nGroupby methods agg and transform no longer changes return dtype for callables\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously the methods :meth:`.DataFrameGroupBy.aggregate`,\n:meth:`.SeriesGroupBy.aggregate`, :meth:`.DataFrameGroupBy.transform`, and\n:meth:`.SeriesGroupBy.transform` might cast the result dtype when the argument ``func``\nis callable, possibly leading to undesirable results (:issue:`21240`). The cast would\noccur if the result is numeric and casting back to the input dtype does not change any\nvalues as measured by ``np.allclose``. Now no such casting occurs.\n\n.. ipython:: python\n\n    df = pd.DataFrame({'key': [1, 1], 'a': [True, False], 'b': [True, True]})\n    df\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [5]: df.groupby('key').agg(lambda x: x.sum())\n    Out[5]:\n            a  b\n    key\n    1    True  2\n\n*New behavior*:\n\n.. ipython:: python\n\n    df.groupby('key').agg(lambda x: x.sum())\n\n.. _whatsnew_130.notable_bug_fixes.groupby_reductions_float_result:\n\n``float`` result for :meth:`.DataFrameGroupBy.mean`, :meth:`.DataFrameGroupBy.median`, and :meth:`.GDataFrameGroupBy.var`, :meth:`.SeriesGroupBy.mean`, :meth:`.SeriesGroupBy.median`, and :meth:`.SeriesGroupBy.var`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously, these methods could result in different dtypes depending on the input values.\nNow, these methods will always return a float dtype. (:issue:`41137`)\n\n.. ipython:: python\n\n    df = pd.DataFrame({'a': [True], 'b': [1], 'c': [1.0]})\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [5]: df.groupby(df.index).mean()\n    Out[5]:\n            a  b    c\n    0    True  1  1.0\n\n*New behavior*:\n\n.. ipython:: python\n\n    df.groupby(df.index).mean()\n\n.. _whatsnew_130.notable_bug_fixes.setitem_column_try_inplace:\n\nTry operating inplace when setting values with ``loc`` and ``iloc``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen setting an entire column using ``loc`` or ``iloc``, pandas will try to\ninsert the values into the existing data rather than create an entirely new array.\n\n.. ipython:: python\n\n   df = pd.DataFrame(range(3), columns=[\"A\"], dtype=\"float64\")\n   values = df.values\n   new = np.array([5, 6, 7], dtype=\"int64\")\n   df.loc[[0, 1, 2], \"A\"] = new\n\nIn both the new and old behavior, the data in ``values`` is overwritten, but in\nthe old behavior the dtype of ``df[\"A\"]`` changed to ``int64``.\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [1]: df.dtypes\n   Out[1]:\n   A    int64\n   dtype: object\n   In [2]: np.shares_memory(df[\"A\"].values, new)\n   Out[2]: False\n   In [3]: np.shares_memory(df[\"A\"].values, values)\n   Out[3]: False\n\nIn pandas 1.3.0, ``df`` continues to share data with ``values``\n\n*New behavior*:\n\n.. ipython:: python\n\n   df.dtypes\n   np.shares_memory(df[\"A\"], new)\n   np.shares_memory(df[\"A\"], values)\n\n\n.. _whatsnew_130.notable_bug_fixes.setitem_never_inplace:\n\nNever operate inplace when setting ``frame[keys] = values``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen setting multiple columns using ``frame[keys] = values`` new arrays will\nreplace pre-existing arrays for these keys, which will *not* be over-written\n(:issue:`39510`).  As a result, the columns will retain the dtype(s) of ``values``,\nnever casting to the dtypes of the existing arrays.\n\n.. ipython:: python\n\n   df = pd.DataFrame(range(3), columns=[\"A\"], dtype=\"float64\")\n   df[[\"A\"]] = 5\n\nIn the old behavior, ``5`` was cast to ``float64`` and inserted into the existing\narray backing ``df``:\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [1]: df.dtypes\n   Out[1]:\n   A    float64\n\nIn the new behavior, we get a new array, and retain an integer-dtyped ``5``:\n\n*New behavior*:\n\n.. ipython:: python\n\n   df.dtypes\n\n\n.. _whatsnew_130.notable_bug_fixes.setitem_with_bool_casting:\n\nConsistent casting with setting into Boolean Series\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSetting non-boolean values into a :class:`Series` with ``dtype=bool`` now consistently\ncasts to ``dtype=object`` (:issue:`38709`)\n\n.. code-block:: ipython\n\n   In [1]: orig = pd.Series([True, False])\n\n   In [2]: ser = orig.copy()\n\n   In [3]: ser.iloc[1] = np.nan\n\n   In [4]: ser2 = orig.copy()\n\n   In [5]: ser2.iloc[1] = 2.0\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [1]: ser\n   Out [1]:\n   0    1.0\n   1    NaN\n   dtype: float64\n\n   In [2]:ser2\n   Out [2]:\n   0    True\n   1     2.0\n   dtype: object\n\n*New behavior*:\n\n.. code-block:: ipython\n\n   In [1]: ser\n   Out [1]:\n   0    True\n   1     NaN\n   dtype: object\n\n   In [2]:ser2\n   Out [2]:\n   0    True\n   1     2.0\n   dtype: object\n\n\n.. _whatsnew_130.notable_bug_fixes.rolling_groupby_column:\n\nDataFrameGroupBy.rolling and SeriesGroupBy.rolling no longer return grouped-by column in values\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe group-by column will now be dropped from the result of a\n``groupby.rolling`` operation (:issue:`32262`)\n\n.. ipython:: python\n\n    df = pd.DataFrame({\"A\": [1, 1, 2, 3], \"B\": [0, 1, 2, 3]})\n    df\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [1]: df.groupby(\"A\").rolling(2).sum()\n    Out[1]:\n           A    B\n    A\n    1 0  NaN  NaN\n    1    2.0  1.0\n    2 2  NaN  NaN\n    3 3  NaN  NaN\n\n*New behavior*:\n\n.. ipython:: python\n\n    df.groupby(\"A\").rolling(2).sum()\n\n.. _whatsnew_130.notable_bug_fixes.rolling_var_precision:\n\nRemoved artificial truncation in rolling variance and standard deviation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`.Rolling.std` and :meth:`.Rolling.var` will no longer\nartificially truncate results that are less than ``~1e-8`` and ``~1e-15`` respectively to\nzero (:issue:`37051`, :issue:`40448`, :issue:`39872`).\n\nHowever, floating point artifacts may now exist in the results when rolling over larger values.\n\n.. ipython:: python\n\n   s = pd.Series([7, 5, 5, 5])\n   s.rolling(3).var()\n\n.. _whatsnew_130.notable_bug_fixes.rolling_groupby_multiindex:\n\nDataFrameGroupBy.rolling and SeriesGroupBy.rolling with MultiIndex no longer drop levels in the result\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`DataFrameGroupBy.rolling` and :meth:`SeriesGroupBy.rolling` will no longer drop levels of a :class:`DataFrame`\nwith a :class:`MultiIndex` in the result. This can lead to a perceived duplication of levels in the resulting\n:class:`MultiIndex`, but this change restores the behavior that was present in version 1.1.3 (:issue:`38787`, :issue:`38523`).\n\n\n.. ipython:: python\n\n   index = pd.MultiIndex.from_tuples([('idx1', 'idx2')], names=['label1', 'label2'])\n   df = pd.DataFrame({'a': [1], 'b': [2]}, index=index)\n   df\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [1]: df.groupby('label1').rolling(1).sum()\n    Out[1]:\n              a    b\n    label1\n    idx1    1.0  2.0\n\n*New behavior*:\n\n.. ipython:: python\n\n    df.groupby('label1').rolling(1).sum()\n\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_130.api_breaking:\n\nBackwards incompatible API changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_130.api_breaking.deps:\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSome minimum supported versions of dependencies were updated.\nIf installed, we now require:\n\n+-----------------+-----------------+----------+---------+\n| Package         | Minimum Version | Required | Changed |\n+=================+=================+==========+=========+\n| numpy           | 1.17.3          |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| pytz            | 2017.3          |    X     |         |\n+-----------------+-----------------+----------+---------+\n| python-dateutil | 2.7.3           |    X     |         |\n+-----------------+-----------------+----------+---------+\n| bottleneck      | 1.2.1           |          |         |\n+-----------------+-----------------+----------+---------+\n| numexpr         | 2.7.0           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| pytest (dev)    | 6.0             |          |    X    |\n+-----------------+-----------------+----------+---------+\n| mypy (dev)      | 0.812           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| setuptools      | 38.6.0          |          |    X    |\n+-----------------+-----------------+----------+---------+\n\nFor `optional libraries <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\nThe following table lists the lowest version per library that is currently being tested throughout the development of pandas.\nOptional libraries below the lowest tested version may still work, but are not considered supported.\n\n+-----------------+-----------------+---------+\n| Package         | Minimum Version | Changed |\n+=================+=================+=========+\n| beautifulsoup4  | 4.6.0           |         |\n+-----------------+-----------------+---------+\n| fastparquet     | 0.4.0           |    X    |\n+-----------------+-----------------+---------+\n| fsspec          | 0.7.4           |         |\n+-----------------+-----------------+---------+\n| gcsfs           | 0.6.0           |         |\n+-----------------+-----------------+---------+\n| lxml            | 4.3.0           |         |\n+-----------------+-----------------+---------+\n| matplotlib      | 2.2.3           |         |\n+-----------------+-----------------+---------+\n| numba           | 0.46.0          |         |\n+-----------------+-----------------+---------+\n| openpyxl        | 3.0.0           |    X    |\n+-----------------+-----------------+---------+\n| pyarrow         | 0.17.0          |    X    |\n+-----------------+-----------------+---------+\n| pymysql         | 0.8.1           |    X    |\n+-----------------+-----------------+---------+\n| pytables        | 3.5.1           |         |\n+-----------------+-----------------+---------+\n| s3fs            | 0.4.0           |         |\n+-----------------+-----------------+---------+\n| scipy           | 1.2.0           |         |\n+-----------------+-----------------+---------+\n| sqlalchemy      | 1.3.0           |    X    |\n+-----------------+-----------------+---------+\n| tabulate        | 0.8.7           |    X    |\n+-----------------+-----------------+---------+\n| xarray          | 0.12.0          |         |\n+-----------------+-----------------+---------+\n| xlrd            | 1.2.0           |         |\n+-----------------+-----------------+---------+\n| xlsxwriter      | 1.0.2           |         |\n+-----------------+-----------------+---------+\n| xlwt            | 1.3.0           |         |\n+-----------------+-----------------+---------+\n| pandas-gbq      | 0.12.0          |         |\n+-----------------+-----------------+---------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\n.. _whatsnew_130.api_breaking.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n- Partially initialized :class:`CategoricalDtype` objects (i.e. those with ``categories=None``) will no longer compare as equal to fully initialized dtype objects (:issue:`38516`)\n- Accessing ``_constructor_expanddim`` on a :class:`DataFrame` and ``_constructor_sliced`` on a :class:`Series` now raise an ``AttributeError``. Previously a ``NotImplementedError`` was raised (:issue:`38782`)\n- Added new ``engine`` and ``**engine_kwargs`` parameters to :meth:`DataFrame.to_sql` to support other future \"SQL engines\". Currently we still only use ``SQLAlchemy`` under the hood, but more engines are planned to be supported such as `turbodbc <https://turbodbc.readthedocs.io/en/latest/>`_ (:issue:`36893`)\n- Removed redundant ``freq`` from :class:`PeriodIndex` string representation (:issue:`41653`)\n- :meth:`ExtensionDtype.construct_array_type` is now a required method instead of an optional one for :class:`ExtensionDtype` subclasses (:issue:`24860`)\n- Calling ``hash`` on non-hashable pandas objects will now raise ``TypeError`` with the built-in error message (e.g. ``unhashable type: 'Series'``). Previously it would raise a custom message such as ``'Series' objects are mutable, thus they cannot be hashed``. Furthermore, ``isinstance(<Series>, abc.collections.Hashable)`` will now return ``False`` (:issue:`40013`)\n- :meth:`.Styler.from_custom_template` now has two new arguments for template names, and removed the old ``name``, due to template inheritance having been introducing for better parsing (:issue:`42053`). Subclassing modifications to Styler attributes are also needed.\n\n.. _whatsnew_130.api_breaking.build:\n\nBuild\n^^^^^\n- Documentation in ``.pptx`` and ``.pdf`` formats are no longer included in wheels or source distributions. (:issue:`30741`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_130.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\n.. _whatsnew_130.deprecations.nuisance_columns:\n\nDeprecated dropping nuisance columns in DataFrame reductions and DataFrameGroupBy operations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nCalling a reduction (e.g. ``.min``, ``.max``, ``.sum``) on a :class:`DataFrame` with\n``numeric_only=None`` (the default), columns where the reduction raises a ``TypeError``\nare silently ignored and dropped from the result.\n\nThis behavior is deprecated. In a future version, the ``TypeError`` will be raised,\nand users will need to select only valid columns before calling the function.\n\nFor example:\n\n.. ipython:: python\n\n   df = pd.DataFrame({\"A\": [1, 2, 3, 4], \"B\": pd.date_range(\"2016-01-01\", periods=4)})\n   df\n\n*Old behavior*:\n\n.. code-block:: ipython\n\n    In [3]: df.prod()\n    Out[3]:\n    Out[3]:\n    A    24\n    dtype: int64\n\n*Future behavior*:\n\n.. code-block:: ipython\n\n    In [4]: df.prod()\n    ...\n    TypeError: 'DatetimeArray' does not implement reduction 'prod'\n\n    In [5]: df[[\"A\"]].prod()\n    Out[5]:\n    A    24\n    dtype: int64\n\n\nSimilarly, when applying a function to :class:`DataFrameGroupBy`, columns on which\nthe function raises ``TypeError`` are currently silently ignored and dropped\nfrom the result.\n\nThis behavior is deprecated.  In a future version, the ``TypeError``\nwill be raised, and users will need to select only valid columns before calling\nthe function.\n\nFor example:\n\n.. ipython:: python\n\n   df = pd.DataFrame({\"A\": [1, 2, 3, 4], \"B\": pd.date_range(\"2016-01-01\", periods=4)})\n   gb = df.groupby([1, 1, 2, 2])\n\n*Old behavior*:\n\n.. code-block:: ipython\n\n    In [4]: gb.prod(numeric_only=False)\n    Out[4]:\n    A\n    1   2\n    2  12\n\n*Future behavior*:\n\n.. code-block:: ipython\n\n    In [5]: gb.prod(numeric_only=False)\n    ...\n    TypeError: datetime64 type does not support prod operations\n\n    In [6]: gb[[\"A\"]].prod(numeric_only=False)\n    Out[6]:\n        A\n    1   2\n    2  12\n\n.. _whatsnew_130.deprecations.other:\n\nOther Deprecations\n^^^^^^^^^^^^^^^^^^\n- Deprecated allowing scalars to be passed to the :class:`Categorical` constructor (:issue:`38433`)\n- Deprecated constructing :class:`CategoricalIndex` without passing list-like data (:issue:`38944`)\n- Deprecated allowing subclass-specific keyword arguments in the :class:`Index` constructor, use the specific subclass directly instead (:issue:`14093`, :issue:`21311`, :issue:`22315`, :issue:`26974`)\n- Deprecated the :meth:`astype` method of datetimelike (``timedelta64[ns]``, ``datetime64[ns]``, ``Datetime64TZDtype``, ``PeriodDtype``) to convert to integer dtypes, use ``values.view(...)`` instead (:issue:`38544`). This deprecation was later reverted in pandas 1.4.0.\n- Deprecated :meth:`MultiIndex.is_lexsorted` and :meth:`MultiIndex.lexsort_depth`, use :meth:`MultiIndex.is_monotonic_increasing` instead (:issue:`32259`)\n- Deprecated keyword ``try_cast`` in :meth:`Series.where`, :meth:`Series.mask`, :meth:`DataFrame.where`, :meth:`DataFrame.mask`; cast results manually if desired (:issue:`38836`)\n- Deprecated comparison of :class:`Timestamp` objects with ``datetime.date`` objects.  Instead of e.g. ``ts <= mydate`` use ``ts <= pd.Timestamp(mydate)`` or ``ts.date() <= mydate`` (:issue:`36131`)\n- Deprecated :attr:`Rolling.win_type` returning ``\"freq\"`` (:issue:`38963`)\n- Deprecated :attr:`Rolling.is_datetimelike` (:issue:`38963`)\n- Deprecated :class:`DataFrame` indexer for :meth:`Series.__setitem__` and :meth:`DataFrame.__setitem__` (:issue:`39004`)\n- Deprecated :meth:`ExponentialMovingWindow.vol` (:issue:`39220`)\n- Using ``.astype`` to convert between ``datetime64[ns]`` dtype and :class:`DatetimeTZDtype` is deprecated and will raise in a future version, use ``obj.tz_localize`` or ``obj.dt.tz_localize`` instead (:issue:`38622`)\n- Deprecated casting ``datetime.date`` objects to ``datetime64`` when used as ``fill_value`` in :meth:`DataFrame.unstack`, :meth:`DataFrame.shift`, :meth:`Series.shift`, and :meth:`DataFrame.reindex`, pass ``pd.Timestamp(dateobj)`` instead (:issue:`39767`)\n- Deprecated :meth:`.Styler.set_na_rep` and :meth:`.Styler.set_precision` in favor of :meth:`.Styler.format` with ``na_rep`` and ``precision`` as existing and new input arguments respectively (:issue:`40134`, :issue:`40425`)\n- Deprecated :meth:`.Styler.where` in favor of using an alternative formulation with :meth:`Styler.applymap` (:issue:`40821`)\n- Deprecated allowing partial failure in :meth:`Series.transform` and :meth:`DataFrame.transform` when ``func`` is list-like or dict-like and raises anything but ``TypeError``; ``func`` raising anything but a ``TypeError`` will raise in a future version (:issue:`40211`)\n- Deprecated arguments ``error_bad_lines`` and ``warn_bad_lines`` in :meth:`read_csv` and :meth:`read_table` in favor of argument ``on_bad_lines`` (:issue:`15122`)\n- Deprecated support for ``np.ma.mrecords.MaskedRecords`` in the :class:`DataFrame` constructor, pass ``{name: data[name] for name in data.dtype.names}`` instead (:issue:`40363`)\n- Deprecated using :func:`merge`, :meth:`DataFrame.merge`, and :meth:`DataFrame.join` on a different number of levels (:issue:`34862`)\n- Deprecated the use of ``**kwargs`` in :class:`.ExcelWriter`; use the keyword argument ``engine_kwargs`` instead (:issue:`40430`)\n- Deprecated the ``level`` keyword for :class:`DataFrame` and :class:`Series` aggregations; use groupby instead (:issue:`39983`)\n- Deprecated the ``inplace`` parameter of :meth:`Categorical.remove_categories`, :meth:`Categorical.add_categories`, :meth:`Categorical.reorder_categories`, :meth:`Categorical.rename_categories`, :meth:`Categorical.set_categories` and will be removed in a future version (:issue:`37643`)\n- Deprecated :func:`merge` producing duplicated columns through the ``suffixes`` keyword  and already existing columns (:issue:`22818`)\n- Deprecated setting :attr:`Categorical._codes`, create a new :class:`Categorical` with the desired codes instead (:issue:`40606`)\n- Deprecated the ``convert_float`` optional argument in :func:`read_excel` and :meth:`ExcelFile.parse` (:issue:`41127`)\n- Deprecated behavior of :meth:`DatetimeIndex.union` with mixed timezones; in a future version both will be cast to UTC instead of object dtype (:issue:`39328`)\n- Deprecated using ``usecols`` with out of bounds indices for :func:`read_csv` with ``engine=\"c\"`` (:issue:`25623`)\n- Deprecated special treatment of lists with first element a Categorical in the :class:`DataFrame` constructor; pass as ``pd.DataFrame({col: categorical, ...})`` instead (:issue:`38845`)\n- Deprecated behavior of :class:`DataFrame` constructor when a ``dtype`` is passed and the data cannot be cast to that dtype. In a future version, this will raise instead of being silently ignored (:issue:`24435`)\n- Deprecated the :attr:`Timestamp.freq` attribute.  For the properties that use it (``is_month_start``, ``is_month_end``, ``is_quarter_start``, ``is_quarter_end``, ``is_year_start``, ``is_year_end``), when you have a ``freq``, use e.g. ``freq.is_month_start(ts)`` (:issue:`15146`)\n- Deprecated construction of :class:`Series` or :class:`DataFrame` with ``DatetimeTZDtype`` data and ``datetime64[ns]`` dtype.  Use ``Series(data).dt.tz_localize(None)`` instead (:issue:`41555`, :issue:`33401`)\n- Deprecated behavior of :class:`Series` construction with large-integer values and small-integer dtype silently overflowing; use ``Series(data).astype(dtype)`` instead (:issue:`41734`)\n- Deprecated behavior of :class:`DataFrame` construction with floating data and integer dtype casting even when lossy; in a future version this will remain floating, matching :class:`Series` behavior (:issue:`41770`)\n- Deprecated inference of ``timedelta64[ns]``, ``datetime64[ns]``, or ``DatetimeTZDtype`` dtypes in :class:`Series` construction when data containing strings is passed and no ``dtype`` is passed (:issue:`33558`)\n- In a future version, constructing :class:`Series` or :class:`DataFrame` with ``datetime64[ns]`` data and ``DatetimeTZDtype`` will treat the data as wall-times instead of as UTC times (matching DatetimeIndex behavior). To treat the data as UTC times, use ``pd.Series(data).dt.tz_localize(\"UTC\").dt.tz_convert(dtype.tz)`` or ``pd.Series(data.view(\"int64\"), dtype=dtype)`` (:issue:`33401`)\n- Deprecated passing lists as ``key`` to :meth:`DataFrame.xs` and :meth:`Series.xs` (:issue:`41760`)\n- Deprecated boolean arguments of ``inclusive`` in :meth:`Series.between` to have ``{\"left\", \"right\", \"neither\", \"both\"}`` as standard argument values (:issue:`40628`)\n- Deprecated passing arguments as positional for all of the following, with exceptions noted (:issue:`41485`):\n\n  - :func:`concat` (other than ``objs``)\n  - :func:`read_csv` (other than ``filepath_or_buffer``)\n  - :func:`read_table` (other than ``filepath_or_buffer``)\n  - :meth:`DataFrame.clip` and :meth:`Series.clip` (other than ``upper`` and ``lower``)\n  - :meth:`DataFrame.drop_duplicates` (except for ``subset``), :meth:`Series.drop_duplicates`, :meth:`Index.drop_duplicates` and :meth:`MultiIndex.drop_duplicates`\n  - :meth:`DataFrame.drop` (other than ``labels``) and :meth:`Series.drop`\n  - :meth:`DataFrame.dropna` and :meth:`Series.dropna`\n  - :meth:`DataFrame.ffill`, :meth:`Series.ffill`, :meth:`DataFrame.bfill`, and :meth:`Series.bfill`\n  - :meth:`DataFrame.fillna` and :meth:`Series.fillna` (apart from ``value``)\n  - :meth:`DataFrame.interpolate` and :meth:`Series.interpolate` (other than ``method``)\n  - :meth:`DataFrame.mask` and :meth:`Series.mask` (other than ``cond`` and ``other``)\n  - :meth:`DataFrame.reset_index` (other than ``level``) and :meth:`Series.reset_index`\n  - :meth:`DataFrame.set_axis` and :meth:`Series.set_axis` (other than ``labels``)\n  - :meth:`DataFrame.set_index` (other than ``keys``)\n  - :meth:`DataFrame.sort_index` and :meth:`Series.sort_index`\n  - :meth:`DataFrame.sort_values` (other than ``by``) and :meth:`Series.sort_values`\n  - :meth:`DataFrame.where` and :meth:`Series.where` (other than ``cond`` and ``other``)\n  - :meth:`Index.set_names` and :meth:`MultiIndex.set_names` (except for ``names``)\n  - :meth:`MultiIndex.codes` (except for ``codes``)\n  - :meth:`MultiIndex.set_levels` (except for ``levels``)\n  - :meth:`Resampler.interpolate` (other than ``method``)\n\n\n.. ---------------------------------------------------------------------------\n\n\n.. _whatsnew_130.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- Performance improvement in :meth:`IntervalIndex.isin` (:issue:`38353`)\n- Performance improvement in :meth:`Series.mean` for nullable data types (:issue:`34814`)\n- Performance improvement in :meth:`Series.isin` for nullable data types (:issue:`38340`)\n- Performance improvement in :meth:`DataFrame.fillna` with ``method=\"pad\"`` or ``method=\"backfill\"`` for nullable floating and nullable integer dtypes (:issue:`39953`)\n- Performance improvement in :meth:`DataFrame.corr` for ``method=kendall`` (:issue:`28329`)\n- Performance improvement in :meth:`DataFrame.corr` for ``method=spearman`` (:issue:`40956`, :issue:`41885`)\n- Performance improvement in :meth:`.Rolling.corr` and :meth:`.Rolling.cov` (:issue:`39388`)\n- Performance improvement in :meth:`.RollingGroupby.corr`, :meth:`.ExpandingGroupby.corr`, :meth:`.ExpandingGroupby.corr` and :meth:`.ExpandingGroupby.cov` (:issue:`39591`)\n- Performance improvement in :func:`unique` for object data type (:issue:`37615`)\n- Performance improvement in :func:`json_normalize` for basic cases (including separators) (:issue:`40035` :issue:`15621`)\n- Performance improvement in :class:`.ExpandingGroupby` aggregation methods (:issue:`39664`)\n- Performance improvement in :class:`.Styler` where render times are more than 50% reduced and now matches :meth:`DataFrame.to_html` (:issue:`39972` :issue:`39952`, :issue:`40425`)\n- The method :meth:`.Styler.set_td_classes` is now as performant as :meth:`.Styler.apply` and :meth:`.Styler.applymap`, and even more so in some cases (:issue:`40453`)\n- Performance improvement in :meth:`.ExponentialMovingWindow.mean` with ``times`` (:issue:`39784`)\n- Performance improvement in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` when requiring the Python fallback implementation (:issue:`40176`)\n- Performance improvement in the conversion of a PyArrow Boolean array to a pandas nullable Boolean array (:issue:`41051`)\n- Performance improvement for concatenation of data with type :class:`CategoricalDtype` (:issue:`40193`)\n- Performance improvement in :meth:`.DataFrameGroupBy.cummin`, :meth:`.SeriesGroupBy.cummin`, :meth:`.DataFrameGroupBy.cummax`, and :meth:`.SeriesGroupBy.cummax` with nullable data types (:issue:`37493`)\n- Performance improvement in :meth:`Series.nunique` with nan values (:issue:`40865`)\n- Performance improvement in :meth:`DataFrame.transpose`, :meth:`Series.unstack` with ``DatetimeTZDtype`` (:issue:`40149`)\n- Performance improvement in :meth:`Series.plot` and :meth:`DataFrame.plot` with entry point lazy loading (:issue:`41492`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_130.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n- Bug in :class:`CategoricalIndex` incorrectly failing to raise ``TypeError`` when scalar data is passed (:issue:`38614`)\n- Bug in ``CategoricalIndex.reindex`` failed when the :class:`Index` passed was not categorical but whose values were all labels in the category (:issue:`28690`)\n- Bug where constructing a :class:`Categorical` from an object-dtype array of ``date`` objects did not round-trip correctly with ``astype`` (:issue:`38552`)\n- Bug in constructing a :class:`DataFrame` from an ``ndarray`` and a :class:`CategoricalDtype` (:issue:`38857`)\n- Bug in setting categorical values into an object-dtype column in a :class:`DataFrame` (:issue:`39136`)\n- Bug in :meth:`DataFrame.reindex` was raising an ``IndexError`` when the new index contained duplicates and the old index was a :class:`CategoricalIndex` (:issue:`38906`)\n- Bug in :meth:`Categorical.fillna` with a tuple-like category raising ``NotImplementedError`` instead of ``ValueError`` when filling with a non-category tuple (:issue:`41914`)\n\nDatetimelike\n^^^^^^^^^^^^\n- Bug in :class:`DataFrame` and :class:`Series` constructors sometimes dropping nanoseconds from :class:`Timestamp` (resp. :class:`Timedelta`) ``data``, with ``dtype=datetime64[ns]`` (resp. ``timedelta64[ns]``) (:issue:`38032`)\n- Bug in :meth:`DataFrame.first` and :meth:`Series.first` with an offset of one month returning an incorrect result when the first day is the last day of a month (:issue:`29623`)\n- Bug in constructing a :class:`DataFrame` or :class:`Series` with mismatched ``datetime64`` data and ``timedelta64`` dtype, or vice-versa, failing to raise a ``TypeError`` (:issue:`38575`, :issue:`38764`, :issue:`38792`)\n- Bug in constructing a :class:`Series` or :class:`DataFrame` with a ``datetime`` object out of bounds for ``datetime64[ns]`` dtype or a ``timedelta`` object out of bounds for ``timedelta64[ns]`` dtype (:issue:`38792`, :issue:`38965`)\n- Bug in :meth:`DatetimeIndex.intersection`, :meth:`DatetimeIndex.symmetric_difference`, :meth:`PeriodIndex.intersection`, :meth:`PeriodIndex.symmetric_difference` always returning object-dtype when operating with :class:`CategoricalIndex` (:issue:`38741`)\n- Bug in :meth:`DatetimeIndex.intersection` giving incorrect results with non-Tick frequencies with ``n != 1`` (:issue:`42104`)\n- Bug in :meth:`Series.where` incorrectly casting ``datetime64`` values to ``int64`` (:issue:`37682`)\n- Bug in :class:`Categorical` incorrectly typecasting ``datetime`` object to ``Timestamp`` (:issue:`38878`)\n- Bug in comparisons between :class:`Timestamp` object and ``datetime64`` objects just outside the implementation bounds for nanosecond ``datetime64`` (:issue:`39221`)\n- Bug in :meth:`Timestamp.round`, :meth:`Timestamp.floor`, :meth:`Timestamp.ceil` for values near the implementation bounds of :class:`Timestamp` (:issue:`39244`)\n- Bug in :meth:`Timedelta.round`, :meth:`Timedelta.floor`, :meth:`Timedelta.ceil` for values near the implementation bounds of :class:`Timedelta` (:issue:`38964`)\n- Bug in :func:`date_range` incorrectly creating :class:`DatetimeIndex` containing ``NaT`` instead of raising ``OutOfBoundsDatetime`` in corner cases (:issue:`24124`)\n- Bug in :func:`infer_freq` incorrectly fails to infer 'H' frequency of :class:`DatetimeIndex` if the latter has a timezone and crosses DST boundaries (:issue:`39556`)\n- Bug in :class:`Series` backed by :class:`DatetimeArray` or :class:`TimedeltaArray` sometimes failing to set the array's ``freq`` to ``None`` (:issue:`41425`)\n\nTimedelta\n^^^^^^^^^\n- Bug in constructing :class:`Timedelta` from ``np.timedelta64`` objects with non-nanosecond units that are out of bounds for ``timedelta64[ns]`` (:issue:`38965`)\n- Bug in constructing a :class:`TimedeltaIndex` incorrectly accepting ``np.datetime64(\"NaT\")`` objects (:issue:`39462`)\n- Bug in constructing :class:`Timedelta` from an input string with only symbols and no digits failed to raise an error (:issue:`39710`)\n- Bug in :class:`TimedeltaIndex` and :func:`to_timedelta` failing to raise when passed non-nanosecond ``timedelta64`` arrays that overflow when converting to ``timedelta64[ns]`` (:issue:`40008`)\n\nTimezones\n^^^^^^^^^\n- Bug in different ``tzinfo`` objects representing UTC not being treated as equivalent (:issue:`39216`)\n- Bug in ``dateutil.tz.gettz(\"UTC\")`` not being recognized as equivalent to other UTC-representing tzinfos (:issue:`39276`)\n\nNumeric\n^^^^^^^\n- Bug in :meth:`DataFrame.quantile`, :meth:`DataFrame.sort_values` causing incorrect subsequent indexing behavior (:issue:`38351`)\n- Bug in :meth:`DataFrame.sort_values` raising an :class:`IndexError` for empty ``by`` (:issue:`40258`)\n- Bug in :meth:`DataFrame.select_dtypes` with ``include=np.number`` would drop numeric ``ExtensionDtype`` columns (:issue:`35340`)\n- Bug in :meth:`DataFrame.mode` and :meth:`Series.mode` not keeping consistent integer :class:`Index` for empty input (:issue:`33321`)\n- Bug in :meth:`DataFrame.rank` when the DataFrame contained ``np.inf`` (:issue:`32593`)\n- Bug in :meth:`DataFrame.rank` with ``axis=0`` and columns holding incomparable types raising an ``IndexError`` (:issue:`38932`)\n- Bug in :meth:`Series.rank`, :meth:`DataFrame.rank`, :meth:`.DataFrameGroupBy.rank`, and :meth:`.SeriesGroupBy.rank` treating the most negative ``int64`` value as missing (:issue:`32859`)\n- Bug in :meth:`DataFrame.select_dtypes` different behavior between Windows and Linux with ``include=\"int\"`` (:issue:`36596`)\n- Bug in :meth:`DataFrame.apply` and :meth:`DataFrame.agg` when passed the argument ``func=\"size\"`` would operate on the entire ``DataFrame`` instead of rows or columns (:issue:`39934`)\n- Bug in :meth:`DataFrame.transform` would raise a ``SpecificationError`` when passed a dictionary and columns were missing; will now raise a ``KeyError`` instead (:issue:`40004`)\n- Bug in :meth:`.DataFrameGroupBy.rank` and :meth:`.SeriesGroupBy.rank` giving incorrect results with ``pct=True`` and equal values between consecutive groups (:issue:`40518`)\n- Bug in :meth:`Series.count` would result in an ``int32`` result on 32-bit platforms when argument ``level=None`` (:issue:`40908`)\n- Bug in :class:`Series` and :class:`DataFrame` reductions with methods ``any`` and ``all`` not returning Boolean results for object data (:issue:`12863`, :issue:`35450`, :issue:`27709`)\n- Bug in :meth:`Series.clip` would fail if the Series contains NA values and has nullable int or float as a data type (:issue:`40851`)\n- Bug in :meth:`UInt64Index.where` and :meth:`UInt64Index.putmask` with an ``np.int64`` dtype ``other`` incorrectly raising ``TypeError`` (:issue:`41974`)\n- Bug in :meth:`DataFrame.agg()` not sorting the aggregated axis in the order of the provided aggregation functions when one or more aggregation function fails to produce results (:issue:`33634`)\n- Bug in :meth:`DataFrame.clip` not interpreting missing values as no threshold (:issue:`40420`)\n\nConversion\n^^^^^^^^^^\n- Bug in :meth:`Series.to_dict` with ``orient='records'`` now returns Python native types (:issue:`25969`)\n- Bug in :meth:`Series.view` and :meth:`Index.view` when converting between datetime-like (``datetime64[ns]``, ``datetime64[ns, tz]``, ``timedelta64``, ``period``) dtypes (:issue:`39788`)\n- Bug in creating a :class:`DataFrame` from an empty ``np.recarray`` not retaining the original dtypes (:issue:`40121`)\n- Bug in :class:`DataFrame` failing to raise a ``TypeError`` when constructing from a ``frozenset`` (:issue:`40163`)\n- Bug in :class:`Index` construction silently ignoring a passed ``dtype`` when the data cannot be cast to that dtype (:issue:`21311`)\n- Bug in :meth:`StringArray.astype` falling back to NumPy and raising when converting to ``dtype='categorical'`` (:issue:`40450`)\n- Bug in :func:`factorize` where, when given an array with a numeric NumPy dtype lower than int64, uint64 and float64, the unique values did not keep their original dtype (:issue:`41132`)\n- Bug in :class:`DataFrame` construction with a dictionary containing an array-like with ``ExtensionDtype`` and ``copy=True`` failing to make a copy (:issue:`38939`)\n- Bug in :meth:`qcut` raising error when taking ``Float64DType`` as input (:issue:`40730`)\n- Bug in :class:`DataFrame` and :class:`Series` construction with ``datetime64[ns]`` data and ``dtype=object`` resulting in ``datetime`` objects instead of :class:`Timestamp` objects (:issue:`41599`)\n- Bug in :class:`DataFrame` and :class:`Series` construction with ``timedelta64[ns]`` data and ``dtype=object`` resulting in ``np.timedelta64`` objects instead of :class:`Timedelta` objects (:issue:`41599`)\n- Bug in :class:`DataFrame` construction when given a two-dimensional object-dtype ``np.ndarray`` of :class:`Period` or :class:`Interval` objects failing to cast to :class:`PeriodDtype` or :class:`IntervalDtype`, respectively (:issue:`41812`)\n- Bug in constructing a :class:`Series` from a list and a :class:`PandasDtype` (:issue:`39357`)\n- Bug in creating a :class:`Series` from a ``range`` object that does not fit in the bounds of ``int64`` dtype (:issue:`30173`)\n- Bug in creating a :class:`Series` from a ``dict`` with all-tuple keys and an :class:`Index` that requires reindexing (:issue:`41707`)\n- Bug in :func:`.infer_dtype` not recognizing Series, Index, or array with a Period dtype (:issue:`23553`)\n- Bug in :func:`.infer_dtype` raising an error for general :class:`.ExtensionArray` objects. It will now return ``\"unknown-array\"`` instead of raising (:issue:`37367`)\n- Bug in :meth:`DataFrame.convert_dtypes` incorrectly raised a ``ValueError`` when called on an empty DataFrame (:issue:`40393`)\n\nStrings\n^^^^^^^\n- Bug in the conversion from ``pyarrow.ChunkedArray`` to :class:`~arrays.StringArray` when the original had zero chunks (:issue:`41040`)\n- Bug in :meth:`Series.replace` and :meth:`DataFrame.replace` ignoring replacements with ``regex=True`` for ``StringDType`` data (:issue:`41333`, :issue:`35977`)\n- Bug in :meth:`Series.str.extract` with :class:`~arrays.StringArray` returning object dtype for an empty :class:`DataFrame` (:issue:`41441`)\n- Bug in :meth:`Series.str.replace` where the ``case`` argument was ignored when ``regex=False`` (:issue:`41602`)\n\nInterval\n^^^^^^^^\n- Bug in :meth:`IntervalIndex.intersection` and :meth:`IntervalIndex.symmetric_difference` always returning object-dtype when operating with :class:`CategoricalIndex` (:issue:`38653`, :issue:`38741`)\n- Bug in :meth:`IntervalIndex.intersection` returning duplicates when at least one of the :class:`Index` objects have duplicates which are present in the other (:issue:`38743`)\n- :meth:`IntervalIndex.union`, :meth:`IntervalIndex.intersection`, :meth:`IntervalIndex.difference`, and :meth:`IntervalIndex.symmetric_difference` now cast to the appropriate dtype instead of raising a ``TypeError`` when operating with another :class:`IntervalIndex` with incompatible dtype (:issue:`39267`)\n- :meth:`PeriodIndex.union`, :meth:`PeriodIndex.intersection`, :meth:`PeriodIndex.symmetric_difference`, :meth:`PeriodIndex.difference` now cast to object dtype instead of raising ``IncompatibleFrequency`` when operating with another :class:`PeriodIndex` with incompatible dtype (:issue:`39306`)\n- Bug in :meth:`IntervalIndex.is_monotonic`, :meth:`IntervalIndex.get_loc`, :meth:`IntervalIndex.get_indexer_for`, and :meth:`IntervalIndex.__contains__` when NA values are present (:issue:`41831`)\n\nIndexing\n^^^^^^^^\n- Bug in :meth:`Index.union` and :meth:`MultiIndex.union` dropping duplicate ``Index`` values when ``Index`` was not monotonic or ``sort`` was set to ``False`` (:issue:`36289`, :issue:`31326`, :issue:`40862`)\n- Bug in :meth:`CategoricalIndex.get_indexer` failing to raise ``InvalidIndexError`` when non-unique (:issue:`38372`)\n- Bug in :meth:`IntervalIndex.get_indexer` when ``target`` has ``CategoricalDtype`` and both the index and the target contain NA values (:issue:`41934`)\n- Bug in :meth:`Series.loc` raising a ``ValueError`` when input was filtered with a Boolean list and values to set were a list with lower dimension (:issue:`20438`)\n- Bug in inserting many new columns into a :class:`DataFrame` causing incorrect subsequent indexing behavior (:issue:`38380`)\n- Bug in :meth:`DataFrame.__setitem__` raising a ``ValueError`` when setting multiple values to duplicate columns (:issue:`15695`)\n- Bug in :meth:`DataFrame.loc`, :meth:`Series.loc`, :meth:`DataFrame.__getitem__` and :meth:`Series.__getitem__` returning incorrect elements for non-monotonic :class:`DatetimeIndex` for string slices (:issue:`33146`)\n- Bug in :meth:`DataFrame.reindex` and :meth:`Series.reindex` with timezone aware indexes raising a ``TypeError`` for ``method=\"ffill\"`` and ``method=\"bfill\"`` and specified ``tolerance`` (:issue:`38566`)\n- Bug in :meth:`DataFrame.reindex` with ``datetime64[ns]`` or ``timedelta64[ns]`` incorrectly casting to integers when the ``fill_value`` requires casting to object dtype (:issue:`39755`)\n- Bug in :meth:`DataFrame.__setitem__` raising a ``ValueError`` when setting on an empty :class:`DataFrame` using specified columns and a nonempty :class:`DataFrame` value (:issue:`38831`)\n- Bug in :meth:`DataFrame.loc.__setitem__` raising a ``ValueError`` when operating on a unique column when the :class:`DataFrame` has duplicate columns (:issue:`38521`)\n- Bug in :meth:`DataFrame.iloc.__setitem__` and :meth:`DataFrame.loc.__setitem__` with mixed dtypes when setting with a dictionary value (:issue:`38335`)\n- Bug in :meth:`Series.loc.__setitem__` and :meth:`DataFrame.loc.__setitem__` raising ``KeyError`` when provided a Boolean generator (:issue:`39614`)\n- Bug in :meth:`Series.iloc` and :meth:`DataFrame.iloc` raising a ``KeyError`` when provided a generator (:issue:`39614`)\n- Bug in :meth:`DataFrame.__setitem__` not raising a ``ValueError`` when the right hand side is a :class:`DataFrame` with wrong number of columns (:issue:`38604`)\n- Bug in :meth:`Series.__setitem__` raising a ``ValueError`` when setting a :class:`Series` with a scalar indexer (:issue:`38303`)\n- Bug in :meth:`DataFrame.loc` dropping levels of a :class:`MultiIndex` when the :class:`DataFrame` used as input has only one row (:issue:`10521`)\n- Bug in :meth:`DataFrame.__getitem__` and :meth:`Series.__getitem__` always raising ``KeyError`` when slicing with existing strings where the :class:`Index` has milliseconds (:issue:`33589`)\n- Bug in setting ``timedelta64`` or ``datetime64`` values into numeric :class:`Series` failing to cast to object dtype (:issue:`39086`, :issue:`39619`)\n- Bug in setting :class:`Interval` values into a :class:`Series` or :class:`DataFrame` with mismatched :class:`IntervalDtype` incorrectly casting the new values to the existing dtype (:issue:`39120`)\n- Bug in setting ``datetime64`` values into a :class:`Series` with integer-dtype incorrectly casting the datetime64 values to integers (:issue:`39266`)\n- Bug in setting ``np.datetime64(\"NaT\")`` into a :class:`Series` with :class:`Datetime64TZDtype` incorrectly treating the timezone-naive value as timezone-aware (:issue:`39769`)\n- Bug in :meth:`Index.get_loc` not raising ``KeyError`` when ``key=NaN`` and ``method`` is specified but ``NaN`` is not in the :class:`Index` (:issue:`39382`)\n- Bug in :meth:`DatetimeIndex.insert` when inserting ``np.datetime64(\"NaT\")`` into a timezone-aware index incorrectly treating the timezone-naive value as timezone-aware (:issue:`39769`)\n- Bug in incorrectly raising in :meth:`Index.insert`, when setting a new column that cannot be held in the existing ``frame.columns``, or in :meth:`Series.reset_index` or :meth:`DataFrame.reset_index` instead of casting to a compatible dtype (:issue:`39068`)\n- Bug in :meth:`RangeIndex.append` where a single object of length 1 was concatenated incorrectly (:issue:`39401`)\n- Bug in :meth:`RangeIndex.astype` where when converting to :class:`CategoricalIndex`, the categories became a :class:`Int64Index` instead of a :class:`RangeIndex` (:issue:`41263`)\n- Bug in setting ``numpy.timedelta64`` values into an object-dtype :class:`Series` using a Boolean indexer (:issue:`39488`)\n- Bug in setting numeric values into a into a boolean-dtypes :class:`Series` using ``at`` or ``iat`` failing to cast to object-dtype (:issue:`39582`)\n- Bug in :meth:`DataFrame.__setitem__` and :meth:`DataFrame.iloc.__setitem__` raising ``ValueError`` when trying to index with a row-slice and setting a list as values (:issue:`40440`)\n- Bug in :meth:`DataFrame.loc` not raising ``KeyError`` when the key was not found in :class:`MultiIndex` and the levels were not fully specified (:issue:`41170`)\n- Bug in :meth:`DataFrame.loc.__setitem__` when setting-with-expansion incorrectly raising when the index in the expanding axis contained duplicates (:issue:`40096`)\n- Bug in :meth:`DataFrame.loc.__getitem__` with :class:`MultiIndex` casting to float when at least one index column has float dtype and we retrieve a scalar (:issue:`41369`)\n- Bug in :meth:`DataFrame.loc` incorrectly matching non-Boolean index elements (:issue:`20432`)\n- Bug in indexing with ``np.nan`` on a :class:`Series` or :class:`DataFrame` with a :class:`CategoricalIndex` incorrectly raising ``KeyError`` when ``np.nan`` keys are present (:issue:`41933`)\n- Bug in :meth:`Series.__delitem__` with ``ExtensionDtype`` incorrectly casting to ``ndarray`` (:issue:`40386`)\n- Bug in :meth:`DataFrame.at` with a :class:`CategoricalIndex` returning incorrect results when passed integer keys (:issue:`41846`)\n- Bug in :meth:`DataFrame.loc` returning a :class:`MultiIndex` in the wrong order if an indexer has duplicates (:issue:`40978`)\n- Bug in :meth:`DataFrame.__setitem__` raising a ``TypeError`` when using a ``str`` subclass as the column name with a :class:`DatetimeIndex` (:issue:`37366`)\n- Bug in :meth:`PeriodIndex.get_loc` failing to raise a ``KeyError`` when given a :class:`Period` with a mismatched ``freq`` (:issue:`41670`)\n- Bug ``.loc.__getitem__`` with a :class:`UInt64Index` and negative-integer keys raising ``OverflowError`` instead of ``KeyError`` in some cases, wrapping around to positive integers in others (:issue:`41777`)\n- Bug in :meth:`Index.get_indexer` failing to raise ``ValueError`` in some cases with invalid ``method``, ``limit``, or ``tolerance`` arguments (:issue:`41918`)\n- Bug when slicing a :class:`Series` or :class:`DataFrame` with a :class:`TimedeltaIndex` when passing an invalid string raising ``ValueError`` instead of a ``TypeError`` (:issue:`41821`)\n- Bug in :class:`Index` constructor sometimes silently ignoring a specified ``dtype`` (:issue:`38879`)\n- :meth:`Index.where` behavior now mirrors :meth:`Index.putmask` behavior, i.e. ``index.where(mask, other)`` matches ``index.putmask(~mask, other)`` (:issue:`39412`)\n\nMissing\n^^^^^^^\n- Bug in :class:`Grouper` did not correctly propagate the ``dropna`` argument; :meth:`.DataFrameGroupBy.transform` now correctly handles missing values for ``dropna=True`` (:issue:`35612`)\n- Bug in :func:`isna`, :meth:`Series.isna`, :meth:`Index.isna`, :meth:`DataFrame.isna`, and the corresponding ``notna`` functions not recognizing ``Decimal(\"NaN\")`` objects (:issue:`39409`)\n- Bug in :meth:`DataFrame.fillna` not accepting a dictionary for the ``downcast`` keyword (:issue:`40809`)\n- Bug in :func:`isna` not returning a copy of the mask for nullable types, causing any subsequent mask modification to change the original array (:issue:`40935`)\n- Bug in :class:`DataFrame` construction with float data containing ``NaN`` and an integer ``dtype`` casting instead of retaining the ``NaN`` (:issue:`26919`)\n- Bug in :meth:`Series.isin` and :meth:`MultiIndex.isin` didn't treat all nans as equivalent if they were in tuples (:issue:`41836`)\n\nMultiIndex\n^^^^^^^^^^\n- Bug in :meth:`DataFrame.drop` raising a ``TypeError`` when the :class:`MultiIndex` is non-unique and ``level`` is not provided (:issue:`36293`)\n- Bug in :meth:`MultiIndex.intersection` duplicating ``NaN`` in the result (:issue:`38623`)\n- Bug in :meth:`MultiIndex.equals` incorrectly returning ``True`` when the :class:`MultiIndex` contained ``NaN`` even when they are differently ordered (:issue:`38439`)\n- Bug in :meth:`MultiIndex.intersection` always returning an empty result when intersecting with :class:`CategoricalIndex` (:issue:`38653`)\n- Bug in :meth:`MultiIndex.difference` incorrectly raising ``TypeError`` when indexes contain non-sortable entries (:issue:`41915`)\n- Bug in :meth:`MultiIndex.reindex` raising a ``ValueError`` when used on an empty :class:`MultiIndex` and indexing only a specific level (:issue:`41170`)\n- Bug in :meth:`MultiIndex.reindex` raising ``TypeError`` when reindexing against a flat :class:`Index` (:issue:`41707`)\n\nI/O\n^^^\n- Bug in :meth:`Index.__repr__` when ``display.max_seq_items=1`` (:issue:`38415`)\n- Bug in :func:`read_csv` not recognizing scientific notation if the argument ``decimal`` is set and ``engine=\"python\"`` (:issue:`31920`)\n- Bug in :func:`read_csv` interpreting ``NA`` value as comment, when ``NA`` does contain the comment string fixed for ``engine=\"python\"`` (:issue:`34002`)\n- Bug in :func:`read_csv` raising an ``IndexError`` with multiple header columns and ``index_col`` is specified when the file has no data rows (:issue:`38292`)\n- Bug in :func:`read_csv` not accepting ``usecols`` with a different length than ``names`` for ``engine=\"python\"`` (:issue:`16469`)\n- Bug in :meth:`read_csv` returning object dtype when ``delimiter=\",\"`` with ``usecols`` and ``parse_dates`` specified for ``engine=\"python\"`` (:issue:`35873`)\n- Bug in :func:`read_csv` raising a ``TypeError`` when ``names`` and ``parse_dates`` is specified for ``engine=\"c\"`` (:issue:`33699`)\n- Bug in :func:`read_clipboard` and :func:`DataFrame.to_clipboard` not working in WSL (:issue:`38527`)\n- Allow custom error values for the ``parse_dates`` argument of :func:`read_sql`, :func:`read_sql_query` and :func:`read_sql_table` (:issue:`35185`)\n- Bug in :meth:`DataFrame.to_hdf` and :meth:`Series.to_hdf` raising a ``KeyError`` when trying to apply for subclasses of ``DataFrame`` or ``Series`` (:issue:`33748`)\n- Bug in :meth:`.HDFStore.put` raising a wrong ``TypeError`` when saving a DataFrame with non-string dtype (:issue:`34274`)\n- Bug in :func:`json_normalize` resulting in the first element of a generator object not being included in the returned DataFrame (:issue:`35923`)\n- Bug in :func:`read_csv` applying the thousands separator to date columns when the column should be parsed for dates and ``usecols`` is specified for ``engine=\"python\"`` (:issue:`39365`)\n- Bug in :func:`read_excel` forward filling :class:`MultiIndex` names when multiple header and index columns are specified (:issue:`34673`)\n- Bug in :func:`read_excel` not respecting :func:`set_option` (:issue:`34252`)\n- Bug in :func:`read_csv` not switching ``true_values`` and ``false_values`` for nullable Boolean dtype (:issue:`34655`)\n- Bug in :func:`read_json` when ``orient=\"split\"`` not maintaining a numeric string index (:issue:`28556`)\n- :meth:`read_sql` returned an empty generator if ``chunksize`` was non-zero and the query returned no results. Now returns a generator with a single empty DataFrame (:issue:`34411`)\n- Bug in :func:`read_hdf` returning unexpected records when filtering on categorical string columns using the ``where`` parameter (:issue:`39189`)\n- Bug in :func:`read_sas` raising a ``ValueError`` when ``datetimes`` were null (:issue:`39725`)\n- Bug in :func:`read_excel` dropping empty values from single-column spreadsheets (:issue:`39808`)\n- Bug in :func:`read_excel` loading trailing empty rows/columns for some filetypes (:issue:`41167`)\n- Bug in :func:`read_excel` raising an ``AttributeError`` when the excel file had a ``MultiIndex`` header followed by two empty rows and no index (:issue:`40442`)\n- Bug in :func:`read_excel`, :func:`read_csv`, :func:`read_table`, :func:`read_fwf`, and :func:`read_clipboard` where one blank row after a ``MultiIndex`` header with no index would be dropped (:issue:`40442`)\n- Bug in :meth:`DataFrame.to_string` misplacing the truncation column when ``index=False`` (:issue:`40904`)\n- Bug in :meth:`DataFrame.to_string` adding an extra dot and misaligning the truncation row when ``index=False`` (:issue:`40904`)\n- Bug in :func:`read_orc` always raising an ``AttributeError`` (:issue:`40918`)\n- Bug in :func:`read_csv` and :func:`read_table` silently ignoring ``prefix`` if ``names`` and ``prefix`` are defined, now raising a ``ValueError`` (:issue:`39123`)\n- Bug in :func:`read_csv` and :func:`read_excel` not respecting the dtype for a duplicated column name when ``mangle_dupe_cols`` is set to ``True`` (:issue:`35211`)\n- Bug in :func:`read_csv` silently ignoring ``sep`` if ``delimiter`` and ``sep`` are defined, now raising a ``ValueError`` (:issue:`39823`)\n- Bug in :func:`read_csv` and :func:`read_table` misinterpreting arguments when ``sys.setprofile`` had been previously called (:issue:`41069`)\n- Bug in the conversion from PyArrow to pandas (e.g. for reading Parquet) with nullable dtypes and a PyArrow array whose data buffer size is not a multiple of the dtype size (:issue:`40896`)\n- Bug in :func:`read_excel` would raise an error when pandas could not determine the file type even though the user specified the ``engine`` argument (:issue:`41225`)\n- Bug in :func:`read_clipboard` copying from an excel file shifts values into the wrong column if there are null values in first column (:issue:`41108`)\n- Bug in :meth:`DataFrame.to_hdf` and :meth:`Series.to_hdf` raising a ``TypeError`` when trying to append a string column to an incompatible column (:issue:`41897`)\n\nPeriod\n^^^^^^\n- Comparisons of :class:`Period` objects or :class:`Index`, :class:`Series`, or :class:`DataFrame` with mismatched ``PeriodDtype`` now behave like other mismatched-type comparisons, returning ``False`` for equals, ``True`` for not-equal, and raising ``TypeError`` for inequality checks (:issue:`39274`)\n\nPlotting\n^^^^^^^^\n- Bug in :func:`plotting.scatter_matrix` raising when 2d ``ax`` argument passed (:issue:`16253`)\n- Prevent warnings when Matplotlib's ``constrained_layout`` is enabled (:issue:`25261`)\n- Bug in :func:`DataFrame.plot` was showing the wrong colors in the legend if the function was called repeatedly and some calls used ``yerr`` while others didn't (:issue:`39522`)\n- Bug in :func:`DataFrame.plot` was showing the wrong colors in the legend if the function was called repeatedly and some calls used ``secondary_y`` and others use ``legend=False`` (:issue:`40044`)\n- Bug in :meth:`DataFrame.plot.box` when ``dark_background`` theme was selected, caps or min/max markers for the plot were not visible (:issue:`40769`)\n\nGroupby/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n- Bug in :meth:`.DataFrameGroupBy.agg` and :meth:`.SeriesGroupBy.agg` with :class:`PeriodDtype` columns incorrectly casting results too aggressively (:issue:`38254`)\n- Bug in :meth:`.SeriesGroupBy.value_counts` where unobserved categories in a grouped categorical Series were not tallied (:issue:`38672`)\n- Bug in :meth:`.SeriesGroupBy.value_counts` where an error was raised on an empty Series (:issue:`39172`)\n- Bug in :meth:`.GroupBy.indices` would contain non-existent indices when null values were present in the groupby keys (:issue:`9304`)\n- Fixed bug in :meth:`.DataFrameGroupBy.sum` and :meth:`.SeriesGroupBy.sum` causing a loss of precision by now using Kahan summation (:issue:`38778`)\n- Fixed bug in :meth:`.DataFrameGroupBy.cumsum`, :meth:`.SeriesGroupBy.cumsum`, :meth:`.DataFrameGroupBy.mean`, and :meth:`.SeriesGroupBy.mean` causing loss of precision through using Kahan summation (:issue:`38934`)\n- Bug in :meth:`.Resampler.aggregate` and :meth:`DataFrame.transform` raising a ``TypeError`` instead of ``SpecificationError`` when missing keys had mixed dtypes (:issue:`39025`)\n- Bug in :meth:`.DataFrameGroupBy.idxmin` and :meth:`.DataFrameGroupBy.idxmax` with ``ExtensionDtype`` columns (:issue:`38733`)\n- Bug in :meth:`Series.resample` would raise when the index was a :class:`PeriodIndex` consisting of ``NaT`` (:issue:`39227`)\n- Bug in :meth:`.RollingGroupby.corr` and :meth:`.ExpandingGroupby.corr` where the groupby column would return ``0`` instead of ``np.nan`` when providing ``other`` that was longer than each group (:issue:`39591`)\n- Bug in :meth:`.ExpandingGroupby.corr` and :meth:`.ExpandingGroupby.cov` where ``1`` would be returned instead of ``np.nan`` when providing ``other`` that was longer than each group (:issue:`39591`)\n- Bug in :meth:`.DataFrameGroupBy.mean`, :meth:`.SeriesGroupBy.mean`, :meth:`.DataFrameGroupBy.median`, :meth:`.SeriesGroupBy.median`, and :meth:`DataFrame.pivot_table` not propagating metadata (:issue:`28283`)\n- Bug in :meth:`Series.rolling` and :meth:`DataFrame.rolling` not calculating window bounds correctly when window is an offset and dates are in descending order (:issue:`40002`)\n- Bug in :meth:`Series.groupby` and :meth:`DataFrame.groupby` on an empty ``Series`` or ``DataFrame`` would lose index, columns, and/or data types when directly using the methods ``idxmax``, ``idxmin``, ``mad``, ``min``, ``max``, ``sum``, ``prod``, and ``skew`` or using them through ``apply``, ``aggregate``, or ``resample`` (:issue:`26411`)\n- Bug in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` where a :class:`MultiIndex` would be created instead of an :class:`Index` when used on a :class:`.RollingGroupby` object (:issue:`39732`)\n- Bug in :meth:`.DataFrameGroupBy.sample` where an error was raised when ``weights`` was specified and the index was an :class:`Int64Index` (:issue:`39927`)\n- Bug in :meth:`.DataFrameGroupBy.aggregate` and :meth:`.Resampler.aggregate` would sometimes raise a ``SpecificationError`` when passed a dictionary and columns were missing; will now always raise a ``KeyError`` instead (:issue:`40004`)\n- Bug in :meth:`.DataFrameGroupBy.sample` where column selection was not applied before computing the result (:issue:`39928`)\n- Bug in :class:`.ExponentialMovingWindow` when calling ``__getitem__`` would incorrectly raise a ``ValueError`` when providing ``times`` (:issue:`40164`)\n- Bug in :class:`.ExponentialMovingWindow` when calling ``__getitem__`` would not retain ``com``, ``span``, ``alpha`` or ``halflife`` attributes  (:issue:`40164`)\n- :class:`.ExponentialMovingWindow` now raises a ``NotImplementedError`` when specifying ``times`` with ``adjust=False`` due to an incorrect calculation (:issue:`40098`)\n- Bug in :meth:`.ExponentialMovingWindowGroupby.mean` where the ``times`` argument was ignored when ``engine='numba'`` (:issue:`40951`)\n- Bug in :meth:`.ExponentialMovingWindowGroupby.mean` where the wrong times were used the in case of multiple groups (:issue:`40951`)\n- Bug in :class:`.ExponentialMovingWindowGroupby` where the times vector and values became out of sync for non-trivial groups (:issue:`40951`)\n- Bug in :meth:`Series.asfreq` and :meth:`DataFrame.asfreq` dropping rows when the index was not sorted (:issue:`39805`)\n- Bug in aggregation functions for :class:`DataFrame` not respecting ``numeric_only`` argument when ``level`` keyword was given (:issue:`40660`)\n- Bug in :meth:`.SeriesGroupBy.aggregate` where using a user-defined function to aggregate a Series with an object-typed :class:`Index` causes an incorrect :class:`Index` shape (:issue:`40014`)\n- Bug in :class:`.RollingGroupby` where ``as_index=False`` argument in ``groupby`` was ignored (:issue:`39433`)\n- Bug in :meth:`.DataFrameGroupBy.any`, :meth:`.SeriesGroupBy.any`, :meth:`.DataFrameGroupBy.all` and :meth:`.SeriesGroupBy.all` raising a ``ValueError`` when using with nullable type columns holding ``NA`` even with ``skipna=True`` (:issue:`40585`)\n- Bug in :meth:`.DataFrameGroupBy.cummin`, :meth:`.SeriesGroupBy.cummin`, :meth:`.DataFrameGroupBy.cummax` and :meth:`.SeriesGroupBy.cummax` incorrectly rounding integer values near the ``int64`` implementations bounds (:issue:`40767`)\n- Bug in :meth:`.DataFrameGroupBy.rank` and :meth:`.SeriesGroupBy.rank` with nullable dtypes incorrectly raising a ``TypeError`` (:issue:`41010`)\n- Bug in :meth:`.DataFrameGroupBy.cummin`, :meth:`.SeriesGroupBy.cummin`, :meth:`.DataFrameGroupBy.cummax` and :meth:`.SeriesGroupBy.cummax` computing wrong result with nullable data types too large to roundtrip when casting to float (:issue:`37493`)\n- Bug in :meth:`DataFrame.rolling` returning mean zero for all ``NaN`` window with ``min_periods=0`` if calculation is not numerical stable (:issue:`41053`)\n- Bug in :meth:`DataFrame.rolling` returning sum not zero for all ``NaN`` window with ``min_periods=0`` if calculation is not numerical stable (:issue:`41053`)\n- Bug in :meth:`.SeriesGroupBy.agg` failing to retain ordered :class:`CategoricalDtype` on order-preserving aggregations (:issue:`41147`)\n- Bug in :meth:`.DataFrameGroupBy.min`, :meth:`.SeriesGroupBy.min`, :meth:`.DataFrameGroupBy.max` and :meth:`.SeriesGroupBy.max` with multiple object-dtype columns and ``numeric_only=False`` incorrectly raising a ``ValueError`` (:issue:`41111`)\n- Bug in :meth:`.DataFrameGroupBy.rank` with the GroupBy object's ``axis=0`` and the ``rank`` method's keyword ``axis=1`` (:issue:`41320`)\n- Bug in :meth:`DataFrameGroupBy.__getitem__` with non-unique columns incorrectly returning a malformed :class:`SeriesGroupBy` instead of :class:`DataFrameGroupBy` (:issue:`41427`)\n- Bug in :meth:`.DataFrameGroupBy.transform` with non-unique columns incorrectly raising an ``AttributeError`` (:issue:`41427`)\n- Bug in :meth:`.Resampler.apply` with non-unique columns incorrectly dropping duplicated columns (:issue:`41445`)\n- Bug in :meth:`Series.groupby` aggregations incorrectly returning empty :class:`Series` instead of raising ``TypeError`` on aggregations that are invalid for its dtype, e.g. ``.prod`` with ``datetime64[ns]`` dtype (:issue:`41342`)\n- Bug in :class:`DataFrameGroupBy` aggregations incorrectly failing to drop columns with invalid dtypes for that aggregation when there are no valid columns (:issue:`41291`)\n- Bug in :meth:`DataFrame.rolling.__iter__` where ``on`` was not assigned to the index of the resulting objects (:issue:`40373`)\n- Bug in :meth:`.DataFrameGroupBy.transform` and :meth:`.DataFrameGroupBy.agg` with ``engine=\"numba\"`` where ``*args`` were being cached with the user passed function (:issue:`41647`)\n- Bug in :class:`DataFrameGroupBy` methods ``agg``, ``transform``, ``sum``, ``bfill``, ``ffill``, ``pad``, ``pct_change``, ``shift``, ``ohlc`` dropping ``.columns.names`` (:issue:`41497`)\n\n\nReshaping\n^^^^^^^^^\n- Bug in :func:`merge` raising error when performing an inner join with partial index and ``right_index=True`` when there was no overlap between indices (:issue:`33814`)\n- Bug in :meth:`DataFrame.unstack` with missing levels led to incorrect index names (:issue:`37510`)\n- Bug in :func:`merge_asof` propagating the right Index with ``left_index=True`` and ``right_on`` specification instead of left Index (:issue:`33463`)\n- Bug in :meth:`DataFrame.join` on a DataFrame with a :class:`MultiIndex` returned the wrong result when one of both indexes had only one level (:issue:`36909`)\n- :func:`merge_asof` now raises a ``ValueError`` instead of a cryptic ``TypeError`` in case of non-numerical merge columns (:issue:`29130`)\n- Bug in :meth:`DataFrame.join` not assigning values correctly when the DataFrame had a :class:`MultiIndex` where at least one dimension had dtype ``Categorical`` with non-alphabetically sorted categories (:issue:`38502`)\n- :meth:`Series.value_counts` and :meth:`Series.mode` now return consistent keys in original order (:issue:`12679`, :issue:`11227` and :issue:`39007`)\n- Bug in :meth:`DataFrame.stack` not handling ``NaN`` in :class:`MultiIndex` columns correctly (:issue:`39481`)\n- Bug in :meth:`DataFrame.apply` would give incorrect results when the argument ``func`` was a string, ``axis=1``, and the axis argument was not supported; now raises a ``ValueError`` instead (:issue:`39211`)\n- Bug in :meth:`DataFrame.sort_values` not reshaping the index correctly after sorting on columns when ``ignore_index=True`` (:issue:`39464`)\n- Bug in :meth:`DataFrame.append` returning incorrect dtypes with combinations of ``ExtensionDtype`` dtypes (:issue:`39454`)\n- Bug in :meth:`DataFrame.append` returning incorrect dtypes when used with combinations of ``datetime64`` and ``timedelta64`` dtypes (:issue:`39574`)\n- Bug in :meth:`DataFrame.append` with a :class:`DataFrame` with a :class:`MultiIndex` and appending a :class:`Series` whose :class:`Index` is not a :class:`MultiIndex` (:issue:`41707`)\n- Bug in :meth:`DataFrame.pivot_table` returning a :class:`MultiIndex` for a single value when operating on an empty DataFrame (:issue:`13483`)\n- :class:`Index` can now be passed to the :func:`numpy.all` function (:issue:`40180`)\n- Bug in :meth:`DataFrame.stack` not preserving ``CategoricalDtype`` in a :class:`MultiIndex` (:issue:`36991`)\n- Bug in :func:`to_datetime` raising an error when the input sequence contained unhashable items (:issue:`39756`)\n- Bug in :meth:`Series.explode` preserving the index when ``ignore_index`` was ``True`` and values were scalars (:issue:`40487`)\n- Bug in :func:`to_datetime` raising a ``ValueError`` when :class:`Series` contains ``None`` and ``NaT`` and has more than 50 elements (:issue:`39882`)\n- Bug in :meth:`Series.unstack` and :meth:`DataFrame.unstack` with object-dtype values containing timezone-aware datetime objects incorrectly raising ``TypeError`` (:issue:`41875`)\n- Bug in :meth:`DataFrame.melt` raising ``InvalidIndexError`` when :class:`DataFrame` has duplicate columns used as ``value_vars`` (:issue:`41951`)\n\nSparse\n^^^^^^\n- Bug in :meth:`DataFrame.sparse.to_coo` raising a ``KeyError`` with columns that are a numeric :class:`Index` without a ``0`` (:issue:`18414`)\n- Bug in :meth:`SparseArray.astype` with ``copy=False`` producing incorrect results when going from integer dtype to floating dtype (:issue:`34456`)\n- Bug in :meth:`SparseArray.max` and :meth:`SparseArray.min` would always return an empty result (:issue:`40921`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n- Bug in :meth:`DataFrame.where` when ``other`` is a Series with an :class:`ExtensionDtype` (:issue:`38729`)\n- Fixed bug where :meth:`Series.idxmax`, :meth:`Series.idxmin`, :meth:`Series.argmax`, and :meth:`Series.argmin` would fail when the underlying data is an :class:`ExtensionArray` (:issue:`32749`, :issue:`33719`, :issue:`36566`)\n- Fixed bug where some properties of subclasses of :class:`PandasExtensionDtype` where improperly cached (:issue:`40329`)\n- Bug in :meth:`DataFrame.mask` where masking a DataFrame with an :class:`ExtensionDtype` raises a ``ValueError`` (:issue:`40941`)\n\nStyler\n^^^^^^\n- Bug in :class:`.Styler` where the ``subset`` argument in methods raised an error for some valid MultiIndex slices (:issue:`33562`)\n- :class:`.Styler` rendered HTML output has seen minor alterations to support w3 good code standards (:issue:`39626`)\n- Bug in :class:`.Styler` where rendered HTML was missing a column class identifier for certain header cells (:issue:`39716`)\n- Bug in :meth:`.Styler.background_gradient` where text-color was not determined correctly (:issue:`39888`)\n- Bug in :meth:`.Styler.set_table_styles` where multiple elements in CSS-selectors of the ``table_styles`` argument were not correctly added (:issue:`34061`)\n- Bug in :class:`.Styler` where copying from Jupyter dropped the top left cell and misaligned headers (:issue:`12147`)\n- Bug in :class:`Styler.where` where ``kwargs`` were not passed to the applicable callable (:issue:`40845`)\n- Bug in :class:`.Styler` causing CSS to duplicate on multiple renders (:issue:`39395`, :issue:`40334`)\n\nOther\n^^^^^\n- ``inspect.getmembers(Series)`` no longer raises an ``AbstractMethodError`` (:issue:`38782`)\n- Bug in :meth:`Series.where` with numeric dtype and ``other=None`` not casting to ``nan`` (:issue:`39761`)\n- Bug in :func:`.assert_series_equal`, :func:`.assert_frame_equal`, :func:`.assert_index_equal` and :func:`.assert_extension_array_equal` incorrectly raising when an attribute has an unrecognized NA type (:issue:`39461`)\n- Bug in :func:`.assert_index_equal` with ``exact=True`` not raising when comparing :class:`CategoricalIndex` instances with ``Int64Index`` and ``RangeIndex`` categories (:issue:`41263`)\n- Bug in :meth:`DataFrame.equals`, :meth:`Series.equals`, and :meth:`Index.equals` with object-dtype containing ``np.datetime64(\"NaT\")`` or ``np.timedelta64(\"NaT\")`` (:issue:`39650`)\n- Bug in :func:`show_versions` where console JSON output was not proper JSON (:issue:`39701`)\n- pandas can now compile on z/OS when using `xlc <https://www.ibm.com/products/xl-cpp-compiler-zos>`_ (:issue:`35826`)\n- Bug in :func:`pandas.util.hash_pandas_object` not recognizing ``hash_key``, ``encoding`` and ``categorize`` when the input object type is a :class:`DataFrame` (:issue:`41404`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_130.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.2.5..v1.3.0\n", "1.1.5": ".. _whatsnew_115:\n\nWhat's new in 1.1.5 (December 07, 2020)\n---------------------------------------\n\nThese are the changes in pandas 1.1.5. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_115.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in addition of a timedelta-like scalar to a :class:`DatetimeIndex` raising incorrectly (:issue:`37295`)\n- Fixed regression in :meth:`Series.groupby` raising when the :class:`Index` of the :class:`Series` had a tuple as its name (:issue:`37755`)\n- Fixed regression in :meth:`DataFrame.loc` and :meth:`Series.loc` for ``__setitem__`` when one-dimensional tuple was given to select from :class:`MultiIndex` (:issue:`37711`)\n- Fixed regression in inplace operations on :class:`Series` with ``ExtensionDtype`` with NumPy dtyped operand (:issue:`37910`)\n- Fixed regression in metadata propagation for ``groupby`` iterator (:issue:`37343`)\n- Fixed regression in :class:`MultiIndex` constructed from a :class:`DatetimeIndex` not retaining frequency (:issue:`35563`)\n- Fixed regression in :class:`Index` constructor raising a ``AttributeError`` when passed a :class:`SparseArray` with datetime64 values (:issue:`35843`)\n- Fixed regression in :meth:`DataFrame.unstack` with columns with integer dtype (:issue:`37115`)\n- Fixed regression in indexing on a :class:`Series` with ``CategoricalDtype`` after unpickling (:issue:`37631`)\n- Fixed regression in :meth:`DataFrame.groupby` aggregation with out-of-bounds datetime objects in an object-dtype column (:issue:`36003`)\n- Fixed regression in ``df.groupby(..).rolling(..)`` with the resulting :class:`MultiIndex` when grouping by a label that is in the index (:issue:`37641`)\n- Fixed regression in :meth:`DataFrame.fillna` not filling ``NaN`` after other operations such as :meth:`DataFrame.pivot` (:issue:`36495`).\n- Fixed performance regression in ``df.groupby(..).rolling(..)`` (:issue:`38038`)\n- Fixed regression in :meth:`MultiIndex.intersection` returning duplicates when at least one of the indexes had duplicates (:issue:`36915`)\n- Fixed regression in :meth:`.DataFrameGroupBy.first`, :meth:`.SeriesGroupBy.first`, :meth:`.DataFrameGroupBy.last`, and :meth:`.SeriesGroupBy.last` where ``None`` was considered a non-NA value (:issue:`38286`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_115.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in pytables methods in python 3.9 (:issue:`38041`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_115.other:\n\nOther\n~~~~~\n- Only set ``-Werror`` as a compiler flag in the CI jobs (:issue:`33315`, :issue:`33314`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_115.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.1.4..v1.1.5|HEAD\n", "1.4.4": ".. _whatsnew_144:\n\nWhat's new in 1.4.4 (August 31, 2022)\n-------------------------------------\n\nThese are the changes in pandas 1.4.4. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_144.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`DataFrame.fillna` not working on a :class:`DataFrame` with a :class:`MultiIndex` (:issue:`47649`)\n- Fixed regression in taking NULL :class:`objects` from a :class:`DataFrame` causing a segmentation violation. These NULL values are created by :meth:`numpy.empty_like` (:issue:`46848`)\n- Fixed regression in :func:`concat` materializing the :class:`Index` during sorting even if the :class:`Index` was already sorted (:issue:`47501`)\n- Fixed regression in :func:`concat` or :func:`merge` handling of all-NaN ExtensionArrays with custom attributes (:issue:`47762`)\n- Fixed regression in calling bitwise numpy ufuncs (for example, ``np.bitwise_and``) on Index objects (:issue:`46769`)\n- Fixed regression in :func:`cut` when using a ``datetime64`` IntervalIndex as bins (:issue:`46218`)\n- Fixed regression in :meth:`DataFrame.select_dtypes` where ``include=\"number\"`` included :class:`BooleanDtype` (:issue:`46870`)\n- Fixed regression in :meth:`DataFrame.loc` raising error when indexing with a ``NamedTuple`` (:issue:`48124`)\n- Fixed regression in :meth:`DataFrame.loc` not updating the cache correctly after values were set (:issue:`47867`)\n- Fixed regression in :meth:`DataFrame.loc` not aligning index in some cases when setting a :class:`DataFrame` (:issue:`47578`)\n- Fixed regression in :meth:`DataFrame.loc` setting a length-1 array like value to a single value in the DataFrame (:issue:`46268`)\n- Fixed regression when slicing with :meth:`DataFrame.loc` with :class:`DatetimeIndex` with a :class:`.DateOffset` object for its ``freq`` (:issue:`46671`)\n- Fixed regression in setting ``None`` or non-string value into a ``string``-dtype Series using a mask (:issue:`47628`)\n- Fixed regression in updating a DataFrame column through Series ``__setitem__`` (using chained assignment) not updating column values inplace and using too much memory (:issue:`47172`)\n- Fixed regression in :meth:`DataFrame.select_dtypes` returning a view on the original DataFrame (:issue:`48090`)\n- Fixed regression using custom Index subclasses (for example, used in xarray) with :meth:`~DataFrame.reset_index` or :meth:`Index.insert` (:issue:`47071`)\n- Fixed regression in :meth:`~Index.intersection` when the :class:`DatetimeIndex` has dates crossing daylight savings time (:issue:`46702`)\n- Fixed regression in :func:`merge` throwing an error when passing a :class:`Series` with a multi-level name (:issue:`47946`)\n- Fixed regression in :meth:`DataFrame.eval` creating a copy when updating inplace (:issue:`47449`)\n- Fixed regression where getting a row using :meth:`DataFrame.iloc` with :class:`SparseDtype` would raise (:issue:`46406`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_144.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- The ``FutureWarning`` raised when passing arguments (other than ``filepath_or_buffer``) as positional in :func:`read_csv` is now raised at the correct stacklevel (:issue:`47385`)\n- Bug in :meth:`DataFrame.to_sql` when ``method`` was a ``callable`` that did not return an ``int`` and would raise a ``TypeError`` (:issue:`46891`)\n- Bug in :meth:`.DataFrameGroupBy.value_counts` where ``subset`` had no effect (:issue:`46383`)\n- Bug when getting values with :meth:`DataFrame.loc` with a list of keys causing an internal inconsistency that could lead to a disconnect between ``frame.at[x, y]`` vs ``frame[y].loc[x]`` (:issue:`22372`)\n- Bug in the :meth:`Series.dt.strftime` accessor return a float instead of object dtype Series for all-NaT input, which also causes a spurious deprecation warning (:issue:`45858`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_144.other:\n\nOther\n~~~~~\n- The minimum version of Cython needed to compile pandas is now ``0.29.32`` (:issue:`47978`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_144.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.4.3..v1.4.4|HEAD\n", "0.6.0": ".. _whatsnew_060:\n\nVersion 0.6.0 (November 25, 2011)\n---------------------------------\n\n{{ header }}\n\nNew features\n~~~~~~~~~~~~\n- :ref:`Added <reshaping.melt>` ``melt`` function to ``pandas.core.reshape``\n- :ref:`Added <groupby.multiindex>` ``level`` parameter to group by level in Series and DataFrame descriptive statistics (:issue:`313`)\n- :ref:`Added <basics.head_tail>` ``head`` and ``tail`` methods to Series, analogous to DataFrame (:issue:`296`)\n- :ref:`Added <indexing.boolean>` ``Series.isin`` function which checks if each value is contained in a passed sequence (:issue:`289`)\n- :ref:`Added <io.formatting>` ``float_format`` option to ``Series.to_string``\n- :ref:`Added <io.parse_dates>` ``skip_footer`` (:issue:`291`) and ``converters`` (:issue:`343`) options to ``read_csv`` and ``read_table``\n- :ref:`Added <indexing.duplicate>` ``drop_duplicates`` and ``duplicated`` functions for removing duplicate DataFrame rows and checking for duplicate rows, respectively (:issue:`319`)\n- :ref:`Implemented <dsintro.boolean>` operators '&', '|', '^', '-' on DataFrame (:issue:`347`)\n- :ref:`Added <basics.stats>` ``Series.mad``, mean absolute deviation\n- :ref:`Added <timeseries.offsets>` ``QuarterEnd`` DateOffset (:issue:`321`)\n- :ref:`Added <dsintro.numpy_interop>` ``dot`` to DataFrame (:issue:`65`)\n- Added ``orient`` option to ``Panel.from_dict`` (:issue:`359`, :issue:`301`)\n- :ref:`Added <basics.dataframe.from_dict>` ``orient`` option to ``DataFrame.from_dict``\n- :ref:`Added <basics.dataframe.from_records>` passing list of tuples or list of lists to ``DataFrame.from_records`` (:issue:`357`)\n- :ref:`Added <groupby.multiindex>` multiple levels to groupby (:issue:`103`)\n- :ref:`Allow <basics.sorting>` multiple columns in ``by`` argument of ``DataFrame.sort_index`` (:issue:`92`, :issue:`362`)\n- :ref:`Added <indexing.basics.get_value>` fast ``get_value`` and ``put_value`` methods to DataFrame (:issue:`360`)\n- Added ``cov`` instance methods to Series and DataFrame (:issue:`194`, :issue:`362`)\n- :ref:`Added <visualization.barplot>` ``kind='bar'`` option to ``DataFrame.plot`` (:issue:`348`)\n- :ref:`Added <basics.idxmin>` ``idxmin`` and ``idxmax`` to Series and DataFrame (:issue:`286`)\n- :ref:`Added <io.clipboard>` ``read_clipboard`` function to parse DataFrame from clipboard (:issue:`300`)\n- :ref:`Added <basics.stats>` ``nunique`` function to Series for counting unique elements (:issue:`297`)\n- :ref:`Made <basics.dataframe>` DataFrame constructor use Series name if no columns passed (:issue:`373`)\n- :ref:`Support <io.parse_dates>` regular expressions in read_table/read_csv (:issue:`364`)\n- :ref:`Added <io.html>` ``DataFrame.to_html`` for writing DataFrame to HTML (:issue:`387`)\n- :ref:`Added <basics.dataframe>` support for MaskedArray data in DataFrame, masked values converted to NaN (:issue:`396`)\n- :ref:`Added <visualization.box>` ``DataFrame.boxplot`` function (:issue:`368`)\n- :ref:`Can <basics.apply>` pass extra args, kwds to DataFrame.apply (:issue:`376`)\n- :ref:`Implement <merging.multikey_join>` ``DataFrame.join`` with vector ``on`` argument (:issue:`312`)\n- :ref:`Added <visualization.basic>` ``legend`` boolean flag to ``DataFrame.plot`` (:issue:`324`)\n- :ref:`Can <reshaping.stacking>` pass multiple levels to ``stack`` and ``unstack`` (:issue:`370`)\n- :ref:`Can <reshaping.pivot>` pass multiple values columns to ``pivot_table`` (:issue:`381`)\n- :ref:`Use <groupby.multiindex>` Series name in GroupBy for result index (:issue:`363`)\n- :ref:`Added <basics.apply>` ``raw`` option to ``DataFrame.apply`` for performance if only need ndarray (:issue:`309`)\n- Added proper, tested weighted least squares to standard and panel OLS (:issue:`303`)\n\nPerformance enhancements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- VBENCH Cythonized ``cache_readonly``, resulting in substantial micro-performance enhancements throughout the code base (:issue:`361`)\n- VBENCH Special Cython matrix iterator for applying arbitrary reduction operations with 3-5x better performance than ``np.apply_along_axis`` (:issue:`309`)\n- VBENCH Improved performance of ``MultiIndex.from_tuples``\n- VBENCH Special Cython matrix iterator for applying arbitrary reduction operations\n- VBENCH + DOCUMENT Add ``raw`` option to ``DataFrame.apply`` for getting better performance when\n- VBENCH Faster cythonized count by level in Series and DataFrame (:issue:`341`)\n- VBENCH? Significant GroupBy performance enhancement with multiple keys with many \"empty\" combinations\n- VBENCH New Cython vectorized function ``map_infer`` speeds up ``Series.apply`` and ``Series.map`` significantly when passed elementwise Python function, motivated by (:issue:`355`)\n- VBENCH Significantly improved performance of ``Series.order``, which also makes np.unique called on a Series faster (:issue:`327`)\n- VBENCH Vastly improved performance of GroupBy on axes with a MultiIndex (:issue:`299`)\n\n\n\n.. _whatsnew_0.6.0.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.5.0..v0.6.0\n", "1.2.2": ".. _whatsnew_122:\n\nWhat's new in 1.2.2 (February 09, 2021)\n---------------------------------------\n\nThese are the changes in pandas 1.2.2. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_122.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n\n- Fixed regression in :func:`read_excel` that caused it to raise ``AttributeError`` when checking version of older xlrd versions (:issue:`38955`)\n- Fixed regression in :class:`DataFrame` constructor reordering element when construction from datetime ndarray with dtype not ``\"datetime64[ns]\"`` (:issue:`39422`)\n- Fixed regression in :meth:`DataFrame.astype` and :meth:`Series.astype` not casting to bytes dtype (:issue:`39474`)\n- Fixed regression in :meth:`~DataFrame.to_pickle` failing to create bz2/xz compressed pickle files with ``protocol=5`` (:issue:`39002`)\n- Fixed regression in :func:`pandas.testing.assert_series_equal` and :func:`pandas.testing.assert_frame_equal` always raising ``AssertionError`` when comparing extension dtypes (:issue:`39410`)\n- Fixed regression in :meth:`~DataFrame.to_csv` opening ``codecs.StreamWriter`` in binary mode instead of in text mode and ignoring user-provided ``mode`` (:issue:`39247`)\n- Fixed regression in :meth:`Categorical.astype` casting to incorrect dtype when ``np.int32`` is passed to dtype argument (:issue:`39402`)\n- Fixed regression in :meth:`~DataFrame.to_excel` creating corrupt files when appending (``mode=\"a\"``) to an existing file (:issue:`39576`)\n- Fixed regression in :meth:`DataFrame.transform` failing in case of an empty DataFrame or Series (:issue:`39636`)\n- Fixed regression in :meth:`~DataFrame.groupby` or :meth:`~DataFrame.resample` when aggregating an all-NaN or numeric object dtype column (:issue:`39329`)\n- Fixed regression in :meth:`.Rolling.count` where the ``min_periods`` argument would be set to ``0`` after the operation (:issue:`39554`)\n- Fixed regression in :func:`read_excel` that incorrectly raised when the argument ``io`` was a non-path and non-buffer and the ``engine`` argument was specified (:issue:`39528`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_122.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\n- :func:`pandas.read_excel` error message when a specified ``sheetname`` does not exist is now uniform across engines (:issue:`39250`)\n- Fixed bug in :func:`pandas.read_excel` producing incorrect results when the engine ``openpyxl`` is used and the excel file is missing or has incorrect dimension information; the fix requires ``openpyxl`` >= 3.0.0, prior versions may still fail (:issue:`38956`, :issue:`39001`)\n- Fixed bug in :func:`pandas.read_excel` sometimes producing a ``DataFrame`` with trailing rows of ``np.nan`` when the engine ``openpyxl`` is used (:issue:`39181`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_122.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.2.1..v1.2.2\n", "1.1.1": ".. _whatsnew_111:\n\nWhat's new in 1.1.1 (August 20, 2020)\n-------------------------------------\n\nThese are the changes in pandas 1.1.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_111.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n\n- Fixed regression in :meth:`CategoricalIndex.format` where, when stringified scalars had different lengths, the shorter string would be right-filled with spaces, so it had the same length as the longest string (:issue:`35439`)\n- Fixed regression in :meth:`Series.truncate` when trying to truncate a single-element series (:issue:`35544`)\n- Fixed regression where :meth:`DataFrame.to_numpy` would raise a ``RuntimeError`` for mixed dtypes when converting to ``str`` (:issue:`35455`)\n- Fixed regression where :func:`read_csv` would raise a ``ValueError`` when ``pandas.options.mode.use_inf_as_na`` was set to ``True`` (:issue:`35493`)\n- Fixed regression where :func:`pandas.testing.assert_series_equal` would raise an error when non-numeric dtypes were passed with ``check_exact=True`` (:issue:`35446`)\n- Fixed regression in ``.groupby(..).rolling(..)`` where column selection was ignored (:issue:`35486`)\n- Fixed regression where :meth:`DataFrame.interpolate` would raise a ``TypeError`` when the :class:`DataFrame` was empty (:issue:`35598`)\n- Fixed regression in :meth:`DataFrame.shift` with ``axis=1`` and heterogeneous dtypes (:issue:`35488`)\n- Fixed regression in :meth:`DataFrame.diff` with read-only data (:issue:`35559`)\n- Fixed regression in ``.groupby(..).rolling(..)`` where a segfault would occur with ``center=True`` and an odd number of values (:issue:`35552`)\n- Fixed regression in :meth:`DataFrame.apply` where functions that altered the input in-place only operated on a single row (:issue:`35462`)\n- Fixed regression in :meth:`DataFrame.reset_index` would raise a ``ValueError`` on empty :class:`DataFrame` with a :class:`MultiIndex` with a ``datetime64`` dtype level (:issue:`35606`, :issue:`35657`)\n- Fixed regression where :func:`pandas.merge_asof` would raise a ``UnboundLocalError`` when ``left_index``, ``right_index`` and ``tolerance`` were set (:issue:`35558`)\n- Fixed regression in ``.groupby(..).rolling(..)`` where a custom ``BaseIndexer`` would be ignored (:issue:`35557`)\n- Fixed regression in :meth:`DataFrame.replace` and :meth:`Series.replace` where compiled regular expressions would be ignored during replacement (:issue:`35680`)\n- Fixed regression in :meth:`.DataFrameGroupBy.aggregate` where a list of functions would produce the wrong results if at least one of the functions did not aggregate (:issue:`35490`)\n- Fixed memory usage issue when instantiating large :class:`pandas.arrays.StringArray` (:issue:`35499`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_111.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\n- Bug in :class:`~pandas.io.formats.style.Styler` whereby ``cell_ids`` argument had no effect due to other recent changes (:issue:`35588`) (:issue:`35663`)\n- Bug in :func:`pandas.testing.assert_series_equal` and :func:`pandas.testing.assert_frame_equal` where extension dtypes were not ignored when ``check_dtypes`` was set to ``False`` (:issue:`35715`)\n- Bug in :meth:`to_timedelta` fails when ``arg`` is a :class:`Series` with ``Int64`` dtype containing null values (:issue:`35574`)\n- Bug in ``.groupby(..).rolling(..)`` where passing ``closed`` with column selection would raise a ``ValueError`` (:issue:`35549`)\n- Bug in :class:`DataFrame` constructor failing to raise ``ValueError`` in some cases when ``data`` and ``index`` have mismatched lengths (:issue:`33437`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_111.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.1.0..v1.1.1\n", "1.4.1": ".. _whatsnew_141:\n\nWhat's new in 1.4.1 (February 12, 2022)\n---------------------------------------\n\nThese are the changes in pandas 1.4.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_141.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Regression in :meth:`Series.mask` with ``inplace=True`` and ``PeriodDtype`` and an incompatible ``other`` coercing to a common dtype instead of raising (:issue:`45546`)\n- Regression in :func:`.assert_frame_equal` not respecting ``check_flags=False`` (:issue:`45554`)\n- Regression in :meth:`DataFrame.loc` raising ``ValueError`` when indexing (getting values) on a :class:`MultiIndex` with one level (:issue:`45779`)\n- Regression in :meth:`Series.fillna` with ``downcast=False`` incorrectly downcasting ``object`` dtype (:issue:`45603`)\n- Regression in :func:`api.types.is_bool_dtype` raising an ``AttributeError`` when evaluating a categorical :class:`Series` (:issue:`45615`)\n- Regression in :meth:`DataFrame.iat` setting values leading to not propagating correctly in subsequent lookups (:issue:`45684`)\n- Regression when setting values with :meth:`DataFrame.loc` losing :class:`Index` name if :class:`DataFrame` was empty before (:issue:`45621`)\n- Regression in :meth:`~Index.join` with overlapping :class:`IntervalIndex` raising an ``InvalidIndexError`` (:issue:`45661`)\n- Regression when setting values with :meth:`Series.loc` raising with all ``False`` indexer and :class:`Series` on the right hand side (:issue:`45778`)\n- Regression in :func:`read_sql` with a DBAPI2 connection that is not an instance of ``sqlite3.Connection`` incorrectly requiring SQLAlchemy be installed (:issue:`45660`)\n- Regression in :class:`DateOffset` when constructing with an integer argument with no keywords (e.g. ``pd.DateOffset(n)``) would behave like ``datetime.timedelta(days=0)`` (:issue:`45643`, :issue:`45890`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_141.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fixed segfault in :meth:`DataFrame.to_json` when dumping tz-aware datetimes in Python 3.10 (:issue:`42130`)\n- Stopped emitting unnecessary ``FutureWarning`` in :meth:`DataFrame.sort_values` with sparse columns (:issue:`45618`)\n- Fixed window aggregations in :meth:`DataFrame.rolling` and :meth:`Series.rolling` to skip over unused elements (:issue:`45647`)\n- Fixed builtin highlighters in :class:`.Styler` to be responsive to ``NA`` with nullable dtypes (:issue:`45804`)\n- Bug in :meth:`~Rolling.apply` with ``axis=1`` raising an erroneous ``ValueError`` (:issue:`45912`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_141.other:\n\nOther\n~~~~~\n- Reverted performance speedup of :meth:`DataFrame.corr` for ``method=pearson`` to fix precision regression (:issue:`45640`, :issue:`42761`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_141.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.4.0..v1.4.1\n", "0.7.0": ".. _whatsnew_0700:\n\nVersion 0.7.0 (February 9, 2012)\n--------------------------------\n\n{{ header }}\n\n\nNew features\n~~~~~~~~~~~~\n\n- New unified :ref:`merge function <merging.join>` for efficiently performing\n  full gamut of database / relational-algebra operations. Refactored existing\n  join methods to use the new infrastructure, resulting in substantial\n  performance gains (:issue:`220`, :issue:`249`, :issue:`267`)\n\n- New :ref:`unified concatenation function <merging.concat>` for concatenating\n  Series, DataFrame or Panel objects along an axis. Can form union or\n  intersection of the other axes. Improves performance of ``Series.append`` and\n  ``DataFrame.append`` (:issue:`468`, :issue:`479`, :issue:`273`)\n\n- Can pass multiple DataFrames to\n  ``DataFrame.append`` to concatenate (stack) and multiple Series to\n  ``Series.append`` too\n\n- :ref:`Can<basics.dataframe.from_list_of_dicts>` pass list of dicts (e.g., a\n  list of JSON objects) to DataFrame constructor (:issue:`526`)\n\n- You can now :ref:`set multiple columns <indexing.columns.multiple>` in a\n  DataFrame via ``__getitem__``, useful for transformation (:issue:`342`)\n\n- Handle differently-indexed output values in ``DataFrame.apply`` (:issue:`498`)\n\n.. code-block:: ipython\n\n   In [1]: df = pd.DataFrame(np.random.randn(10, 4))\n   In [2]: df.apply(lambda x: x.describe())\n   Out[2]:\n                  0          1          2          3\n   count  10.000000  10.000000  10.000000  10.000000\n   mean    0.190912  -0.395125  -0.731920  -0.403130\n   std     0.730951   0.813266   1.112016   0.961912\n   min    -0.861849  -2.104569  -1.776904  -1.469388\n   25%    -0.411391  -0.698728  -1.501401  -1.076610\n   50%     0.380863  -0.228039  -1.191943  -1.004091\n   75%     0.658444   0.057974  -0.034326   0.461706\n   max     1.212112   0.577046   1.643563   1.071804\n\n   [8 rows x 4 columns]\n\n- :ref:`Add<advanced.reorderlevels>` ``reorder_levels`` method to Series and\n  DataFrame (:issue:`534`)\n\n- :ref:`Add<indexing.dictionarylike>` dict-like ``get`` function to DataFrame\n  and Panel (:issue:`521`)\n\n- :ref:`Add<basics.iterrows>` ``DataFrame.iterrows`` method for efficiently\n  iterating through the rows of a DataFrame\n\n- Add ``DataFrame.to_panel`` with code adapted from\n  ``LongPanel.to_long``\n\n- :ref:`Add <basics.reindexing>` ``reindex_axis`` method added to DataFrame\n\n- :ref:`Add <basics.stats>` ``level`` option to binary arithmetic functions on\n  ``DataFrame`` and ``Series``\n\n- :ref:`Add <advanced.advanced_reindex>` ``level`` option to the ``reindex``\n  and ``align`` methods on Series and DataFrame for broadcasting values across\n  a level (:issue:`542`, :issue:`552`, others)\n\n- Add attribute-based item access to\n  ``Panel`` and add IPython completion (:issue:`563`)\n\n- :ref:`Add <visualization.basic>` ``logy`` option to ``Series.plot`` for\n  log-scaling on the Y axis\n\n- :ref:`Add <io.formatting>` ``index`` and ``header`` options to\n  ``DataFrame.to_string``\n\n- :ref:`Can <merging.multiple_join>` pass multiple DataFrames to\n  ``DataFrame.join`` to join on index (:issue:`115`)\n\n- :ref:`Can <merging.multiple_join>` pass multiple Panels to ``Panel.join``\n  (:issue:`115`)\n\n- :ref:`Added <io.formatting>` ``justify`` argument to ``DataFrame.to_string``\n  to allow different alignment of column headers\n\n- :ref:`Add <groupby.attributes>` ``sort`` option to GroupBy to allow disabling\n  sorting of the group keys for potential speedups (:issue:`595`)\n\n- :ref:`Can <basics.dataframe.from_series>` pass MaskedArray to Series\n  constructor (:issue:`563`)\n\n- Add Panel item access via attributes\n  and IPython completion (:issue:`554`)\n\n- Implement ``DataFrame.lookup``, fancy-indexing analogue for retrieving values\n  given a sequence of row and column labels (:issue:`338`)\n\n- Can pass a :ref:`list of functions <groupby.aggregate.multifunc>` to\n  aggregate with groupby on a DataFrame, yielding an aggregated result with\n  hierarchical columns (:issue:`166`)\n\n- Can call ``cummin`` and ``cummax`` on Series and DataFrame to get cumulative\n  minimum and maximum, respectively (:issue:`647`)\n\n- ``value_range`` added as utility function to get min and max of a dataframe\n  (:issue:`288`)\n\n- Added ``encoding`` argument to ``read_csv``, ``read_table``, ``to_csv`` and\n  ``from_csv`` for non-ascii text (:issue:`717`)\n\n- :ref:`Added <basics.stats>` ``abs`` method to pandas objects\n\n- :ref:`Added <reshaping.pivot>` ``crosstab`` function for easily computing frequency tables\n\n- :ref:`Added <indexing.set_ops>` ``isin`` method to index objects\n\n- :ref:`Added <advanced.xs>` ``level`` argument to ``xs`` method of DataFrame.\n\n\nAPI changes to integer indexing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOne of the potentially riskiest API changes in 0.7.0, but also one of the most\nimportant, was a complete review of how **integer indexes** are handled with\nregard to label-based indexing. Here is an example:\n\n.. code-block:: ipython\n\n    In [3]: s = pd.Series(np.random.randn(10), index=range(0, 20, 2))\n    In [4]: s\n    Out[4]:\n    0    -1.294524\n    2     0.413738\n    4     0.276662\n    6    -0.472035\n    8    -0.013960\n    10   -0.362543\n    12   -0.006154\n    14   -0.923061\n    16    0.895717\n    18    0.805244\n    Length: 10, dtype: float64\n\n    In [5]: s[0]\n    Out[5]: -1.2945235902555294\n\n    In [6]: s[2]\n    Out[6]: 0.41373810535784006\n\n    In [7]: s[4]\n    Out[7]: 0.2766617129497566\n\nThis is all exactly identical to the behavior before. However, if you ask for a\nkey **not** contained in the Series, in versions 0.6.1 and prior, Series would\n*fall back* on a location-based lookup. This now raises a ``KeyError``:\n\n.. code-block:: ipython\n\n   In [2]: s[1]\n   KeyError: 1\n\nThis change also has the same impact on DataFrame:\n\n.. code-block:: ipython\n\n   In [3]: df = pd.DataFrame(np.random.randn(8, 4), index=range(0, 16, 2))\n\n   In [4]: df\n       0        1       2       3\n   0   0.88427  0.3363 -0.1787  0.03162\n   2   0.14451 -0.1415  0.2504  0.58374\n   4  -1.44779 -0.9186 -1.4996  0.27163\n   6  -0.26598 -2.4184 -0.2658  0.11503\n   8  -0.58776  0.3144 -0.8566  0.61941\n   10  0.10940 -0.7175 -1.0108  0.47990\n   12 -1.16919 -0.3087 -0.6049 -0.43544\n   14 -0.07337  0.3410  0.0424 -0.16037\n\n   In [5]: df.ix[3]\n   KeyError: 3\n\nIn order to support purely integer-based indexing, the following methods have\nbeen added:\n\n.. csv-table::\n    :header: \"Method\",\"Description\"\n    :widths: 40,60\n\n        ``Series.iget_value(i)``, Retrieve value stored at location ``i``\n        ``Series.iget(i)``, Alias for ``iget_value``\n        ``DataFrame.irow(i)``, Retrieve the ``i``-th row\n        ``DataFrame.icol(j)``, Retrieve the ``j``-th column\n        \"``DataFrame.iget_value(i, j)``\", Retrieve the value at row ``i`` and column ``j``\n\nAPI tweaks regarding label-based slicing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLabel-based slicing using ``ix`` now requires that the index be sorted\n(monotonic) **unless** both the start and endpoint are contained in the index:\n\n.. code-block:: python\n\n   In [1]: s = pd.Series(np.random.randn(6), index=list('gmkaec'))\n\n   In [2]: s\n   Out[2]:\n   g   -1.182230\n   m   -0.276183\n   k   -0.243550\n   a    1.628992\n   e    0.073308\n   c   -0.539890\n   dtype: float64\n\nThen this is OK:\n\n.. code-block:: python\n\n   In [3]: s.ix['k':'e']\n   Out[3]:\n   k   -0.243550\n   a    1.628992\n   e    0.073308\n   dtype: float64\n\nBut this is not:\n\n.. code-block:: ipython\n\n   In [12]: s.ix['b':'h']\n   KeyError 'b'\n\nIf the index had been sorted, the \"range selection\" would have been possible:\n\n.. code-block:: python\n\n   In [4]: s2 = s.sort_index()\n\n   In [5]: s2\n   Out[5]:\n   a    1.628992\n   c   -0.539890\n   e    0.073308\n   g   -1.182230\n   k   -0.243550\n   m   -0.276183\n   dtype: float64\n\n   In [6]: s2.ix['b':'h']\n   Out[6]:\n   c   -0.539890\n   e    0.073308\n   g   -1.182230\n   dtype: float64\n\nChanges to Series ``[]`` operator\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs as notational convenience, you can pass a sequence of labels or a label\nslice to a Series when getting and setting values via ``[]`` (i.e. the\n``__getitem__`` and ``__setitem__`` methods). The behavior will be the same as\npassing similar input to ``ix`` **except in the case of integer indexing**:\n\n.. code-block:: ipython\n\n  In [8]: s = pd.Series(np.random.randn(6), index=list('acegkm'))\n\n  In [9]: s\n  Out[9]:\n  a   -1.206412\n  c    2.565646\n  e    1.431256\n  g    1.340309\n  k   -1.170299\n  m   -0.226169\n  Length: 6, dtype: float64\n\n  In [10]: s[['m', 'a', 'c', 'e']]\n  Out[10]:\n  m   -0.226169\n  a   -1.206412\n  c    2.565646\n  e    1.431256\n  Length: 4, dtype: float64\n\n  In [11]: s['b':'l']\n  Out[11]:\n  c    2.565646\n  e    1.431256\n  g    1.340309\n  k   -1.170299\n  Length: 4, dtype: float64\n\n  In [12]: s['c':'k']\n  Out[12]:\n  c    2.565646\n  e    1.431256\n  g    1.340309\n  k   -1.170299\n  Length: 4, dtype: float64\n\nIn the case of integer indexes, the behavior will be exactly as before\n(shadowing ``ndarray``):\n\n.. code-block:: ipython\n\n  In [13]: s = pd.Series(np.random.randn(6), index=range(0, 12, 2))\n\n  In [14]: s[[4, 0, 2]]\n  Out[14]:\n  4    0.132003\n  0    0.410835\n  2    0.813850\n  Length: 3, dtype: float64\n\n  In [15]: s[1:5]\n  Out[15]:\n  2    0.813850\n  4    0.132003\n  6   -0.827317\n  8   -0.076467\n  Length: 4, dtype: float64\n\nIf you wish to do indexing with sequences and slicing on an integer index with\nlabel semantics, use ``ix``.\n\nOther API changes\n~~~~~~~~~~~~~~~~~\n\n- The deprecated ``LongPanel`` class has been completely removed\n\n- If ``Series.sort`` is called on a column of a DataFrame, an exception will\n  now be raised. Before it was possible to accidentally mutate a DataFrame's\n  column by doing ``df[col].sort()`` instead of the side-effect free method\n  ``df[col].order()`` (:issue:`316`)\n\n- Miscellaneous renames and deprecations which will (harmlessly) raise\n  ``FutureWarning``\n\n- ``drop`` added as an optional parameter to ``DataFrame.reset_index`` (:issue:`699`)\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n- :ref:`Cythonized GroupBy aggregations <groupby.aggregate.builtin>` no longer\n  presort the data, thus achieving a significant speedup (:issue:`93`).  GroupBy\n  aggregations with Python functions significantly sped up by clever\n  manipulation of the ndarray data type in Cython (:issue:`496`).\n- Better error message in DataFrame constructor when passed column labels\n  don't match data (:issue:`497`)\n- Substantially improve performance of multi-GroupBy aggregation when a\n  Python function is passed, reuse ndarray object in Cython (:issue:`496`)\n- Can store objects indexed by tuples and floats in HDFStore (:issue:`492`)\n- Don't print length by default in Series.to_string, add ``length`` option (:issue:`489`)\n- Improve Cython code for multi-groupby to aggregate without having to sort\n  the data (:issue:`93`)\n- Improve MultiIndex reindexing speed by storing tuples in the MultiIndex,\n  test for backwards unpickling compatibility\n- Improve column reindexing performance by using specialized Cython take\n  function\n- Further performance tweaking of Series.__getitem__ for standard use cases\n- Avoid Index dict creation in some cases (i.e. when getting slices, etc.),\n  regression from prior versions\n- Friendlier error message in setup.py if NumPy not installed\n- Use common set of NA-handling operations (sum, mean, etc.) in Panel class\n  also (:issue:`536`)\n- Default name assignment when calling ``reset_index`` on DataFrame with a\n  regular (non-hierarchical) index (:issue:`476`)\n- Use Cythonized groupers when possible in Series/DataFrame stat ops with\n  ``level`` parameter passed (:issue:`545`)\n- Ported skiplist data structure to C to speed up ``rolling_median`` by about\n  5-10x in most typical use cases (:issue:`374`)\n\n\n.. _whatsnew_0.7.0.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.6.1..v0.7.0\n", "1.1.0": ".. _whatsnew_110:\n\nWhat's new in 1.1.0 (July 28, 2020)\n-----------------------------------\n\nThese are the changes in pandas 1.1.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_110.specify_missing_labels:\n\nKeyErrors raised by loc specify missing labels\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nPreviously, if labels were missing for a ``.loc`` call, a KeyError was raised stating that this was no longer supported.\n\nNow the error message also includes a list of the missing labels (max 10 items, display width 80 characters). See :issue:`34272`.\n\n\n.. _whatsnew_110.astype_string:\n\nAll dtypes can now be converted to ``StringDtype``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously, declaring or converting to :class:`StringDtype` was in general only possible if the data was already only ``str`` or nan-like (:issue:`31204`).\n:class:`StringDtype` now works in all situations where ``astype(str)`` or ``dtype=str`` work:\n\nFor example, the below now works:\n\n.. ipython:: python\n\n   ser = pd.Series([1, \"abc\", np.nan], dtype=\"string\")\n   ser\n   ser[0]\n   pd.Series([1, 2, np.nan], dtype=\"Int64\").astype(\"string\")\n\n\n.. _whatsnew_110.period_index_partial_string_slicing:\n\nNon-monotonic PeriodIndex partial string slicing\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`PeriodIndex` now supports partial string slicing for non-monotonic indexes, mirroring :class:`DatetimeIndex` behavior (:issue:`31096`)\n\nFor example:\n\n.. ipython:: python\n\n   dti = pd.date_range(\"2014-01-01\", periods=30, freq=\"30D\")\n   pi = dti.to_period(\"D\")\n   ser_monotonic = pd.Series(np.arange(30), index=pi)\n   shuffler = list(range(0, 30, 2)) + list(range(1, 31, 2))\n   ser = ser_monotonic.iloc[shuffler]\n   ser\n\n.. ipython:: python\n\n   ser[\"2014\"]\n   ser.loc[\"May 2015\"]\n\n\n.. _whatsnew_110.dataframe_or_series_comparing:\n\nComparing two ``DataFrame`` or two ``Series`` and summarizing the differences\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've added :meth:`DataFrame.compare` and :meth:`Series.compare` for comparing two ``DataFrame`` or two ``Series`` (:issue:`30429`)\n\n.. ipython:: python\n\n   df = pd.DataFrame(\n       {\n           \"col1\": [\"a\", \"a\", \"b\", \"b\", \"a\"],\n           \"col2\": [1.0, 2.0, 3.0, np.nan, 5.0],\n           \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0]\n       },\n       columns=[\"col1\", \"col2\", \"col3\"],\n   )\n   df\n\n.. ipython:: python\n\n   df2 = df.copy()\n   df2.loc[0, 'col1'] = 'c'\n   df2.loc[2, 'col3'] = 4.0\n   df2\n\n.. ipython:: python\n\n   df.compare(df2)\n\nSee :ref:`User Guide <merging.compare>` for more details.\n\n\n.. _whatsnew_110.groupby_key:\n\nAllow NA in groupby key\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nWith :ref:`groupby <groupby.dropna>` , we've added a ``dropna`` keyword to :meth:`DataFrame.groupby` and :meth:`Series.groupby` in order to\nallow ``NA`` values in group keys. Users can define ``dropna`` to ``False`` if they want to include\n``NA`` values in groupby keys. The default is set to ``True`` for ``dropna`` to keep backwards\ncompatibility (:issue:`3729`)\n\n.. ipython:: python\n\n    df_list = [[1, 2, 3], [1, None, 4], [2, 1, 3], [1, 2, 2]]\n    df_dropna = pd.DataFrame(df_list, columns=[\"a\", \"b\", \"c\"])\n\n    df_dropna\n\n.. ipython:: python\n\n    # Default ``dropna`` is set to True, which will exclude NaNs in keys\n    df_dropna.groupby(by=[\"b\"], dropna=True).sum()\n\n    # In order to allow NaN in keys, set ``dropna`` to False\n    df_dropna.groupby(by=[\"b\"], dropna=False).sum()\n\nThe default setting of ``dropna`` argument is ``True`` which means ``NA`` are not included in group keys.\n\n\n.. _whatsnew_110.key_sorting:\n\nSorting with keys\n^^^^^^^^^^^^^^^^^\n\nWe've added a ``key`` argument to the :class:`DataFrame` and :class:`Series` sorting methods, including\n:meth:`DataFrame.sort_values`, :meth:`DataFrame.sort_index`, :meth:`Series.sort_values`,\nand :meth:`Series.sort_index`. The ``key`` can be any callable function which is applied\ncolumn-by-column to each column used for sorting, before sorting is performed (:issue:`27237`).\nSee :ref:`sort_values with keys <basics.sort_value_key>` and :ref:`sort_index with keys\n<basics.sort_index_key>` for more information.\n\n.. ipython:: python\n\n   s = pd.Series(['C', 'a', 'B'])\n   s\n\n.. ipython:: python\n\n   s.sort_values()\n\n\nNote how this is sorted with capital letters first. If we apply the :meth:`Series.str.lower`\nmethod, we get\n\n.. ipython:: python\n\n   s.sort_values(key=lambda x: x.str.lower())\n\n\nWhen applied to a ``DataFrame``, they key is applied per-column to all columns or a subset if\n``by`` is specified, e.g.\n\n.. ipython:: python\n\n   df = pd.DataFrame({'a': ['C', 'C', 'a', 'a', 'B', 'B'],\n                      'b': [1, 2, 3, 4, 5, 6]})\n   df\n\n.. ipython:: python\n\n   df.sort_values(by=['a'], key=lambda col: col.str.lower())\n\n\nFor more details, see examples and documentation in :meth:`DataFrame.sort_values`,\n:meth:`Series.sort_values`, and :meth:`~DataFrame.sort_index`.\n\n.. _whatsnew_110.timestamp_fold_support:\n\nFold argument support in Timestamp constructor\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`Timestamp:` now supports the keyword-only fold argument according to `PEP 495 <https://www.python.org/dev/peps/pep-0495/#the-fold-attribute>`_ similar to parent ``datetime.datetime`` class. It supports both accepting fold as an initialization argument and inferring fold from other constructor arguments (:issue:`25057`, :issue:`31338`). Support is limited to ``dateutil`` timezones as ``pytz`` doesn't support fold.\n\nFor example:\n\n.. ipython:: python\n\n    ts = pd.Timestamp(\"2019-10-27 01:30:00+00:00\")\n    ts.fold\n\n.. ipython:: python\n\n    ts = pd.Timestamp(year=2019, month=10, day=27, hour=1, minute=30,\n                      tz=\"dateutil/Europe/London\", fold=1)\n    ts\n\nFor more on working with fold, see :ref:`Fold subsection <timeseries.fold>` in the user guide.\n\n.. _whatsnew_110.to_datetime_multiple_tzname_tzoffset_support:\n\nParsing timezone-aware format with different timezones in to_datetime\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:func:`to_datetime` now supports parsing formats containing timezone names (``%Z``) and UTC offsets (``%z``) from different timezones then converting them to UTC by setting ``utc=True``. This would return a :class:`DatetimeIndex` with timezone at UTC as opposed to an :class:`Index` with ``object`` dtype if ``utc=True`` is not set (:issue:`32792`).\n\nFor example:\n\n.. ipython:: python\n\n    tz_strs = [\"2010-01-01 12:00:00 +0100\", \"2010-01-01 12:00:00 -0100\",\n               \"2010-01-01 12:00:00 +0300\", \"2010-01-01 12:00:00 +0400\"]\n    pd.to_datetime(tz_strs, format='%Y-%m-%d %H:%M:%S %z', utc=True)\n\n.. code-block:: ipython\n\n   In[37]: pd.to_datetime(tz_strs, format='%Y-%m-%d %H:%M:%S %z')\n   Out[37]:\n   Index([2010-01-01 12:00:00+01:00, 2010-01-01 12:00:00-01:00,\n          2010-01-01 12:00:00+03:00, 2010-01-01 12:00:00+04:00],\n         dtype='object')\n\n.. _whatsnew_110.grouper_resample_origin:\n\nGrouper and resample now supports the arguments origin and offset\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`Grouper` and :meth:`DataFrame.resample` now supports the arguments ``origin`` and ``offset``. It let the user control the timestamp on which to adjust the grouping. (:issue:`31809`)\n\nThe bins of the grouping are adjusted based on the beginning of the day of the time series starting point. This works well with frequencies that are multiples of a day (like ``30D``) or that divides a day (like ``90s`` or ``1min``). But it can create inconsistencies with some frequencies that do not meet this criteria. To change this behavior you can now specify a fixed timestamp with the argument ``origin``.\n\nTwo arguments are now deprecated (more information in the documentation of :meth:`DataFrame.resample`):\n\n- ``base`` should be replaced by ``offset``.\n- ``loffset`` should be replaced by directly adding an offset to the index :class:`DataFrame` after being resampled.\n\nSmall example of the use of ``origin``:\n\n.. ipython:: python\n\n    start, end = '2000-10-01 23:30:00', '2000-10-02 00:30:00'\n    middle = '2000-10-02 00:00:00'\n    rng = pd.date_range(start, end, freq='7min')\n    ts = pd.Series(np.arange(len(rng)) * 3, index=rng)\n    ts\n\nResample with the default behavior ``'start_day'`` (origin is ``2000-10-01 00:00:00``):\n\n.. ipython:: python\n\n    ts.resample('17min').sum()\n    ts.resample('17min', origin='start_day').sum()\n\nResample using a fixed origin:\n\n.. ipython:: python\n\n    ts.resample('17min', origin='epoch').sum()\n    ts.resample('17min', origin='2000-01-01').sum()\n\nIf needed you can adjust the bins with the argument ``offset`` (a :class:`Timedelta`) that would be added to the default ``origin``.\n\nFor a full example, see: :ref:`timeseries.adjust-the-start-of-the-bins`.\n\nfsspec now used for filesystem handling\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor reading and writing to filesystems other than local and reading from HTTP(S),\nthe optional dependency ``fsspec`` will be used to dispatch operations (:issue:`33452`).\nThis will give unchanged\nfunctionality for S3 and GCS storage, which were already supported, but also add\nsupport for several other storage implementations such as `Azure Datalake and Blob`_,\nSSH, FTP, dropbox and github. For docs and capabilities, see the `fsspec docs`_.\n\nThe existing capability to interface with S3 and GCS will be unaffected by this\nchange, as ``fsspec`` will still bring in the same packages as before.\n\n.. _Azure Datalake and Blob: https://github.com/fsspec/adlfs\n\n.. _fsspec docs: https://filesystem-spec.readthedocs.io/en/latest/\n\n.. _whatsnew_110.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n\n- Compatibility with matplotlib 3.3.0 (:issue:`34850`)\n- :meth:`IntegerArray.astype` now supports ``datetime64`` dtype (:issue:`32538`)\n- :class:`IntegerArray` now implements the ``sum`` operation (:issue:`33172`)\n- Added :class:`pandas.errors.InvalidIndexError` (:issue:`34570`).\n- Added :meth:`DataFrame.value_counts` (:issue:`5377`)\n- Added a :func:`pandas.api.indexers.FixedForwardWindowIndexer` class to support forward-looking windows during ``rolling`` operations.\n- Added a :func:`pandas.api.indexers.VariableOffsetWindowIndexer` class to support ``rolling`` operations with non-fixed offsets (:issue:`34994`)\n- :meth:`~DataFrame.describe` now includes a ``datetime_is_numeric`` keyword to control how datetime columns are summarized (:issue:`30164`, :issue:`34798`)\n- :class:`~pandas.io.formats.style.Styler` may now render CSS more efficiently where multiple cells have the same styling (:issue:`30876`)\n- :meth:`~pandas.io.formats.style.Styler.highlight_null` now accepts ``subset`` argument (:issue:`31345`)\n- When writing directly to a sqlite connection :meth:`DataFrame.to_sql` now supports the ``multi`` method (:issue:`29921`)\n- :class:`pandas.errors.OptionError` is now exposed in ``pandas.errors`` (:issue:`27553`)\n- Added :meth:`api.extensions.ExtensionArray.argmax` and :meth:`api.extensions.ExtensionArray.argmin` (:issue:`24382`)\n- :func:`timedelta_range` will now infer a frequency when passed ``start``, ``stop``, and ``periods`` (:issue:`32377`)\n- Positional slicing on a :class:`IntervalIndex` now supports slices with ``step > 1`` (:issue:`31658`)\n- :class:`Series.str` now has a ``fullmatch`` method that matches a regular expression against the entire string in each row of the :class:`Series`, similar to ``re.fullmatch`` (:issue:`32806`).\n- :meth:`DataFrame.sample` will now also allow array-like and BitGenerator objects to be passed to ``random_state`` as seeds (:issue:`32503`)\n- :meth:`Index.union` will now raise ``RuntimeWarning`` for :class:`MultiIndex` objects if the object inside are unsortable. Pass ``sort=False`` to suppress this warning (:issue:`33015`)\n- Added :meth:`Series.dt.isocalendar` and :meth:`DatetimeIndex.isocalendar` that returns a :class:`DataFrame` with year, week, and day calculated according to the ISO 8601 calendar (:issue:`33206`, :issue:`34392`).\n- The :meth:`DataFrame.to_feather` method now supports additional keyword\n  arguments (e.g. to set the compression) that are added in pyarrow 0.17\n  (:issue:`33422`).\n- The :func:`cut` will now accept parameter ``ordered`` with default ``ordered=True``. If ``ordered=False`` and no labels are provided, an error will be raised (:issue:`33141`)\n- :meth:`DataFrame.to_csv`, :meth:`DataFrame.to_pickle`,\n  and :meth:`DataFrame.to_json` now support passing a dict of\n  compression arguments when using the ``gzip`` and ``bz2`` protocols.\n  This can be used to set a custom compression level, e.g.,\n  ``df.to_csv(path, compression={'method': 'gzip', 'compresslevel': 1}``\n  (:issue:`33196`)\n- :meth:`melt` has gained an ``ignore_index`` (default ``True``) argument that, if set to ``False``, prevents the method from dropping the index (:issue:`17440`).\n- :meth:`Series.update` now accepts objects that can be coerced to a :class:`Series`,\n  such as ``dict`` and ``list``, mirroring the behavior of :meth:`DataFrame.update` (:issue:`33215`)\n- :meth:`.DataFrameGroupBy.transform` and :meth:`.DataFrameGroupBy.aggregate` have gained ``engine`` and ``engine_kwargs`` arguments that support executing functions with ``Numba`` (:issue:`32854`, :issue:`33388`)\n- :meth:`.Resampler.interpolate` now supports SciPy interpolation method :class:`scipy.interpolate.CubicSpline` as method ``cubicspline`` (:issue:`33670`)\n- :class:`.DataFrameGroupBy` and :class:`.SeriesGroupBy` now implement the ``sample`` method for doing random sampling within groups (:issue:`31775`)\n- :meth:`DataFrame.to_numpy` now supports the ``na_value`` keyword to control the NA sentinel in the output array (:issue:`33820`)\n- Added :class:`api.extension.ExtensionArray.equals` to the extension array interface, similar to :meth:`Series.equals` (:issue:`27081`)\n- The minimum supported dta version has increased to 105 in :func:`read_stata` and :class:`~pandas.io.stata.StataReader`  (:issue:`26667`).\n- :meth:`~DataFrame.to_stata` supports compression using the ``compression``\n  keyword argument. Compression can either be inferred or explicitly set using a string or a\n  dictionary containing both the method and any additional arguments that are passed to the\n  compression library. Compression was also added to the low-level Stata-file writers\n  :class:`~pandas.io.stata.StataWriter`, :class:`~pandas.io.stata.StataWriter117`,\n  and :class:`~pandas.io.stata.StataWriterUTF8` (:issue:`26599`).\n- :meth:`HDFStore.put` now accepts a ``track_times`` parameter. This parameter is passed to the ``create_table`` method of ``PyTables`` (:issue:`32682`).\n- :meth:`Series.plot` and :meth:`DataFrame.plot` now accepts ``xlabel`` and ``ylabel`` parameters to present labels on x and y axis (:issue:`9093`).\n- Made :class:`.Rolling` and :class:`.Expanding` iterable\u00ef\u00bc\u0088:issue:`11704`)\n- Made ``option_context`` a :class:`contextlib.ContextDecorator`, which allows it to be used as a decorator over an entire function (:issue:`34253`).\n- :meth:`DataFrame.to_csv` and :meth:`Series.to_csv` now accept an ``errors`` argument (:issue:`22610`)\n- :meth:`.DataFrameGroupBy.groupby.transform` now allows ``func`` to be ``pad``, ``backfill`` and ``cumcount`` (:issue:`31269`).\n- :func:`read_json` now accepts an ``nrows`` parameter. (:issue:`33916`).\n- :meth:`DataFrame.hist`, :meth:`Series.hist`, :meth:`core.groupby.DataFrameGroupBy.hist`, and :meth:`core.groupby.SeriesGroupBy.hist` have gained the ``legend`` argument. Set to True to show a legend in the histogram. (:issue:`6279`)\n- :func:`concat` and :meth:`~DataFrame.append` now preserve extension dtypes, for example\n  combining a nullable integer column with a numpy integer column will no longer\n  result in object dtype but preserve the integer dtype (:issue:`33607`, :issue:`34339`, :issue:`34095`).\n- :func:`read_gbq` now allows to disable progress bar (:issue:`33360`).\n- :func:`read_gbq` now supports the ``max_results`` kwarg from ``pandas-gbq`` (:issue:`34639`).\n- :meth:`DataFrame.cov` and :meth:`Series.cov` now support a new parameter ``ddof`` to support delta degrees of freedom as in the corresponding numpy methods (:issue:`34611`).\n- :meth:`DataFrame.to_html` and :meth:`DataFrame.to_string`'s ``col_space`` parameter now accepts a list or dict to change only some specific columns' width (:issue:`28917`).\n- :meth:`DataFrame.to_excel` can now also write OpenOffice spreadsheet (.ods) files (:issue:`27222`)\n- :meth:`~Series.explode` now accepts ``ignore_index`` to reset the index, similar to :meth:`pd.concat` or :meth:`DataFrame.sort_values` (:issue:`34932`).\n- :meth:`DataFrame.to_markdown` and :meth:`Series.to_markdown` now accept ``index`` argument as an alias for tabulate's ``showindex`` (:issue:`32667`)\n- :meth:`read_csv` now accepts string values like \"0\", \"0.0\", \"1\", \"1.0\" as convertible to the nullable Boolean dtype (:issue:`34859`)\n- :class:`.ExponentialMovingWindow` now supports a ``times`` argument that allows ``mean`` to be calculated with observations spaced by the timestamps in ``times`` (:issue:`34839`)\n- :meth:`DataFrame.agg` and :meth:`Series.agg` now accept named aggregation for renaming the output columns/indexes. (:issue:`26513`)\n- ``compute.use_numba`` now exists as a configuration option that utilizes the numba engine when available (:issue:`33966`, :issue:`35374`)\n- :meth:`Series.plot` now supports asymmetric error bars. Previously, if :meth:`Series.plot` received a \"2xN\" array with error values for ``yerr`` and/or ``xerr``, the left/lower values (first row) were mirrored, while the right/upper values (second row) were ignored. Now, the first row represents the left/lower error values and the second row the right/upper error values. (:issue:`9536`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_110.notable_bug_fixes:\n\nNotable bug fixes\n~~~~~~~~~~~~~~~~~\n\nThese are bug fixes that might have notable behavior changes.\n\n``MultiIndex.get_indexer`` interprets ``method`` argument correctly\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis restores the behavior of :meth:`MultiIndex.get_indexer` with ``method='backfill'`` or ``method='pad'`` to the behavior before pandas 0.23.0. In particular, MultiIndexes are treated as a list of tuples and padding or backfilling is done with respect to the ordering of these lists of tuples (:issue:`29896`).\n\nAs an example of this, given:\n\n.. ipython:: python\n\n        df = pd.DataFrame({\n            'a': [0, 0, 0, 0],\n            'b': [0, 2, 3, 4],\n            'c': ['A', 'B', 'C', 'D'],\n        }).set_index(['a', 'b'])\n        mi_2 = pd.MultiIndex.from_product([[0], [-1, 0, 1, 3, 4, 5]])\n\nThe differences in reindexing ``df`` with ``mi_2`` and using ``method='backfill'`` can be seen here:\n\n*pandas >= 0.23, < 1.1.0*:\n\n.. code-block:: ipython\n\n    In [1]: df.reindex(mi_2, method='backfill')\n    Out[1]:\n          c\n    0 -1  A\n       0  A\n       1  D\n       3  A\n       4  A\n       5  C\n\n*pandas <0.23, >= 1.1.0*\n\n.. ipython:: python\n\n        df.reindex(mi_2, method='backfill')\n\nAnd the differences in reindexing ``df`` with ``mi_2`` and using ``method='pad'`` can be seen here:\n\n*pandas >= 0.23, < 1.1.0*\n\n.. code-block:: ipython\n\n    In [1]: df.reindex(mi_2, method='pad')\n    Out[1]:\n            c\n    0 -1  NaN\n       0  NaN\n       1    D\n       3  NaN\n       4    A\n       5    C\n\n*pandas < 0.23, >= 1.1.0*\n\n.. ipython:: python\n\n        df.reindex(mi_2, method='pad')\n\n.. _whatsnew_110.notable_bug_fixes.indexing_raises_key_errors:\n\nFailed label-based lookups always raise KeyError\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLabel lookups ``series[key]``, ``series.loc[key]`` and ``frame.loc[key]``\nused to raise either ``KeyError`` or ``TypeError`` depending on the type of\nkey and type of :class:`Index`.  These now consistently raise ``KeyError`` (:issue:`31867`)\n\n.. ipython:: python\n\n    ser1 = pd.Series(range(3), index=[0, 1, 2])\n    ser2 = pd.Series(range(3), index=pd.date_range(\"2020-02-01\", periods=3))\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [3]: ser1[1.5]\n    ...\n    TypeError: cannot do label indexing on Int64Index with these indexers [1.5] of type float\n\n    In [4] ser1[\"foo\"]\n    ...\n    KeyError: 'foo'\n\n    In [5]: ser1.loc[1.5]\n    ...\n    TypeError: cannot do label indexing on Int64Index with these indexers [1.5] of type float\n\n    In [6]: ser1.loc[\"foo\"]\n    ...\n    KeyError: 'foo'\n\n    In [7]: ser2.loc[1]\n    ...\n    TypeError: cannot do label indexing on DatetimeIndex with these indexers [1] of type int\n\n    In [8]: ser2.loc[pd.Timestamp(0)]\n    ...\n    KeyError: Timestamp('1970-01-01 00:00:00')\n\n*New behavior*:\n\n.. code-block:: ipython\n\n    In [3]: ser1[1.5]\n    ...\n    KeyError: 1.5\n\n    In [4] ser1[\"foo\"]\n    ...\n    KeyError: 'foo'\n\n    In [5]: ser1.loc[1.5]\n    ...\n    KeyError: 1.5\n\n    In [6]: ser1.loc[\"foo\"]\n    ...\n    KeyError: 'foo'\n\n    In [7]: ser2.loc[1]\n    ...\n    KeyError: 1\n\n    In [8]: ser2.loc[pd.Timestamp(0)]\n    ...\n    KeyError: Timestamp('1970-01-01 00:00:00')\n\n\nSimilarly, :meth:`DataFrame.at` and :meth:`Series.at` will raise a ``TypeError`` instead of a ``ValueError`` if an incompatible key is passed, and ``KeyError`` if a missing key is passed, matching the behavior of ``.loc[]`` (:issue:`31722`)\n\n.. _whatsnew_110.notable_bug_fixes.indexing_int_multiindex_raises_key_errors:\n\nFailed Integer Lookups on MultiIndex Raise KeyError\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexing with integers with a :class:`MultiIndex` that has an integer-dtype\nfirst level incorrectly failed to raise ``KeyError`` when one or more of\nthose integer keys is not present in the first level of the index (:issue:`33539`)\n\n.. ipython:: python\n\n    idx = pd.Index(range(4))\n    dti = pd.date_range(\"2000-01-03\", periods=3)\n    mi = pd.MultiIndex.from_product([idx, dti])\n    ser = pd.Series(range(len(mi)), index=mi)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [5]: ser[[5]]\n    Out[5]: Series([], dtype: int64)\n\n*New behavior*:\n\n.. code-block:: ipython\n\n    In [5]: ser[[5]]\n    ...\n    KeyError: '[5] not in index'\n\n:meth:`DataFrame.merge` preserves right frame's row order\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n:meth:`DataFrame.merge` now preserves the right frame's row order when executing a right merge (:issue:`27453`)\n\n.. ipython:: python\n\n    left_df = pd.DataFrame({'animal': ['dog', 'pig'],\n                           'max_speed': [40, 11]})\n    right_df = pd.DataFrame({'animal': ['quetzal', 'pig'],\n                            'max_speed': [80, 11]})\n    left_df\n    right_df\n\n*Previous behavior*:\n\n.. code-block:: python\n\n    >>> left_df.merge(right_df, on=['animal', 'max_speed'], how=\"right\")\n        animal  max_speed\n    0      pig         11\n    1  quetzal         80\n\n*New behavior*:\n\n.. ipython:: python\n\n    left_df.merge(right_df, on=['animal', 'max_speed'], how=\"right\")\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_110.notable_bug_fixes.assignment_to_multiple_columns:\n\nAssignment to multiple columns of a DataFrame when some columns do not exist\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAssignment to multiple columns of a :class:`DataFrame` when some of the columns do not exist would previously assign the values to the last column. Now, new columns will be constructed with the right values. (:issue:`13658`)\n\n.. ipython:: python\n\n   df = pd.DataFrame({'a': [0, 1, 2], 'b': [3, 4, 5]})\n   df\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [3]: df[['a', 'c']] = 1\n   In [4]: df\n   Out[4]:\n      a  b\n   0  1  1\n   1  1  1\n   2  1  1\n\n*New behavior*:\n\n.. ipython:: python\n\n   df[['a', 'c']] = 1\n   df\n\n.. _whatsnew_110.notable_bug_fixes.groupby_consistency:\n\nConsistency across groupby reductions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUsing :meth:`DataFrame.groupby` with ``as_index=True`` and the aggregation ``nunique`` would include the grouping column(s) in the columns of the result. Now the grouping column(s) only appear in the index, consistent with other reductions. (:issue:`32579`)\n\n.. ipython:: python\n\n   df = pd.DataFrame({\"a\": [\"x\", \"x\", \"y\", \"y\"], \"b\": [1, 1, 2, 3]})\n   df\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [3]: df.groupby(\"a\", as_index=True).nunique()\n   Out[4]:\n      a  b\n   a\n   x  1  1\n   y  1  2\n\n*New behavior*:\n\n.. ipython:: python\n\n   df.groupby(\"a\", as_index=True).nunique()\n\nUsing :meth:`DataFrame.groupby` with ``as_index=False`` and the function ``idxmax``, ``idxmin``, ``mad``, ``nunique``, ``sem``, ``skew``, or ``std`` would modify the grouping column. Now the grouping column remains unchanged, consistent with other reductions. (:issue:`21090`, :issue:`10355`)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [3]: df.groupby(\"a\", as_index=False).nunique()\n   Out[4]:\n      a  b\n   0  1  1\n   1  1  2\n\n*New behavior*:\n\n.. ipython:: python\n\n   df.groupby(\"a\", as_index=False).nunique()\n\nThe method :meth:`.DataFrameGroupBy.size` would previously ignore ``as_index=False``. Now the grouping columns are returned as columns, making the result a :class:`DataFrame` instead of a :class:`Series`. (:issue:`32599`)\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [3]: df.groupby(\"a\", as_index=False).size()\n   Out[4]:\n   a\n   x    2\n   y    2\n   dtype: int64\n\n*New behavior*:\n\n.. ipython:: python\n\n   df.groupby(\"a\", as_index=False).size()\n\n.. _whatsnew_110.api_breaking.groupby_results_lost_as_index_false:\n\n:meth:`.DataFrameGroupby.agg` lost results with ``as_index=False`` when relabeling columns\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously :meth:`.DataFrameGroupby.agg` lost the result columns, when the ``as_index`` option was\nset to ``False`` and the result columns were relabeled. In this case the result values were replaced with\nthe previous index (:issue:`32240`).\n\n.. ipython:: python\n\n   df = pd.DataFrame({\"key\": [\"x\", \"y\", \"z\", \"x\", \"y\", \"z\"],\n                      \"val\": [1.0, 0.8, 2.0, 3.0, 3.6, 0.75]})\n   df\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [2]: grouped = df.groupby(\"key\", as_index=False)\n   In [3]: result = grouped.agg(min_val=pd.NamedAgg(column=\"val\", aggfunc=\"min\"))\n   In [4]: result\n   Out[4]:\n        min_val\n    0   x\n    1   y\n    2   z\n\n*New behavior*:\n\n.. ipython:: python\n\n   grouped = df.groupby(\"key\", as_index=False)\n   result = grouped.agg(min_val=pd.NamedAgg(column=\"val\", aggfunc=\"min\"))\n   result\n\n\n.. _whatsnew_110.notable_bug_fixes.apply_applymap_first_once:\n\napply and applymap on ``DataFrame`` evaluates first row/column only once\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. ipython:: python\n\n    df = pd.DataFrame({'a': [1, 2], 'b': [3, 6]})\n\n    def func(row):\n        print(row)\n        return row\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [4]: df.apply(func, axis=1)\n    a    1\n    b    3\n    Name: 0, dtype: int64\n    a    1\n    b    3\n    Name: 0, dtype: int64\n    a    2\n    b    6\n    Name: 1, dtype: int64\n    Out[4]:\n       a  b\n    0  1  3\n    1  2  6\n\n*New behavior*:\n\n.. ipython:: python\n\n    df.apply(func, axis=1)\n\n.. _whatsnew_110.api_breaking:\n\nBackwards incompatible API changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_110.api_breaking.testing.check_freq:\n\nAdded ``check_freq`` argument to ``testing.assert_frame_equal`` and ``testing.assert_series_equal``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``check_freq`` argument was added to :func:`testing.assert_frame_equal` and :func:`testing.assert_series_equal` in pandas 1.1.0 and defaults to ``True``. :func:`testing.assert_frame_equal` and :func:`testing.assert_series_equal` now raise ``AssertionError`` if the indexes do not have the same frequency. Before pandas 1.1.0, the index frequency was not checked.\n\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSome minimum supported versions of dependencies were updated (:issue:`33718`, :issue:`29766`, :issue:`29723`, pytables >= 3.4.3).\nIf installed, we now require:\n\n+-----------------+-----------------+----------+---------+\n| Package         | Minimum Version | Required | Changed |\n+=================+=================+==========+=========+\n| numpy           | 1.15.4          |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| pytz            | 2015.4          |    X     |         |\n+-----------------+-----------------+----------+---------+\n| python-dateutil | 2.7.3           |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| bottleneck      | 1.2.1           |          |         |\n+-----------------+-----------------+----------+---------+\n| numexpr         | 2.6.2           |          |         |\n+-----------------+-----------------+----------+---------+\n| pytest (dev)    | 4.0.2           |          |         |\n+-----------------+-----------------+----------+---------+\n\nFor `optional libraries <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\nThe following table lists the lowest version per library that is currently being tested throughout the development of pandas.\nOptional libraries below the lowest tested version may still work, but are not considered supported.\n\n+-----------------+-----------------+---------+\n| Package         | Minimum Version | Changed |\n+=================+=================+=========+\n| beautifulsoup4  | 4.6.0           |         |\n+-----------------+-----------------+---------+\n| fastparquet     | 0.3.2           |         |\n+-----------------+-----------------+---------+\n| fsspec          | 0.7.4           |         |\n+-----------------+-----------------+---------+\n| gcsfs           | 0.6.0           |    X    |\n+-----------------+-----------------+---------+\n| lxml            | 3.8.0           |         |\n+-----------------+-----------------+---------+\n| matplotlib      | 2.2.2           |         |\n+-----------------+-----------------+---------+\n| numba           | 0.46.0          |         |\n+-----------------+-----------------+---------+\n| openpyxl        | 2.5.7           |         |\n+-----------------+-----------------+---------+\n| pyarrow         | 0.13.0          |         |\n+-----------------+-----------------+---------+\n| pymysql         | 0.7.1           |         |\n+-----------------+-----------------+---------+\n| pytables        | 3.4.3           |    X    |\n+-----------------+-----------------+---------+\n| s3fs            | 0.4.0           |    X    |\n+-----------------+-----------------+---------+\n| scipy           | 1.2.0           |    X    |\n+-----------------+-----------------+---------+\n| sqlalchemy      | 1.1.4           |         |\n+-----------------+-----------------+---------+\n| xarray          | 0.8.2           |         |\n+-----------------+-----------------+---------+\n| xlrd            | 1.1.0           |         |\n+-----------------+-----------------+---------+\n| xlsxwriter      | 0.9.8           |         |\n+-----------------+-----------------+---------+\n| xlwt            | 1.2.0           |         |\n+-----------------+-----------------+---------+\n| pandas-gbq      | 1.2.0           |    X    |\n+-----------------+-----------------+---------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\nDevelopment changes\n^^^^^^^^^^^^^^^^^^^\n\n- The minimum version of Cython is now the most recent bug-fix version (0.29.16) (:issue:`33334`).\n\n\n.. _whatsnew_110.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\n- Lookups on a :class:`Series` with a single-item list containing a slice (e.g. ``ser[[slice(0, 4)]]``) are deprecated and will raise in a future version.  Either convert the list to a tuple, or pass the slice directly instead (:issue:`31333`)\n\n- :meth:`DataFrame.mean` and :meth:`DataFrame.median` with ``numeric_only=None`` will include ``datetime64`` and ``datetime64tz`` columns in a future version (:issue:`29941`)\n- Setting values with ``.loc`` using a positional slice is deprecated and will raise in a future version.  Use ``.loc`` with labels or ``.iloc`` with positions instead (:issue:`31840`)\n- :meth:`DataFrame.to_dict` has deprecated accepting short names for ``orient`` and will raise in a future version (:issue:`32515`)\n- :meth:`Categorical.to_dense` is deprecated and will be removed in a future version, use ``np.asarray(cat)`` instead (:issue:`32639`)\n- The ``fastpath`` keyword in the ``SingleBlockManager`` constructor is deprecated and will be removed in a future version (:issue:`33092`)\n- Providing ``suffixes`` as a ``set`` in :func:`pandas.merge` is deprecated. Provide a tuple instead (:issue:`33740`, :issue:`34741`).\n- Indexing a :class:`Series` with a multi-dimensional indexer like ``[:, None]`` to return an ``ndarray`` now raises a ``FutureWarning``. Convert to a NumPy array before indexing instead (:issue:`27837`)\n- :meth:`Index.is_mixed` is deprecated and will be removed in a future version, check ``index.inferred_type`` directly instead (:issue:`32922`)\n\n- Passing any arguments but the first one to :func:`read_html` as\n  positional arguments is deprecated. All other\n  arguments should be given as keyword arguments (:issue:`27573`).\n\n- Passing any arguments but ``path_or_buf`` (the first one) to\n  :func:`read_json` as positional arguments is deprecated. All\n  other arguments should be given as keyword arguments (:issue:`27573`).\n\n- Passing any arguments but the first two to :func:`read_excel` as\n  positional arguments is deprecated. All other\n  arguments should be given as keyword arguments (:issue:`27573`).\n\n- :func:`pandas.api.types.is_categorical` is deprecated and will be removed in a future version; use :func:`pandas.api.types.is_categorical_dtype` instead (:issue:`33385`)\n- :meth:`Index.get_value` is deprecated and will be removed in a future version (:issue:`19728`)\n- :meth:`Series.dt.week` and :meth:`Series.dt.weekofyear` are deprecated and will be removed in a future version, use :meth:`Series.dt.isocalendar().week` instead (:issue:`33595`)\n- :meth:`DatetimeIndex.week` and ``DatetimeIndex.weekofyear`` are deprecated and will be removed in a future version, use ``DatetimeIndex.isocalendar().week`` instead (:issue:`33595`)\n- :meth:`DatetimeArray.week` and ``DatetimeArray.weekofyear`` are deprecated and will be removed in a future version, use ``DatetimeArray.isocalendar().week`` instead (:issue:`33595`)\n- :meth:`DateOffset.__call__` is deprecated and will be removed in a future version, use ``offset + other`` instead (:issue:`34171`)\n- :meth:`~pandas.tseries.offsets.BusinessDay.apply_index` is deprecated and will be removed in a future version. Use ``offset + other`` instead (:issue:`34580`)\n- :meth:`DataFrame.tshift` and :meth:`Series.tshift` are deprecated and will be removed in a future version, use :meth:`DataFrame.shift` and :meth:`Series.shift` instead (:issue:`11631`)\n- Indexing an :class:`Index` object with a float key is deprecated, and will\n  raise an ``IndexError`` in the future. You can manually convert to an integer key\n  instead (:issue:`34191`).\n- The ``squeeze`` keyword in :meth:`~DataFrame.groupby` is deprecated and will be removed in a future version (:issue:`32380`)\n- The ``tz`` keyword in :meth:`Period.to_timestamp` is deprecated and will be removed in a future version; use ``per.to_timestamp(...).tz_localize(tz)`` instead (:issue:`34522`)\n- :meth:`DatetimeIndex.to_perioddelta` is deprecated and will be removed in a future version.  Use ``index - index.to_period(freq).to_timestamp()`` instead (:issue:`34853`)\n- :meth:`DataFrame.melt` accepting a ``value_name`` that already exists is deprecated, and will be removed in a future version (:issue:`34731`)\n- The ``center`` keyword in the :meth:`DataFrame.expanding` function is deprecated and will be removed in a future version (:issue:`20647`)\n\n\n\n.. ---------------------------------------------------------------------------\n\n\n.. _whatsnew_110.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n- Performance improvement in :class:`Timedelta` constructor (:issue:`30543`)\n- Performance improvement in :class:`Timestamp` constructor (:issue:`30543`)\n- Performance improvement in flex arithmetic ops between :class:`DataFrame` and :class:`Series` with ``axis=0`` (:issue:`31296`)\n- Performance improvement in arithmetic ops between :class:`DataFrame` and :class:`Series` with ``axis=1`` (:issue:`33600`)\n- The internal index method :meth:`~Index._shallow_copy` now copies cached attributes over to the new index,\n  avoiding creating these again on the new index. This can speed up many operations that depend on creating copies of\n  existing indexes (:issue:`28584`, :issue:`32640`, :issue:`32669`)\n- Significant performance improvement when creating a :class:`DataFrame` with\n  sparse values from ``scipy.sparse`` matrices using the\n  :meth:`DataFrame.sparse.from_spmatrix` constructor (:issue:`32821`,\n  :issue:`32825`,  :issue:`32826`, :issue:`32856`, :issue:`32858`).\n- Performance improvement for groupby methods :meth:`.Groupby.first`\n  and :meth:`.Groupby.last` (:issue:`34178`)\n- Performance improvement in :func:`factorize` for nullable (integer and Boolean) dtypes (:issue:`33064`).\n- Performance improvement when constructing :class:`Categorical` objects (:issue:`33921`)\n- Fixed performance regression in :func:`pandas.qcut` and :func:`pandas.cut` (:issue:`33921`)\n- Performance improvement in reductions (``sum``, ``prod``, ``min``, ``max``) for nullable (integer and Boolean) dtypes (:issue:`30982`, :issue:`33261`, :issue:`33442`).\n- Performance improvement in arithmetic operations between two :class:`DataFrame` objects (:issue:`32779`)\n- Performance improvement in :class:`.RollingGroupby` (:issue:`34052`)\n- Performance improvement in arithmetic operations (``sub``, ``add``, ``mul``, ``div``) for :class:`MultiIndex` (:issue:`34297`)\n- Performance improvement in ``DataFrame[bool_indexer]`` when ``bool_indexer`` is a ``list`` (:issue:`33924`)\n- Significant performance improvement of :meth:`io.formats.style.Styler.render` with styles added with various ways such as :meth:`io.formats.style.Styler.apply`, :meth:`io.formats.style.Styler.applymap` or :meth:`io.formats.style.Styler.bar` (:issue:`19917`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_110.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\n\nCategorical\n^^^^^^^^^^^\n\n- Passing an invalid ``fill_value`` to :meth:`Categorical.take` raises a ``ValueError`` instead of ``TypeError`` (:issue:`33660`)\n- Combining a :class:`Categorical` with integer categories and which contains missing values with a float dtype column in operations such as :func:`concat` or :meth:`~DataFrame.append` will now result in a float column instead of an object dtype column (:issue:`33607`)\n- Bug where :func:`merge` was unable to join on non-unique categorical indices (:issue:`28189`)\n- Bug when passing categorical data to :class:`Index` constructor along with ``dtype=object`` incorrectly returning a :class:`CategoricalIndex` instead of object-dtype :class:`Index` (:issue:`32167`)\n- Bug where :class:`Categorical` comparison operator ``__ne__`` would incorrectly evaluate to ``False`` when either element was missing (:issue:`32276`)\n- :meth:`Categorical.fillna` now accepts :class:`Categorical` ``other`` argument (:issue:`32420`)\n- Repr of :class:`Categorical` was not distinguishing between ``int`` and ``str`` (:issue:`33676`)\n\nDatetimelike\n^^^^^^^^^^^^\n\n- Passing an integer dtype other than ``int64`` to ``np.array(period_index, dtype=...)`` will now raise ``TypeError`` instead of incorrectly using ``int64`` (:issue:`32255`)\n- :meth:`Series.to_timestamp` now raises a ``TypeError`` if the axis is not a :class:`PeriodIndex`. Previously an ``AttributeError`` was raised (:issue:`33327`)\n- :meth:`Series.to_period` now raises a ``TypeError`` if the axis is not a :class:`DatetimeIndex`. Previously an ``AttributeError`` was raised (:issue:`33327`)\n- :class:`Period` no longer accepts tuples for the ``freq`` argument (:issue:`34658`)\n- Bug in :class:`Timestamp` where constructing a :class:`Timestamp` from ambiguous epoch time and calling constructor again changed the :meth:`Timestamp.value` property (:issue:`24329`)\n- :meth:`DatetimeArray.searchsorted`, :meth:`TimedeltaArray.searchsorted`, :meth:`PeriodArray.searchsorted` not recognizing non-pandas scalars and incorrectly raising ``ValueError`` instead of ``TypeError`` (:issue:`30950`)\n- Bug in :class:`Timestamp` where constructing :class:`Timestamp` with dateutil timezone less than 128 nanoseconds before daylight saving time switch from winter to summer would result in nonexistent time (:issue:`31043`)\n- Bug in :meth:`Period.to_timestamp`, :meth:`Period.start_time` with microsecond frequency returning a timestamp one nanosecond earlier than the correct time (:issue:`31475`)\n- :class:`Timestamp` raised a confusing error message when year, month or day is missing (:issue:`31200`)\n- Bug in :class:`DatetimeIndex` constructor incorrectly accepting ``bool``-dtype inputs (:issue:`32668`)\n- Bug in :meth:`DatetimeIndex.searchsorted` not accepting a ``list`` or :class:`Series` as its argument (:issue:`32762`)\n- Bug where :meth:`PeriodIndex` raised when passed a :class:`Series` of strings (:issue:`26109`)\n- Bug in :class:`Timestamp` arithmetic when adding or subtracting an ``np.ndarray`` with ``timedelta64`` dtype (:issue:`33296`)\n- Bug in :meth:`DatetimeIndex.to_period` not inferring the frequency when called with no arguments (:issue:`33358`)\n- Bug in :meth:`DatetimeIndex.tz_localize` incorrectly retaining ``freq`` in some cases where the original ``freq`` is no longer valid (:issue:`30511`)\n- Bug in :meth:`DatetimeIndex.intersection` losing ``freq`` and timezone in some cases (:issue:`33604`)\n- Bug in :meth:`DatetimeIndex.get_indexer` where incorrect output would be returned for mixed datetime-like targets (:issue:`33741`)\n- Bug in :class:`DatetimeIndex` addition and subtraction with some types of :class:`DateOffset` objects incorrectly retaining an invalid ``freq`` attribute (:issue:`33779`)\n- Bug in :class:`DatetimeIndex` where setting the ``freq`` attribute on an index could silently change the ``freq`` attribute on another index viewing the same data (:issue:`33552`)\n- :meth:`DataFrame.min` and :meth:`DataFrame.max` were not returning consistent results with :meth:`Series.min` and :meth:`Series.max` when called on objects initialized with empty :func:`pd.to_datetime`\n- Bug in :meth:`DatetimeIndex.intersection` and :meth:`TimedeltaIndex.intersection` with results not having the correct ``name`` attribute (:issue:`33904`)\n- Bug in :meth:`DatetimeArray.__setitem__`, :meth:`TimedeltaArray.__setitem__`, :meth:`PeriodArray.__setitem__` incorrectly allowing values with ``int64`` dtype to be silently cast (:issue:`33717`)\n- Bug in subtracting :class:`TimedeltaIndex` from :class:`Period` incorrectly raising ``TypeError`` in some cases where it should succeed and ``IncompatibleFrequency`` in some cases where it should raise ``TypeError`` (:issue:`33883`)\n- Bug in constructing a :class:`Series` or :class:`Index` from a read-only NumPy array with non-ns\n  resolution which converted to object dtype instead of coercing to ``datetime64[ns]``\n  dtype when within the timestamp bounds (:issue:`34843`).\n- The ``freq`` keyword in :class:`Period`, :func:`date_range`, :func:`period_range`, :func:`pd.tseries.frequencies.to_offset` no longer allows tuples, pass as string instead (:issue:`34703`)\n- Bug in :meth:`DataFrame.append` when appending a :class:`Series` containing a scalar tz-aware :class:`Timestamp` to an empty :class:`DataFrame` resulted in an object column instead of ``datetime64[ns, tz]`` dtype (:issue:`35038`)\n- ``OutOfBoundsDatetime`` issues an improved error message when timestamp is out of implementation bounds. (:issue:`32967`)\n- Bug in :meth:`AbstractHolidayCalendar.holidays` when no rules were defined (:issue:`31415`)\n- Bug in :class:`Tick` comparisons raising ``TypeError`` when comparing against timedelta-like objects (:issue:`34088`)\n- Bug in :class:`Tick` multiplication raising ``TypeError`` when multiplying by a float (:issue:`34486`)\n\nTimedelta\n^^^^^^^^^\n\n- Bug in constructing a :class:`Timedelta` with a high precision integer that would round the :class:`Timedelta` components (:issue:`31354`)\n- Bug in dividing ``np.nan`` or ``None`` by :class:`Timedelta` incorrectly returning ``NaT`` (:issue:`31869`)\n- :class:`Timedelta` now understands ``\u00c2\u00b5s`` as an identifier for microsecond (:issue:`32899`)\n- :class:`Timedelta` string representation now includes nanoseconds, when nanoseconds are non-zero (:issue:`9309`)\n- Bug in comparing a :class:`Timedelta` object against an ``np.ndarray`` with ``timedelta64`` dtype incorrectly viewing all entries as unequal (:issue:`33441`)\n- Bug in :func:`timedelta_range` that produced an extra point on a edge case (:issue:`30353`, :issue:`33498`)\n- Bug in :meth:`DataFrame.resample` that produced an extra point on a edge case (:issue:`30353`, :issue:`13022`, :issue:`33498`)\n- Bug in :meth:`DataFrame.resample` that ignored the ``loffset`` argument when dealing with timedelta (:issue:`7687`, :issue:`33498`)\n- Bug in :class:`Timedelta` and :func:`pandas.to_timedelta` that ignored the ``unit`` argument for string input (:issue:`12136`)\n\nTimezones\n^^^^^^^^^\n\n- Bug in :func:`to_datetime` with ``infer_datetime_format=True`` where timezone names (e.g. ``UTC``) would not be parsed correctly (:issue:`33133`)\n\n\nNumeric\n^^^^^^^\n- Bug in :meth:`DataFrame.floordiv` with ``axis=0`` not treating division-by-zero like :meth:`Series.floordiv` (:issue:`31271`)\n- Bug in :func:`to_numeric` with string argument ``\"uint64\"`` and ``errors=\"coerce\"`` silently fails (:issue:`32394`)\n- Bug in :func:`to_numeric` with ``downcast=\"unsigned\"`` fails for empty data (:issue:`32493`)\n- Bug in :meth:`DataFrame.mean` with ``numeric_only=False`` and either ``datetime64`` dtype or ``PeriodDtype`` column incorrectly raising ``TypeError`` (:issue:`32426`)\n- Bug in :meth:`DataFrame.count` with ``level=\"foo\"`` and index level ``\"foo\"`` containing NaNs causes segmentation fault (:issue:`21824`)\n- Bug in :meth:`DataFrame.diff` with ``axis=1`` returning incorrect results with mixed dtypes (:issue:`32995`)\n- Bug in :meth:`DataFrame.corr` and :meth:`DataFrame.cov` raising when handling nullable integer columns with ``pandas.NA`` (:issue:`33803`)\n- Bug in arithmetic operations between :class:`DataFrame` objects with non-overlapping columns with duplicate labels causing an infinite loop (:issue:`35194`)\n- Bug in :class:`DataFrame` and :class:`Series` addition and subtraction between object-dtype objects and ``datetime64`` dtype objects (:issue:`33824`)\n- Bug in :meth:`Index.difference` giving incorrect results when comparing a :class:`Float64Index` and object :class:`Index` (:issue:`35217`)\n- Bug in :class:`DataFrame` reductions (e.g. ``df.min()``, ``df.max()``) with ``ExtensionArray`` dtypes (:issue:`34520`, :issue:`32651`)\n- :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` now raise a ValueError if ``limit_direction`` is ``'forward'`` or ``'both'`` and ``method`` is ``'backfill'`` or ``'bfill'`` or ``limit_direction`` is ``'backward'`` or ``'both'`` and ``method`` is ``'pad'`` or ``'ffill'`` (:issue:`34746`)\n\nConversion\n^^^^^^^^^^\n- Bug in :class:`Series` construction from NumPy array with big-endian ``datetime64`` dtype (:issue:`29684`)\n- Bug in :class:`Timedelta` construction with large nanoseconds keyword value (:issue:`32402`)\n- Bug in :class:`DataFrame` construction where sets would be duplicated rather than raising (:issue:`32582`)\n- The :class:`DataFrame` constructor no longer accepts a list of :class:`DataFrame` objects. Because of changes to NumPy, :class:`DataFrame` objects are now consistently treated as 2D objects, so a list of :class:`DataFrame` objects is considered 3D, and no longer acceptable for the :class:`DataFrame` constructor (:issue:`32289`).\n- Bug in :class:`DataFrame` when initiating a frame with lists and assign ``columns`` with nested list for ``MultiIndex`` (:issue:`32173`)\n- Improved error message for invalid construction of list when creating a new index (:issue:`35190`)\n\n\nStrings\n^^^^^^^\n\n- Bug in the :meth:`~Series.astype` method when converting \"string\" dtype data to nullable integer dtype (:issue:`32450`).\n- Fixed issue where taking ``min`` or ``max`` of a ``StringArray`` or ``Series`` with ``StringDtype`` type would raise. (:issue:`31746`)\n- Bug in :meth:`Series.str.cat` returning ``NaN`` output when other had :class:`Index` type (:issue:`33425`)\n- :func:`pandas.api.dtypes.is_string_dtype` no longer incorrectly identifies categorical series as string.\n\nInterval\n^^^^^^^^\n- Bug in :class:`IntervalArray` incorrectly allowing the underlying data to be changed when setting values (:issue:`32782`)\n\nIndexing\n^^^^^^^^\n\n- :meth:`DataFrame.xs` now raises a  ``TypeError`` if a ``level`` keyword is supplied and the axis is not a :class:`MultiIndex`. Previously an ``AttributeError`` was raised (:issue:`33610`)\n- Bug in slicing on a :class:`DatetimeIndex` with a partial-timestamp dropping high-resolution indices near the end of a year, quarter, or month (:issue:`31064`)\n- Bug in :meth:`PeriodIndex.get_loc` treating higher-resolution strings differently from :meth:`PeriodIndex.get_value` (:issue:`31172`)\n- Bug in :meth:`Series.at` and :meth:`DataFrame.at` not matching ``.loc`` behavior when looking up an integer in a :class:`Float64Index` (:issue:`31329`)\n- Bug in :meth:`PeriodIndex.is_monotonic` incorrectly returning ``True`` when containing leading ``NaT`` entries (:issue:`31437`)\n- Bug in :meth:`DatetimeIndex.get_loc` raising ``KeyError`` with converted-integer key instead of the user-passed key (:issue:`31425`)\n- Bug in :meth:`Series.xs` incorrectly returning ``Timestamp`` instead of ``datetime64`` in some object-dtype cases (:issue:`31630`)\n- Bug in :meth:`DataFrame.iat` incorrectly returning ``Timestamp`` instead of ``datetime`` in some object-dtype cases (:issue:`32809`)\n- Bug in :meth:`DataFrame.at` when either columns or index is non-unique (:issue:`33041`)\n- Bug in :meth:`Series.loc` and :meth:`DataFrame.loc` when indexing with an integer key on a object-dtype :class:`Index` that is not all-integers (:issue:`31905`)\n- Bug in :meth:`DataFrame.iloc.__setitem__` on a :class:`DataFrame` with duplicate columns incorrectly setting values for all matching columns (:issue:`15686`, :issue:`22036`)\n- Bug in :meth:`DataFrame.loc` and :meth:`Series.loc` with a :class:`DatetimeIndex`, :class:`TimedeltaIndex`, or :class:`PeriodIndex` incorrectly allowing lookups of non-matching datetime-like dtypes (:issue:`32650`)\n- Bug in :meth:`Series.__getitem__` indexing with non-standard scalars, e.g. ``np.dtype`` (:issue:`32684`)\n- Bug in :class:`Index` constructor where an unhelpful error message was raised for NumPy scalars (:issue:`33017`)\n- Bug in :meth:`DataFrame.lookup` incorrectly raising an ``AttributeError`` when ``frame.index`` or ``frame.columns`` is not unique; this will now raise a ``ValueError`` with a helpful error message (:issue:`33041`)\n- Bug in :class:`Interval` where a :class:`Timedelta` could not be added or subtracted from a :class:`Timestamp` interval (:issue:`32023`)\n- Bug in :meth:`DataFrame.copy` not invalidating _item_cache after copy caused post-copy value updates to not be reflected (:issue:`31784`)\n- Fixed regression in :meth:`DataFrame.loc` and :meth:`Series.loc` throwing an error when a ``datetime64[ns, tz]`` value is provided (:issue:`32395`)\n- Bug in :meth:`Series.__getitem__` with an integer key and a :class:`MultiIndex` with leading integer level failing to raise ``KeyError`` if the key is not present in the first level (:issue:`33355`)\n- Bug in :meth:`DataFrame.iloc` when slicing a single column :class:`DataFrame` with ``ExtensionDtype`` (e.g. ``df.iloc[:, :1]``) returning an invalid result (:issue:`32957`)\n- Bug in :meth:`DatetimeIndex.insert` and :meth:`TimedeltaIndex.insert` causing index ``freq`` to be lost when setting an element into an empty :class:`Series` (:issue:`33573`)\n- Bug in :meth:`Series.__setitem__` with an :class:`IntervalIndex` and a list-like key of integers (:issue:`33473`)\n- Bug in :meth:`Series.__getitem__` allowing missing labels with ``np.ndarray``, :class:`Index`, :class:`Series` indexers but not ``list``, these now all raise ``KeyError`` (:issue:`33646`)\n- Bug in :meth:`DataFrame.truncate` and :meth:`Series.truncate` where index was assumed to be monotone increasing (:issue:`33756`)\n- Indexing with a list of strings representing datetimes failed on :class:`DatetimeIndex` or :class:`PeriodIndex` (:issue:`11278`)\n- Bug in :meth:`Series.at` when used with a :class:`MultiIndex` would raise an exception on valid inputs (:issue:`26989`)\n- Bug in :meth:`DataFrame.loc` with dictionary of values changes columns with dtype of ``int`` to ``float`` (:issue:`34573`)\n- Bug in :meth:`Series.loc` when used with a :class:`MultiIndex` would raise an ``IndexingError`` when accessing a ``None`` value (:issue:`34318`)\n- Bug in :meth:`DataFrame.reset_index` and :meth:`Series.reset_index` would not preserve data types on an empty :class:`DataFrame` or :class:`Series` with a :class:`MultiIndex` (:issue:`19602`)\n- Bug in :class:`Series` and :class:`DataFrame` indexing with a ``time`` key on a :class:`DatetimeIndex` with ``NaT`` entries (:issue:`35114`)\n\nMissing\n^^^^^^^\n- Calling :meth:`fillna` on an empty :class:`Series` now correctly returns a shallow copied object. The behaviour is now consistent with :class:`Index`, :class:`DataFrame` and a non-empty :class:`Series` (:issue:`32543`).\n- Bug in :meth:`Series.replace` when argument ``to_replace`` is of type dict/list and is used on a :class:`Series` containing ``<NA>`` was raising a ``TypeError``. The method now handles this by ignoring ``<NA>`` values when doing the comparison for the replacement (:issue:`32621`)\n- Bug in :meth:`~Series.any` and :meth:`~Series.all` incorrectly returning ``<NA>`` for all ``False`` or all ``True`` values using the nulllable Boolean dtype and with ``skipna=False`` (:issue:`33253`)\n- Clarified documentation on interpolate with ``method=akima``. The ``der`` parameter must be scalar or ``None`` (:issue:`33426`)\n- :meth:`DataFrame.interpolate` uses the correct axis convention now. Previously interpolating along columns lead to interpolation along indices and vice versa. Furthermore interpolating with methods ``pad``, ``ffill``, ``bfill`` and ``backfill`` are identical to using these methods with :meth:`DataFrame.fillna` (:issue:`12918`, :issue:`29146`)\n- Bug in :meth:`DataFrame.interpolate` when called on a :class:`DataFrame` with column names of string type was throwing a ValueError. The method is now independent of the type of the column names (:issue:`33956`)\n- Passing :class:`NA` into a format string using format specs will now work. For example ``\"{:.1f}\".format(pd.NA)`` would previously raise a ``ValueError``, but will now return the string ``\"<NA>\"`` (:issue:`34740`)\n- Bug in :meth:`Series.map` not raising on invalid ``na_action`` (:issue:`32815`)\n\nMultiIndex\n^^^^^^^^^^\n\n- :meth:`DataFrame.swaplevels` now raises a ``TypeError`` if the axis is not a :class:`MultiIndex`. Previously an ``AttributeError`` was raised (:issue:`31126`)\n- Bug in :meth:`Dataframe.loc` when used with a :class:`MultiIndex`. The returned values were not in the same order as the given inputs (:issue:`22797`)\n\n.. ipython:: python\n\n        df = pd.DataFrame(np.arange(4),\n                          index=[[\"a\", \"a\", \"b\", \"b\"], [1, 2, 1, 2]])\n        # Rows are now ordered as the requested keys\n        df.loc[(['b', 'a'], [2, 1]), :]\n\n- Bug in :meth:`MultiIndex.intersection` was not guaranteed to preserve order when ``sort=False``. (:issue:`31325`)\n- Bug in :meth:`DataFrame.truncate` was dropping :class:`MultiIndex` names. (:issue:`34564`)\n\n.. ipython:: python\n\n        left = pd.MultiIndex.from_arrays([[\"b\", \"a\"], [2, 1]])\n        right = pd.MultiIndex.from_arrays([[\"a\", \"b\", \"c\"], [1, 2, 3]])\n        # Common elements are now guaranteed to be ordered by the left side\n        left.intersection(right, sort=False)\n\n- Bug when joining two :class:`MultiIndex` without specifying level with different columns. Return-indexers parameter was ignored. (:issue:`34074`)\n\nIO\n^^\n- Passing a ``set`` as ``names`` argument to :func:`pandas.read_csv`, :func:`pandas.read_table`, or :func:`pandas.read_fwf` will raise ``ValueError: Names should be an ordered collection.`` (:issue:`34946`)\n- Bug in print-out when ``display.precision`` is zero. (:issue:`20359`)\n- Bug in :func:`read_json` where integer overflow was occurring when json contains big number strings. (:issue:`30320`)\n- :func:`read_csv` will now raise a ``ValueError`` when the arguments ``header`` and ``prefix`` both are not ``None``. (:issue:`27394`)\n- Bug in :meth:`DataFrame.to_json` was raising ``NotFoundError`` when ``path_or_buf`` was an S3 URI (:issue:`28375`)\n- Bug in :meth:`DataFrame.to_parquet` overwriting pyarrow's default for\n  ``coerce_timestamps``; following pyarrow's default allows writing nanosecond\n  timestamps with ``version=\"2.0\"`` (:issue:`31652`).\n- Bug in :func:`read_csv` was raising ``TypeError`` when ``sep=None`` was used in combination with ``comment`` keyword (:issue:`31396`)\n- Bug in :class:`HDFStore` that caused it to set to ``int64`` the dtype of a ``datetime64`` column when reading a :class:`DataFrame` in Python 3 from fixed format written in Python 2 (:issue:`31750`)\n- :func:`read_sas()` now handles dates and datetimes larger than :attr:`Timestamp.max` returning them as :class:`datetime.datetime` objects (:issue:`20927`)\n- Bug in :meth:`DataFrame.to_json` where ``Timedelta`` objects would not be serialized correctly with ``date_format=\"iso\"`` (:issue:`28256`)\n- :func:`read_csv` will raise a ``ValueError`` when the column names passed in ``parse_dates`` are missing in the :class:`Dataframe` (:issue:`31251`)\n- Bug in :func:`read_excel` where a UTF-8 string with a high surrogate would cause a segmentation violation (:issue:`23809`)\n- Bug in :func:`read_csv` was causing a file descriptor leak on an empty file (:issue:`31488`)\n- Bug in :func:`read_csv` was causing a segfault when there were blank lines between the header and data rows (:issue:`28071`)\n- Bug in :func:`read_csv` was raising a misleading exception on a permissions issue (:issue:`23784`)\n- Bug in :func:`read_csv` was raising an ``IndexError`` when ``header=None`` and two extra data columns\n- Bug in :func:`read_sas` was raising an ``AttributeError`` when reading files from Google Cloud Storage (:issue:`33069`)\n- Bug in :meth:`DataFrame.to_sql` where an ``AttributeError`` was raised when saving an out of bounds date (:issue:`26761`)\n- Bug in :func:`read_excel` did not correctly handle multiple embedded spaces in OpenDocument text cells. (:issue:`32207`)\n- Bug in :func:`read_json` was raising ``TypeError`` when reading a ``list`` of Booleans into a :class:`Series`. (:issue:`31464`)\n- Bug in :func:`pandas.io.json.json_normalize` where location specified by ``record_path`` doesn't point to an array. (:issue:`26284`)\n- :func:`pandas.read_hdf` has a more explicit error message when loading an\n  unsupported HDF file (:issue:`9539`)\n- Bug in :meth:`~DataFrame.read_feather` was raising an ``ArrowIOError`` when reading an s3 or http file path (:issue:`29055`)\n- Bug in :meth:`~DataFrame.to_excel` could not handle the column name ``render`` and was raising an ``KeyError`` (:issue:`34331`)\n- Bug in :meth:`~SQLDatabase.execute` was raising a ``ProgrammingError`` for some DB-API drivers when the SQL statement contained the ``%`` character and no parameters were present (:issue:`34211`)\n- Bug in :meth:`~pandas.io.stata.StataReader` which resulted in categorical variables with different dtypes when reading data using an iterator. (:issue:`31544`)\n- :meth:`HDFStore.keys` has now an optional ``include`` parameter that allows the retrieval of all native HDF5 table names (:issue:`29916`)\n- ``TypeError`` exceptions raised by :func:`read_csv` and :func:`read_table` were showing as ``parser_f`` when an unexpected keyword argument was passed (:issue:`25648`)\n- Bug in :func:`read_excel` for ODS files removes 0.0 values (:issue:`27222`)\n- Bug in :func:`ujson.encode` was raising an ``OverflowError`` with numbers larger than ``sys.maxsize`` (:issue:`34395`)\n- Bug in :meth:`HDFStore.append_to_multiple` was raising a ``ValueError`` when the ``min_itemsize`` parameter is set (:issue:`11238`)\n- Bug in :meth:`~HDFStore.create_table` now raises an error when ``column`` argument was not specified in ``data_columns`` on input (:issue:`28156`)\n- :func:`read_json` now could read line-delimited json file from a file url while ``lines`` and ``chunksize`` are set.\n- Bug in :meth:`DataFrame.to_sql` when reading DataFrames with ``-np.inf`` entries with MySQL now has a more explicit ``ValueError`` (:issue:`34431`)\n- Bug where capitalised files extensions were not decompressed by read_* functions (:issue:`35164`)\n- Bug in :meth:`read_excel` that was raising a ``TypeError`` when ``header=None`` and ``index_col`` is given as a ``list`` (:issue:`31783`)\n- Bug in :func:`read_excel` where datetime values are used in the header in a :class:`MultiIndex` (:issue:`34748`)\n- :func:`read_excel` no longer takes ``**kwds`` arguments. This means that passing in the keyword argument ``chunksize`` now raises a ``TypeError`` (previously raised a ``NotImplementedError``), while passing in the keyword argument ``encoding`` now raises a ``TypeError`` (:issue:`34464`)\n- Bug in :meth:`DataFrame.to_records` was incorrectly losing timezone information in timezone-aware ``datetime64`` columns (:issue:`32535`)\n\nPlotting\n^^^^^^^^\n\n- :meth:`DataFrame.plot` for line/bar now accepts color by dictionary (:issue:`8193`).\n- Bug in :meth:`DataFrame.plot.hist` where weights are not working for multiple columns (:issue:`33173`)\n- Bug in :meth:`DataFrame.boxplot` and :meth:`DataFrame.plot.boxplot` lost color attributes of ``medianprops``, ``whiskerprops``, ``capprops`` and ``boxprops`` (:issue:`30346`)\n- Bug in :meth:`DataFrame.hist` where the order of ``column`` argument was ignored (:issue:`29235`)\n- Bug in :meth:`DataFrame.plot.scatter` that when adding multiple plots with different ``cmap``, colorbars always use the first ``cmap`` (:issue:`33389`)\n- Bug in :meth:`DataFrame.plot.scatter` was adding a colorbar to the plot even if the argument ``c`` was assigned to a column containing color names (:issue:`34316`)\n- Bug in :meth:`pandas.plotting.bootstrap_plot` was causing cluttered axes and overlapping labels (:issue:`34905`)\n- Bug in :meth:`DataFrame.plot.scatter` caused an error when plotting variable marker sizes (:issue:`32904`)\n\nGroupBy/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n- Using a :class:`pandas.api.indexers.BaseIndexer` with ``count``, ``min``, ``max``, ``median``, ``skew``,  ``cov``, ``corr`` will now return correct results for any monotonic :class:`pandas.api.indexers.BaseIndexer` descendant (:issue:`32865`)\n- :meth:`DataFrameGroupby.mean` and :meth:`SeriesGroupby.mean` (and similarly for :meth:`~DataFrameGroupby.median`, :meth:`~DataFrameGroupby.std` and :meth:`~DataFrameGroupby.var`) now raise a ``TypeError`` if a non-accepted keyword argument is passed into it. Previously an ``UnsupportedFunctionCall`` was raised (``AssertionError`` if ``min_count`` passed into :meth:`~DataFrameGroupby.median`) (:issue:`31485`)\n- Bug in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` raising ``ValueError`` when the ``by`` axis is not sorted, has duplicates, and the applied ``func`` does not mutate passed in objects (:issue:`30667`)\n- Bug in :meth:`DataFrameGroupBy.transform` produces an incorrect result with transformation functions (:issue:`30918`)\n- Bug in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` were returning the wrong result when grouping by multiple keys of which some were categorical and others not (:issue:`32494`)\n- Bug in :meth:`.DataFrameGroupBy.count` and :meth:`.SeriesGroupBy.count` causing segmentation fault when grouped-by columns contain NaNs (:issue:`32841`)\n- Bug in :meth:`DataFrame.groupby` and :meth:`Series.groupby` produces inconsistent type when aggregating Boolean :class:`Series` (:issue:`32894`)\n- Bug in :meth:`DataFrameGroupBy.sum` and :meth:`SeriesGroupBy.sum` where a large negative number would be returned when the number of non-null values was below ``min_count`` for nullable integer dtypes (:issue:`32861`)\n- Bug in :meth:`SeriesGroupBy.quantile` was raising on nullable integers (:issue:`33136`)\n- Bug in :meth:`DataFrame.resample` where an ``AmbiguousTimeError`` would be raised when the resulting timezone aware :class:`DatetimeIndex` had a DST transition at midnight (:issue:`25758`)\n- Bug in :meth:`DataFrame.groupby` where a ``ValueError`` would be raised when grouping by a categorical column with read-only categories and ``sort=False`` (:issue:`33410`)\n- Bug in :meth:`.DataFrameGroupBy.agg`, :meth:`.SeriesGroupBy.agg`, :meth:`.DataFrameGroupBy.transform`, :meth:`.SeriesGroupBy.transform`, :meth:`.DataFrameGroupBy.resample`, and :meth:`.SeriesGroupBy.resample` where subclasses are not preserved (:issue:`28330`)\n- Bug in :meth:`SeriesGroupBy.agg` where any column name was accepted in the named aggregation of :class:`SeriesGroupBy` previously. The behaviour now allows only ``str`` and callables else would raise ``TypeError``. (:issue:`34422`)\n- Bug in :meth:`DataFrame.groupby` lost the name of the :class:`Index` when one of the ``agg`` keys referenced an empty list (:issue:`32580`)\n- Bug in :meth:`Rolling.apply` where ``center=True`` was ignored when ``engine='numba'`` was specified (:issue:`34784`)\n- Bug in :meth:`DataFrame.ewm.cov` was throwing ``AssertionError`` for :class:`MultiIndex` inputs (:issue:`34440`)\n- Bug in :meth:`core.groupby.DataFrameGroupBy.quantile` raised ``TypeError`` for non-numeric types rather than dropping the columns (:issue:`27892`)\n- Bug in :meth:`core.groupby.DataFrameGroupBy.transform` when ``func='nunique'`` and columns are of type ``datetime64``, the result would also be of type ``datetime64`` instead of ``int64`` (:issue:`35109`)\n- Bug in :meth:`DataFrame.groupby` raising an ``AttributeError`` when selecting a column and aggregating with ``as_index=False`` (:issue:`35246`).\n- Bug in :meth:`DataFrameGroupBy.first` and :meth:`DataFrameGroupBy.last` that would raise an unnecessary ``ValueError`` when grouping on multiple ``Categoricals`` (:issue:`34951`)\n\nReshaping\n^^^^^^^^^\n\n- Bug effecting all numeric and Boolean reduction methods not returning subclassed data type. (:issue:`25596`)\n- Bug in :meth:`DataFrame.pivot_table` when only :class:`MultiIndexed` columns is set (:issue:`17038`)\n- Bug in :meth:`DataFrame.unstack` and :meth:`Series.unstack` can take tuple names in :class:`MultiIndexed` data (:issue:`19966`)\n- Bug in :meth:`DataFrame.pivot_table` when ``margin`` is ``True`` and only ``column`` is defined (:issue:`31016`)\n- Fixed incorrect error message in :meth:`DataFrame.pivot` when ``columns`` is set to ``None``. (:issue:`30924`)\n- Bug in :func:`crosstab` when inputs are two :class:`Series` and have tuple names, the output will keep a dummy :class:`MultiIndex` as columns. (:issue:`18321`)\n- :meth:`DataFrame.pivot` can now take lists for ``index`` and ``columns`` arguments (:issue:`21425`)\n- Bug in :func:`concat` where the resulting indices are not copied when ``copy=True`` (:issue:`29879`)\n- Bug in :meth:`SeriesGroupBy.aggregate` was resulting in aggregations being overwritten when they shared the same name (:issue:`30880`)\n- Bug where :meth:`Index.astype` would lose the :attr:`name` attribute when converting from ``Float64Index`` to ``Int64Index``, or when casting to an ``ExtensionArray`` dtype (:issue:`32013`)\n- :meth:`Series.append` will now raise a ``TypeError`` when passed a :class:`DataFrame` or a sequence containing :class:`DataFrame` (:issue:`31413`)\n- :meth:`DataFrame.replace` and :meth:`Series.replace` will raise a ``TypeError`` if ``to_replace`` is not an expected type. Previously the ``replace`` would fail silently (:issue:`18634`)\n- Bug on inplace operation of a :class:`Series` that was adding a column to the :class:`DataFrame` from where it was originally dropped from (using ``inplace=True``) (:issue:`30484`)\n- Bug in :meth:`DataFrame.apply` where callback was called with :class:`Series` parameter even though ``raw=True`` requested. (:issue:`32423`)\n- Bug in :meth:`DataFrame.pivot_table` losing timezone information when creating a :class:`MultiIndex` level from a column with timezone-aware dtype (:issue:`32558`)\n- Bug in :func:`concat` where when passing a non-dict mapping as ``objs`` would raise a ``TypeError`` (:issue:`32863`)\n- :meth:`DataFrame.agg` now provides more descriptive ``SpecificationError`` message when attempting to aggregate a non-existent column (:issue:`32755`)\n- Bug in :meth:`DataFrame.unstack` when :class:`MultiIndex` columns and :class:`MultiIndex` rows were used (:issue:`32624`, :issue:`24729` and :issue:`28306`)\n- Appending a dictionary to a :class:`DataFrame` without passing ``ignore_index=True`` will raise ``TypeError: Can only append a dict if ignore_index=True`` instead of ``TypeError: Can only append a :class:`Series` if ignore_index=True or if the :class:`Series` has a name`` (:issue:`30871`)\n- Bug in :meth:`DataFrame.corrwith()`, :meth:`DataFrame.memory_usage()`, :meth:`DataFrame.dot()`,\n  :meth:`DataFrame.idxmin()`, :meth:`DataFrame.idxmax()`, :meth:`DataFrame.duplicated()`, :meth:`DataFrame.isin()`,\n  :meth:`DataFrame.count()`, :meth:`Series.explode()`, :meth:`Series.asof()` and :meth:`DataFrame.asof()` not\n  returning subclassed types. (:issue:`31331`)\n- Bug in :func:`concat` was not allowing for concatenation of :class:`DataFrame` and :class:`Series` with duplicate keys (:issue:`33654`)\n- Bug in :func:`cut` raised an error when the argument ``labels`` contains duplicates (:issue:`33141`)\n- Ensure only named functions can be used in :func:`eval()` (:issue:`32460`)\n- Bug in :meth:`Dataframe.aggregate` and :meth:`Series.aggregate` was causing a recursive loop in some cases (:issue:`34224`)\n- Fixed bug in :func:`melt` where melting :class:`MultiIndex` columns with ``col_level > 0`` would raise a ``KeyError`` on ``id_vars`` (:issue:`34129`)\n- Bug in :meth:`Series.where` with an empty :class:`Series` and empty ``cond`` having non-bool dtype (:issue:`34592`)\n- Fixed regression where :meth:`DataFrame.apply` would raise ``ValueError`` for elements with ``S`` dtype (:issue:`34529`)\n\nSparse\n^^^^^^\n- Creating a :class:`SparseArray` from timezone-aware dtype will issue a warning before dropping timezone information, instead of doing so silently (:issue:`32501`)\n- Bug in :meth:`arrays.SparseArray.from_spmatrix` wrongly read scipy sparse matrix (:issue:`31991`)\n- Bug in :meth:`Series.sum` with ``SparseArray`` raised a ``TypeError`` (:issue:`25777`)\n- Bug where :class:`DataFrame` containing an all-sparse :class:`SparseArray` filled with ``NaN`` when indexed by a list-like (:issue:`27781`, :issue:`29563`)\n- The repr of :class:`SparseDtype` now includes the repr of its ``fill_value`` attribute. Previously it used ``fill_value``'s  string representation (:issue:`34352`)\n- Bug where empty :class:`DataFrame` could not be cast to :class:`SparseDtype` (:issue:`33113`)\n- Bug in :meth:`arrays.SparseArray` was returning the incorrect type when indexing a sparse dataframe with an iterable (:issue:`34526`, :issue:`34540`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n\n- Fixed bug where :meth:`Series.value_counts` would raise on empty input of ``Int64`` dtype (:issue:`33317`)\n- Fixed bug in :func:`concat` when concatenating :class:`DataFrame` objects with non-overlapping columns resulting in object-dtype columns rather than preserving the extension dtype (:issue:`27692`, :issue:`33027`)\n- Fixed bug where :meth:`StringArray.isna` would return ``False`` for NA values when ``pandas.options.mode.use_inf_as_na`` was set to ``True`` (:issue:`33655`)\n- Fixed bug in :class:`Series` construction with EA dtype and index but no data or scalar data fails (:issue:`26469`)\n- Fixed bug that caused :meth:`Series.__repr__()` to crash for extension types whose elements are multidimensional arrays (:issue:`33770`).\n- Fixed bug where :meth:`Series.update` would raise a ``ValueError`` for ``ExtensionArray`` dtypes with missing values (:issue:`33980`)\n- Fixed bug where :meth:`StringArray.memory_usage` was not implemented (:issue:`33963`)\n- Fixed bug where :meth:`DataFrameGroupBy` would ignore the ``min_count`` argument for aggregations on nullable Boolean dtypes (:issue:`34051`)\n- Fixed bug where the constructor of :class:`DataFrame` with ``dtype='string'`` would fail (:issue:`27953`, :issue:`33623`)\n- Bug where :class:`DataFrame` column set to scalar extension type was considered an object type rather than the extension type (:issue:`34832`)\n- Fixed bug in :meth:`IntegerArray.astype` to correctly copy the mask as well (:issue:`34931`).\n\nOther\n^^^^^\n\n- Set operations on an object-dtype :class:`Index` now always return object-dtype results (:issue:`31401`)\n- Fixed :func:`pandas.testing.assert_series_equal` to correctly raise if the ``left`` argument is a different subclass with ``check_series_type=True`` (:issue:`32670`).\n- Getting a missing attribute in a :meth:`DataFrame.query` or :meth:`DataFrame.eval` string raises the correct ``AttributeError`` (:issue:`32408`)\n- Fixed bug in :func:`pandas.testing.assert_series_equal` where dtypes were checked for ``Interval`` and ``ExtensionArray`` operands when ``check_dtype`` was ``False`` (:issue:`32747`)\n- Bug in :meth:`DataFrame.__dir__` caused a segfault when using unicode surrogates in a column name (:issue:`25509`)\n- Bug in :meth:`DataFrame.equals` and :meth:`Series.equals` in allowing subclasses to be equal (:issue:`34402`).\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_110.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.0.5..v1.1.0|HEAD\n", "0.5.0": "\n.. _whatsnew_050:\n\nVersion 0.5.0 (October 24, 2011)\n--------------------------------\n\n{{ header }}\n\nNew features\n~~~~~~~~~~~~\n\n- :ref:`Added <basics.df_join>` ``DataFrame.align`` method with standard join options\n- :ref:`Added <io.parse_dates>` ``parse_dates`` option to ``read_csv`` and ``read_table`` methods to optionally try to parse dates in the index columns\n- :ref:`Added <io.parse_dates>` ``nrows``, ``chunksize``, and ``iterator`` arguments to ``read_csv`` and ``read_table``. The last two return a new ``TextParser`` class capable of lazily iterating through chunks of a flat file (:issue:`242`)\n- :ref:`Added <merging.multikey_join>` ability to join on multiple columns in ``DataFrame.join`` (:issue:`214`)\n- Added private ``_get_duplicates`` function to ``Index`` for identifying duplicate values more easily (ENH5c_)\n- :ref:`Added <indexing.df_cols>` column attribute access to DataFrame.\n- :ref:`Added <indexing.df_cols>` Python tab completion hook for DataFrame columns. (:issue:`233`, :issue:`230`)\n- :ref:`Implemented <basics.describe>` ``Series.describe`` for Series containing objects (:issue:`241`)\n- :ref:`Added <merging.df_inner_join>` inner join option to ``DataFrame.join`` when joining on key(s) (:issue:`248`)\n- :ref:`Implemented <indexing.df_cols>` selecting DataFrame columns by passing a list to ``__getitem__`` (:issue:`253`)\n- :ref:`Implemented <indexing.set_ops>` & and | to intersect / union Index objects, respectively (:issue:`261`)\n- :ref:`Added<reshaping.pivot>` ``pivot_table`` convenience function to pandas namespace (:issue:`234`)\n- :ref:`Implemented <basics.rename_axis>` ``Panel.rename_axis`` function (:issue:`243`)\n- DataFrame will show index level names in console output (:issue:`334`)\n- :ref:`Implemented <advanced.take>` ``Panel.take``\n- :ref:`Added<basics.console_output>` ``set_eng_float_format`` for alternate DataFrame floating point string formatting (ENH61_)\n- :ref:`Added <indexing.set_index>` convenience ``set_index`` function for creating a DataFrame index from its existing columns\n- :ref:`Implemented <groupby.multiindex>` ``groupby`` hierarchical index level name  (:issue:`223`)\n- :ref:`Added <io.store_in_csv>` support for different delimiters in ``DataFrame.to_csv`` (:issue:`244`)\n\nPerformance enhancements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n- VBENCH Major performance improvements in file parsing functions ``read_csv`` and ``read_table``\n- VBENCH Added Cython function for converting tuples to ndarray very fast. Speeds up many MultiIndex-related operations\n- VBENCH Refactored merging / joining code into a tidy class and disabled unnecessary computations in the float/object case, thus getting about 10% better performance (:issue:`211`)\n- VBENCH Improved speed of ``DataFrame.xs`` on mixed-type DataFrame objects by about 5x, regression from 0.3.0 (:issue:`215`)\n- VBENCH With new ``DataFrame.align`` method, speeding up binary operations between differently-indexed DataFrame objects by 10-25%.\n- VBENCH Significantly sped up conversion of nested dict into DataFrame (:issue:`212`)\n- VBENCH Significantly speed up DataFrame ``__repr__`` and ``count`` on large mixed-type DataFrame objects\n\n.. _ENH61: https://github.com/pandas-dev/pandas/commit/6141961\n.. _ENH5c: https://github.com/pandas-dev/pandas/commit/5ca6ff5d822ee4ddef1ec0d87b6d83d8b4bbd3eb\n\n\n.. _whatsnew_0.5.0.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.4.0..v0.5.0\n", "2.2.1": ".. _whatsnew_221:\n\nWhat's new in 2.2.1 (February 22, 2024)\n---------------------------------------\n\nThese are the changes in pandas 2.2.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_221.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n- Added ``pyarrow`` pip extra so users can install pandas and pyarrow with pip with ``pip install pandas[pyarrow]`` (:issue:`54466`)\n\n.. _whatsnew_221.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed memory leak in :func:`read_csv` (:issue:`57039`)\n- Fixed performance regression in :meth:`Series.combine_first` (:issue:`55845`)\n- Fixed regression causing overflow for near-minimum timestamps (:issue:`57150`)\n- Fixed regression in :func:`concat` changing long-standing behavior that always sorted the non-concatenation axis when the axis was a :class:`DatetimeIndex` (:issue:`57006`)\n- Fixed regression in :func:`merge_ordered` raising ``TypeError`` for ``fill_method=\"ffill\"`` and ``how=\"left\"`` (:issue:`57010`)\n- Fixed regression in :func:`pandas.testing.assert_series_equal` defaulting to ``check_exact=True`` when checking the :class:`Index` (:issue:`57067`)\n- Fixed regression in :func:`read_json` where an :class:`Index` would be returned instead of a :class:`RangeIndex` (:issue:`57429`)\n- Fixed regression in :func:`wide_to_long` raising an ``AttributeError`` for string columns (:issue:`57066`)\n- Fixed regression in :meth:`.DataFrameGroupBy.idxmin`, :meth:`.DataFrameGroupBy.idxmax`, :meth:`.SeriesGroupBy.idxmin`, :meth:`.SeriesGroupBy.idxmax` ignoring the ``skipna`` argument (:issue:`57040`)\n- Fixed regression in :meth:`.DataFrameGroupBy.idxmin`, :meth:`.DataFrameGroupBy.idxmax`, :meth:`.SeriesGroupBy.idxmin`, :meth:`.SeriesGroupBy.idxmax` where values containing the minimum or maximum value for the dtype could produce incorrect results (:issue:`57040`)\n- Fixed regression in :meth:`CategoricalIndex.difference` raising ``KeyError`` when other contains null values other than NaN (:issue:`57318`)\n- Fixed regression in :meth:`DataFrame.groupby` raising ``ValueError`` when grouping by a :class:`Series` in some cases (:issue:`57276`)\n- Fixed regression in :meth:`DataFrame.loc` raising ``IndexError`` for non-unique, masked dtype indexes where result has more than 10,000 rows (:issue:`57027`)\n- Fixed regression in :meth:`DataFrame.loc` which was unnecessarily throwing \"incompatible dtype warning\" when expanding with partial row indexer and multiple columns (see `PDEP6 <https://pandas.pydata.org/pdeps/0006-ban-upcasting.html>`_) (:issue:`56503`)\n- Fixed regression in :meth:`DataFrame.map` with ``na_action=\"ignore\"`` not being respected for NumPy nullable and :class:`ArrowDtypes` (:issue:`57316`)\n- Fixed regression in :meth:`DataFrame.merge` raising ``ValueError`` for certain types of 3rd-party extension arrays (:issue:`57316`)\n- Fixed regression in :meth:`DataFrame.query` with all ``NaT`` column with object dtype (:issue:`57068`)\n- Fixed regression in :meth:`DataFrame.shift` raising ``AssertionError`` for ``axis=1`` and empty :class:`DataFrame` (:issue:`57301`)\n- Fixed regression in :meth:`DataFrame.sort_index` not producing a stable sort for a index with duplicates (:issue:`57151`)\n- Fixed regression in :meth:`DataFrame.to_dict` with ``orient='list'`` and datetime or timedelta types returning integers (:issue:`54824`)\n- Fixed regression in :meth:`DataFrame.to_json` converting nullable integers to floats (:issue:`57224`)\n- Fixed regression in :meth:`DataFrame.to_sql` when ``method=\"multi\"`` is passed and the dialect type is not Oracle (:issue:`57310`)\n- Fixed regression in :meth:`DataFrame.transpose` with nullable extension dtypes not having F-contiguous data potentially causing exceptions when used (:issue:`57315`)\n- Fixed regression in :meth:`DataFrame.update` emitting incorrect warnings about downcasting (:issue:`57124`)\n- Fixed regression in :meth:`DataFrameGroupBy.idxmin`, :meth:`DataFrameGroupBy.idxmax`, :meth:`SeriesGroupBy.idxmin`, :meth:`SeriesGroupBy.idxmax` ignoring the ``skipna`` argument (:issue:`57040`)\n- Fixed regression in :meth:`DataFrameGroupBy.idxmin`, :meth:`DataFrameGroupBy.idxmax`, :meth:`SeriesGroupBy.idxmin`, :meth:`SeriesGroupBy.idxmax` where values containing the minimum or maximum value for the dtype could produce incorrect results (:issue:`57040`)\n- Fixed regression in :meth:`ExtensionArray.to_numpy` raising for non-numeric masked dtypes (:issue:`56991`)\n- Fixed regression in :meth:`Index.join` raising ``TypeError`` when joining an empty index to a non-empty index containing mixed dtype values (:issue:`57048`)\n- Fixed regression in :meth:`Series.astype` introducing decimals when converting from integer with missing values to string dtype (:issue:`57418`)\n- Fixed regression in :meth:`Series.pct_change` raising a ``ValueError`` for an empty :class:`Series` (:issue:`57056`)\n- Fixed regression in :meth:`Series.to_numpy` when dtype is given as float and the data contains NaNs (:issue:`57121`)\n- Fixed regression in addition or subtraction of :class:`DateOffset` objects with millisecond components to ``datetime64`` :class:`Index`, :class:`Series`, or :class:`DataFrame` (:issue:`57529`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_221.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fixed bug in :func:`pandas.api.interchange.from_dataframe` which was raising for Nullable integers (:issue:`55069`)\n- Fixed bug in :func:`pandas.api.interchange.from_dataframe` which was raising for empty inputs (:issue:`56700`)\n- Fixed bug in :func:`pandas.api.interchange.from_dataframe` which wasn't converting columns names to strings (:issue:`55069`)\n- Fixed bug in :meth:`DataFrame.__getitem__` for empty :class:`DataFrame` with Copy-on-Write enabled (:issue:`57130`)\n- Fixed bug in :meth:`PeriodIndex.asfreq` which was silently converting frequencies which are not supported as period frequencies instead of raising an error (:issue:`56945`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_221.other:\n\nOther\n~~~~~\n\n.. note::\n\n    The ``DeprecationWarning`` that was raised when pandas was imported without PyArrow being\n    installed has been removed. This decision was made because the warning was too noisy for too\n    many users and a lot of feedback was collected about the decision to make PyArrow a required\n    dependency. Pandas is currently considering the decision whether or not PyArrow should be added\n    as a hard dependency in 3.0. Interested users can follow the discussion\n    `here <https://github.com/pandas-dev/pandas/issues/57073>`_.\n\n- Added the argument ``skipna`` to :meth:`DataFrameGroupBy.first`, :meth:`DataFrameGroupBy.last`, :meth:`SeriesGroupBy.first`, and :meth:`SeriesGroupBy.last`; achieving ``skipna=False`` used to be available via :meth:`DataFrameGroupBy.nth`, but the behavior was changed in pandas 2.0.0 (:issue:`57019`)\n- Added the argument ``skipna`` to :meth:`Resampler.first`, :meth:`Resampler.last` (:issue:`57019`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_221.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.2.0..v2.2.1\n", "1.5.3": ".. _whatsnew_153:\n\nWhat's new in 1.5.3 (January 18, 2023)\n--------------------------------------\n\nThese are the changes in pandas 1.5.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_153.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed performance regression in :meth:`Series.isin` when ``values`` is empty (:issue:`49839`)\n- Fixed regression in :meth:`DataFrame.memory_usage` showing unnecessary ``FutureWarning`` when :class:`DataFrame` is empty (:issue:`50066`)\n- Fixed regression in :meth:`.DataFrameGroupBy.transform` when used with ``as_index=False`` (:issue:`49834`)\n- Enforced reversion of ``color`` as an alias for ``c`` and ``size`` as an alias for ``s`` in function :meth:`DataFrame.plot.scatter` (:issue:`49732`)\n- Fixed regression in :meth:`.SeriesGroupBy.apply` setting a ``name`` attribute on the result if the result was a :class:`DataFrame` (:issue:`49907`)\n- Fixed performance regression in setting with the :meth:`~DataFrame.at` indexer (:issue:`49771`)\n- Fixed regression in :func:`to_datetime` raising ``ValueError`` when parsing array of ``float`` containing ``np.nan`` (:issue:`50237`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_153.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in the Copy-on-Write implementation losing track of views when indexing a :class:`DataFrame` with another :class:`DataFrame` (:issue:`50630`)\n- Bug in :meth:`.Styler.to_excel` leading to error when unrecognized ``border-style`` (e.g. ``\"hair\"``) provided to Excel writers (:issue:`48649`)\n- Bug in :meth:`Series.quantile` emitting warning from NumPy when :class:`Series` has only ``NA`` values (:issue:`50681`)\n- Bug when chaining several :meth:`.Styler.concat` calls, only the last styler was concatenated (:issue:`49207`)\n- Fixed bug when instantiating a :class:`DataFrame` subclass inheriting from ``typing.Generic`` that triggered a ``UserWarning`` on python 3.11 (:issue:`49649`)\n- Bug in :func:`pivot_table` with NumPy 1.24 or greater when the :class:`DataFrame` columns has nested elements (:issue:`50342`)\n- Bug in :func:`pandas.testing.assert_series_equal` (and equivalent ``assert_`` functions) when having nested data and using numpy >= 1.25 (:issue:`50360`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_153.other:\n\nOther\n~~~~~\n\n.. note::\n\n    If you are using :meth:`DataFrame.to_sql`, :func:`read_sql`, :func:`read_sql_table`, or :func:`read_sql_query` with SQLAlchemy 1.4.46 or greater,\n    you may see a ``sqlalchemy.exc.RemovedIn20Warning``. These warnings can be safely ignored for the SQLAlchemy 1.4.x releases\n    as pandas works toward compatibility with SQLAlchemy 2.0.\n\n- Reverted deprecation (:issue:`45324`) of behavior of :meth:`Series.__getitem__` and :meth:`Series.__setitem__` slicing with an integer :class:`Index`; this will remain positional (:issue:`49612`)\n- A ``FutureWarning`` raised when attempting to set values inplace with :meth:`DataFrame.loc` or :meth:`DataFrame.iloc` has been changed to a ``DeprecationWarning`` (:issue:`48673`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_153.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.5.2..v1.5.3\n", "1.3.2": ".. _whatsnew_132:\n\nWhat's new in 1.3.2 (August 15, 2021)\n-------------------------------------\n\nThese are the changes in pandas 1.3.2. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_132.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Performance regression in :meth:`DataFrame.isin` and :meth:`Series.isin` for nullable data types (:issue:`42714`)\n- Regression in updating values of :class:`Series` using boolean index, created by using :meth:`DataFrame.pop` (:issue:`42530`)\n- Regression in :meth:`DataFrame.from_records` with empty records (:issue:`42456`)\n- Fixed regression in :meth:`DataFrame.shift` where ``TypeError`` occurred when shifting DataFrame created by concatenation of slices and fills with values (:issue:`42719`)\n- Regression in :meth:`DataFrame.agg` when the ``func`` argument returned lists and ``axis=1`` (:issue:`42727`)\n- Regression in :meth:`DataFrame.drop` does nothing if :class:`MultiIndex` has duplicates and indexer is a tuple or list of tuples (:issue:`42771`)\n- Fixed regression where :func:`read_csv` raised a ``ValueError`` when parameters ``names`` and ``prefix`` were both set to ``None`` (:issue:`42387`)\n- Fixed regression in comparisons between :class:`Timestamp` object and ``datetime64`` objects outside the implementation bounds for nanosecond ``datetime64`` (:issue:`42794`)\n- Fixed regression in :meth:`.Styler.highlight_min` and :meth:`.Styler.highlight_max` where ``pandas.NA`` was not successfully ignored (:issue:`42650`)\n- Fixed regression in :func:`concat` where ``copy=False`` was not honored in ``axis=1`` Series concatenation (:issue:`42501`)\n- Regression in :meth:`Series.nlargest` and :meth:`Series.nsmallest` with nullable integer or float dtype (:issue:`42816`)\n- Fixed regression in :meth:`Series.quantile` with :class:`Int64Dtype` (:issue:`42626`)\n- Fixed regression in :meth:`Series.groupby` and :meth:`DataFrame.groupby` where supplying the ``by`` argument with a Series named with a tuple would incorrectly raise (:issue:`42731`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_132.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :func:`read_excel` modifies the dtypes dictionary when reading a file with duplicate columns (:issue:`42462`)\n- 1D slices over extension types turn into N-dimensional slices over ExtensionArrays (:issue:`42430`)\n- Fixed bug in :meth:`Series.rolling` and :meth:`DataFrame.rolling` not calculating window bounds correctly for the first row when ``center=True`` and ``window`` is an offset that covers all the rows (:issue:`42753`)\n- :meth:`.Styler.hide_columns` now hides the index name header row as well as column headers (:issue:`42101`)\n- :meth:`.Styler.set_sticky` has amended CSS to control the column/index names and ensure the correct sticky positions (:issue:`42537`)\n- Bug in de-serializing datetime indexes in PYTHONOPTIMIZED mode (:issue:`42866`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_132.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.3.1..v1.3.2\n", "1.0.0": ".. _whatsnew_100:\n\nWhat's new in 1.0.0 (January 29, 2020)\n--------------------------------------\n\nThese are the changes in pandas 1.0.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n.. note::\n\n    The pandas 1.0 release removed a lot of functionality that was deprecated\n    in previous releases (see :ref:`below <whatsnew_100.prior_deprecations>`\n    for an overview). It is recommended to first upgrade to pandas 0.25 and to\n    ensure your code is working without warnings, before upgrading to pandas\n    1.0.\n\n\nNew deprecation policy\n~~~~~~~~~~~~~~~~~~~~~~\n\nStarting with pandas 1.0.0, pandas will adopt a variant of `SemVer`_ to\nversion releases. Briefly,\n\n* Deprecations will be introduced in minor releases (e.g. 1.1.0, 1.2.0, 2.1.0, ...)\n* Deprecations will be enforced in major releases (e.g. 1.0.0, 2.0.0, 3.0.0, ...)\n* API-breaking changes will be made only in major releases (except for experimental features)\n\nSee :ref:`policies.version` for more.\n\n.. _2019 Pandas User Survey: https://pandas.pydata.org/community/blog/2019-user-survey.html\n.. _SemVer: https://semver.org\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_100.numba_rolling_apply:\n\nUsing Numba in ``rolling.apply`` and ``expanding.apply``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've added an ``engine`` keyword to :meth:`~core.window.rolling.Rolling.apply` and :meth:`~core.window.expanding.Expanding.apply`\nthat allows the user to execute the routine using `Numba <https://numba.pydata.org/>`__ instead of Cython.\nUsing the Numba engine can yield significant performance gains if the apply function can operate on numpy arrays and\nthe data set is larger (1 million rows or greater). For more details, see\n:ref:`rolling apply documentation <window.numba_engine>` (:issue:`28987`, :issue:`30936`)\n\n.. _whatsnew_100.custom_window:\n\nDefining custom windows for rolling operations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've added a :func:`pandas.api.indexers.BaseIndexer` class that allows users to define how\nwindow bounds are created during ``rolling`` operations. Users can define their own ``get_window_bounds``\nmethod on a :func:`pandas.api.indexers.BaseIndexer` subclass that will generate the start and end\nindices used for each window during the rolling aggregation. For more details and example usage, see\nthe :ref:`custom window rolling documentation <window.custom_rolling_window>`\n\n.. _whatsnew_100.to_markdown:\n\nConverting to markdown\n^^^^^^^^^^^^^^^^^^^^^^\n\nWe've added :meth:`~DataFrame.to_markdown` for creating a markdown table (:issue:`11052`)\n\n.. ipython:: python\n\n   df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [1, 2, 3]}, index=['a', 'a', 'b'])\n   print(df.to_markdown())\n\nExperimental new features\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_100.NA:\n\nExperimental ``NA`` scalar to denote missing values\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA new ``pd.NA`` value (singleton) is introduced to represent scalar missing\nvalues. Up to now, pandas used several values to represent missing data: ``np.nan`` is used for this for float data, ``np.nan`` or\n``None`` for object-dtype data and ``pd.NaT`` for datetime-like data. The\ngoal of ``pd.NA`` is to provide a \"missing\" indicator that can be used\nconsistently across data types. ``pd.NA`` is currently used by the nullable integer and boolean\ndata types and the new string data type (:issue:`28095`).\n\n.. warning::\n\n   Experimental: the behaviour of ``pd.NA`` can still change without warning.\n\nFor example, creating a Series using the nullable integer dtype:\n\n.. ipython:: python\n\n    s = pd.Series([1, 2, None], dtype=\"Int64\")\n    s\n    s[2]\n\nCompared to ``np.nan``, ``pd.NA`` behaves differently in certain operations.\nIn addition to arithmetic operations, ``pd.NA`` also propagates as \"missing\"\nor \"unknown\" in comparison operations:\n\n.. ipython:: python\n\n    np.nan > 1\n    pd.NA > 1\n\nFor logical operations, ``pd.NA`` follows the rules of the\n`three-valued logic <https://en.wikipedia.org/wiki/Three-valued_logic>`__ (or\n*Kleene logic*). For example:\n\n.. ipython:: python\n\n    pd.NA | True\n\nFor more, see :ref:`NA section <missing_data.NA>` in the user guide on missing\ndata.\n\n\n.. _whatsnew_100.string:\n\nDedicated string data type\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've added :class:`StringDtype`, an extension type dedicated to string data.\nPreviously, strings were typically stored in object-dtype NumPy arrays. (:issue:`29975`)\n\n.. warning::\n\n   ``StringDtype`` is currently considered experimental. The implementation\n   and parts of the API may change without warning.\n\nThe ``'string'`` extension type solves several issues with object-dtype NumPy arrays:\n\n1. You can accidentally store a *mixture* of strings and non-strings in an\n   ``object`` dtype array. A ``StringArray`` can only store strings.\n2. ``object`` dtype breaks dtype-specific operations like :meth:`DataFrame.select_dtypes`.\n   There isn't a clear way to select *just* text while excluding non-text,\n   but still object-dtype columns.\n3. When reading code, the contents of an ``object`` dtype array is less clear\n   than ``string``.\n\n\n.. ipython:: python\n\n   pd.Series(['abc', None, 'def'], dtype=pd.StringDtype())\n\nYou can use the alias ``\"string\"`` as well.\n\n.. ipython:: python\n\n   s = pd.Series(['abc', None, 'def'], dtype=\"string\")\n   s\n\nThe usual string accessor methods work. Where appropriate, the return type\nof the Series or columns of a DataFrame will also have string dtype.\n\n.. ipython:: python\n\n   s.str.upper()\n   s.str.split('b', expand=True).dtypes\n\nString accessor methods returning integers will return a value with :class:`Int64Dtype`\n\n.. ipython:: python\n\n   s.str.count(\"a\")\n\nWe recommend explicitly using the ``string`` data type when working with strings.\nSee :ref:`text.types` for more.\n\n.. _whatsnew_100.boolean:\n\nBoolean data type with missing values support\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've added :class:`BooleanDtype` / :class:`~arrays.BooleanArray`, an extension\ntype dedicated to boolean data that can hold missing values. The default\n``bool`` data type based on a bool-dtype NumPy array, the column can only hold\n``True`` or ``False``, and not missing values. This new :class:`~arrays.BooleanArray`\ncan store missing values as well by keeping track of this in a separate mask.\n(:issue:`29555`, :issue:`30095`, :issue:`31131`)\n\n.. ipython:: python\n\n   pd.Series([True, False, None], dtype=pd.BooleanDtype())\n\nYou can use the alias ``\"boolean\"`` as well.\n\n.. ipython:: python\n\n   s = pd.Series([True, False, None], dtype=\"boolean\")\n   s\n\n.. _whatsnew_100.convert_dtypes:\n\nMethod ``convert_dtypes`` to ease use of supported extension dtypes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn order to encourage use of the extension dtypes ``StringDtype``,\n``BooleanDtype``, ``Int64Dtype``, ``Int32Dtype``, etc., that support ``pd.NA``, the\nmethods :meth:`DataFrame.convert_dtypes` and :meth:`Series.convert_dtypes`\nhave been introduced. (:issue:`29752`) (:issue:`30929`)\n\nExample:\n\n.. ipython:: python\n\n   df = pd.DataFrame({'x': ['abc', None, 'def'],\n                      'y': [1, 2, np.nan],\n                      'z': [True, False, True]})\n   df\n   df.dtypes\n\n.. ipython:: python\n\n   converted = df.convert_dtypes()\n   converted\n   converted.dtypes\n\nThis is especially useful after reading in data using readers such as :func:`read_csv`\nand :func:`read_excel`.\nSee :ref:`here <missing_data.NA.conversion>` for a description.\n\n\n.. _whatsnew_100.enhancements.other:\n\nOther enhancements\n~~~~~~~~~~~~~~~~~~\n\n- :meth:`DataFrame.to_string` added the ``max_colwidth`` parameter to control when wide columns are truncated (:issue:`9784`)\n- Added the ``na_value`` argument to :meth:`Series.to_numpy`, :meth:`Index.to_numpy` and :meth:`DataFrame.to_numpy` to control the value used for missing data (:issue:`30322`)\n- :meth:`MultiIndex.from_product` infers level names from inputs if not explicitly provided (:issue:`27292`)\n- :meth:`DataFrame.to_latex` now accepts ``caption`` and ``label`` arguments (:issue:`25436`)\n- DataFrames with :ref:`nullable integer <integer_na>`, the :ref:`new string dtype <text.types>`\n  and period data type can now be converted to ``pyarrow`` (>=0.15.0), which means that it is\n  supported in writing to the Parquet file format when using the ``pyarrow`` engine (:issue:`28368`).\n  Full roundtrip to parquet (writing and reading back in with :meth:`~DataFrame.to_parquet` / :func:`read_parquet`)\n  is supported starting with pyarrow >= 0.16 (:issue:`20612`).\n- :func:`to_parquet` now appropriately handles the ``schema`` argument for user defined schemas in the pyarrow engine. (:issue:`30270`)\n- :meth:`DataFrame.to_json` now accepts an ``indent`` integer argument to enable pretty printing of JSON output (:issue:`12004`)\n- :meth:`read_stata` can read Stata 119 dta files. (:issue:`28250`)\n- Implemented :meth:`.Window.var` and :meth:`.Window.std` functions (:issue:`26597`)\n- Added ``encoding`` argument to :meth:`DataFrame.to_string` for non-ascii text (:issue:`28766`)\n- Added ``encoding`` argument to :func:`DataFrame.to_html` for non-ascii text (:issue:`28663`)\n- :meth:`Styler.background_gradient` now accepts ``vmin`` and ``vmax`` arguments (:issue:`12145`)\n- :meth:`Styler.format` added the ``na_rep`` parameter to help format the missing values (:issue:`21527`, :issue:`28358`)\n- :func:`read_excel` now can read binary Excel (``.xlsb``) files by passing ``engine='pyxlsb'``. For more details and example usage, see the :ref:`Binary Excel files documentation <io.xlsb>`. Closes :issue:`8540`.\n- The ``partition_cols`` argument in :meth:`DataFrame.to_parquet` now accepts a string (:issue:`27117`)\n- :func:`pandas.read_json` now parses ``NaN``, ``Infinity`` and ``-Infinity`` (:issue:`12213`)\n- DataFrame constructor preserve ``ExtensionArray`` dtype with ``ExtensionArray`` (:issue:`11363`)\n- :meth:`DataFrame.sort_values` and :meth:`Series.sort_values` have gained ``ignore_index`` keyword to be able to reset index after sorting (:issue:`30114`)\n- :meth:`DataFrame.sort_index` and :meth:`Series.sort_index` have gained ``ignore_index`` keyword to reset index (:issue:`30114`)\n- :meth:`DataFrame.drop_duplicates` has gained ``ignore_index`` keyword to reset index (:issue:`30114`)\n- Added new writer for exporting Stata dta files in versions 118 and 119, ``StataWriterUTF8``.  These files formats support exporting strings containing Unicode characters. Format 119 supports data sets with more than 32,767 variables (:issue:`23573`, :issue:`30959`)\n- :meth:`Series.map` now accepts ``collections.abc.Mapping`` subclasses as a mapper (:issue:`29733`)\n- Added an experimental :attr:`~DataFrame.attrs` for storing global metadata about a dataset (:issue:`29062`)\n- :meth:`Timestamp.fromisocalendar` is now compatible with python 3.8 and above (:issue:`28115`)\n- :meth:`DataFrame.to_pickle` and :func:`read_pickle` now accept URL (:issue:`30163`)\n\n\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_100.api_breaking:\n\nBackwards incompatible API changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_100.api_breaking.MultiIndex._names:\n\nAvoid using names from ``MultiIndex.levels``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs part of a larger refactor to :class:`MultiIndex` the level names are now\nstored separately from the levels (:issue:`27242`). We recommend using\n:attr:`MultiIndex.names` to access the names, and :meth:`Index.set_names`\nto update the names.\n\nFor backwards compatibility, you can still *access* the names via the levels.\n\n.. ipython:: python\n\n   mi = pd.MultiIndex.from_product([[1, 2], ['a', 'b']], names=['x', 'y'])\n   mi.levels[0].name\n\nHowever, it is no longer possible to *update* the names of the ``MultiIndex``\nvia the level.\n\n.. ipython:: python\n   :okexcept:\n\n   mi.levels[0].name = \"new name\"\n   mi.names\n\nTo update, use ``MultiIndex.set_names``, which returns a new ``MultiIndex``.\n\n.. ipython:: python\n\n   mi2 = mi.set_names(\"new name\", level=0)\n   mi2.names\n\nNew repr for :class:`~pandas.arrays.IntervalArray`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`pandas.arrays.IntervalArray` adopts a new ``__repr__`` in accordance with other array classes (:issue:`25022`)\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\n   Out[2]:\n   IntervalArray([(0, 1], (2, 3]],\n                 closed='right',\n                 dtype='interval[int64]')\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\n\n``DataFrame.rename`` now only accepts one positional argument\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`DataFrame.rename` would previously accept positional arguments that would lead\nto ambiguous or undefined behavior. From pandas 1.0, only the very first argument, which\nmaps labels to their new names along the default axis, is allowed to be passed by position\n(:issue:`29136`).\n\n.. ipython:: python\n   :suppress:\n\n   df = pd.DataFrame([[1]])\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: df = pd.DataFrame([[1]])\n   In [2]: df.rename({0: 1}, {0: 2})\n   Out[2]:\n   FutureWarning: ...Use named arguments to resolve ambiguity...\n      2\n   1  1\n\n*pandas 1.0.0*\n\n.. code-block:: ipython\n\n   In [3]: df.rename({0: 1}, {0: 2})\n   Traceback (most recent call last):\n   ...\n   TypeError: rename() takes from 1 to 2 positional arguments but 3 were given\n\nNote that errors will now be raised when conflicting or potentially ambiguous arguments are provided.\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [4]: df.rename({0: 1}, index={0: 2})\n   Out[4]:\n      0\n   1  1\n\n   In [5]: df.rename(mapper={0: 1}, index={0: 2})\n   Out[5]:\n      0\n   2  1\n\n*pandas 1.0.0*\n\n.. code-block:: ipython\n\n   In [6]: df.rename({0: 1}, index={0: 2})\n   Traceback (most recent call last):\n   ...\n   TypeError: Cannot specify both 'mapper' and any of 'index' or 'columns'\n\n   In [7]: df.rename(mapper={0: 1}, index={0: 2})\n   Traceback (most recent call last):\n   ...\n   TypeError: Cannot specify both 'mapper' and any of 'index' or 'columns'\n\nYou can still change the axis along which the first positional argument is applied by\nsupplying the ``axis`` keyword argument.\n\n.. ipython:: python\n\n   df.rename({0: 1})\n   df.rename({0: 1}, axis=1)\n\nIf you would like to update both the index and column labels, be sure to use the respective\nkeywords.\n\n.. ipython:: python\n\n   df.rename(index={0: 1}, columns={0: 2})\n\nExtended verbose info output for :class:`~pandas.DataFrame`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`DataFrame.info` now shows line numbers for the columns summary (:issue:`17304`)\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: df = pd.DataFrame({\"int_col\": [1, 2, 3],\n   ...                    \"text_col\": [\"a\", \"b\", \"c\"],\n   ...                    \"float_col\": [0.0, 0.1, 0.2]})\n   In [2]: df.info(verbose=True)\n   <class 'pandas.core.frame.DataFrame'>\n   RangeIndex: 3 entries, 0 to 2\n   Data columns (total 3 columns):\n   int_col      3 non-null int64\n   text_col     3 non-null object\n   float_col    3 non-null float64\n   dtypes: float64(1), int64(1), object(1)\n   memory usage: 152.0+ bytes\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   df = pd.DataFrame({\"int_col\": [1, 2, 3],\n                      \"text_col\": [\"a\", \"b\", \"c\"],\n                      \"float_col\": [0.0, 0.1, 0.2]})\n   df.info(verbose=True)\n\n:meth:`pandas.array` inference changes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`pandas.array` now infers pandas' new extension types in several cases (:issue:`29791`):\n\n1. String data (including missing values) now returns a :class:`arrays.StringArray`.\n2. Integer data (including missing values) now returns a :class:`arrays.IntegerArray`.\n3. Boolean data (including missing values) now returns the new :class:`arrays.BooleanArray`\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: pd.array([\"a\", None])\n   Out[1]:\n   <PandasArray>\n   ['a', None]\n   Length: 2, dtype: object\n\n   In [2]: pd.array([1, None])\n   Out[2]:\n   <PandasArray>\n   [1, None]\n   Length: 2, dtype: object\n\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   pd.array([\"a\", None])\n   pd.array([1, None])\n\nAs a reminder, you can specify the ``dtype`` to disable all inference.\n\n:class:`arrays.IntegerArray` now uses :attr:`pandas.NA`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`arrays.IntegerArray` now uses :attr:`pandas.NA` rather than\n:attr:`numpy.nan` as its missing value marker (:issue:`29964`).\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\n   In [2]: a\n   Out[2]:\n   <IntegerArray>\n   [1, 2, NaN]\n   Length: 3, dtype: Int64\n\n   In [3]: a[2]\n   Out[3]:\n   nan\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   a = pd.array([1, 2, None], dtype=\"Int64\")\n   a\n   a[2]\n\nThis has a few API-breaking consequences.\n\n**Converting to a NumPy ndarray**\n\nWhen converting to a NumPy array missing values will be ``pd.NA``, which cannot\nbe converted to a float. So calling ``np.asarray(integer_array, dtype=\"float\")``\nwill now raise.\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n    In [1]: np.asarray(a, dtype=\"float\")\n    Out[1]:\n    array([ 1.,  2., nan])\n\n*pandas 1.0.0*\n\n.. ipython:: python\n   :okexcept:\n\n   np.asarray(a, dtype=\"float\")\n\nUse :meth:`arrays.IntegerArray.to_numpy` with an explicit ``na_value`` instead.\n\n.. ipython:: python\n\n   a.to_numpy(dtype=\"float\", na_value=np.nan)\n\n**Reductions can return** ``pd.NA``\n\nWhen performing a reduction such as a sum with ``skipna=False``, the result\nwill now be ``pd.NA`` instead of ``np.nan`` in presence of missing values\n(:issue:`30958`).\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n    In [1]: pd.Series(a).sum(skipna=False)\n    Out[1]:\n    nan\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   pd.Series(a).sum(skipna=False)\n\n**value_counts returns a nullable integer dtype**\n\n:meth:`Series.value_counts` with a nullable integer dtype now returns a nullable\ninteger dtype for the values.\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\n   Out[1]:\n   dtype('int64')\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\n\nSee :ref:`missing_data.NA` for more on the differences between :attr:`pandas.NA`\nand :attr:`numpy.nan`.\n\n:class:`arrays.IntegerArray` comparisons return :class:`arrays.BooleanArray`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nComparison operations on a :class:`arrays.IntegerArray` now returns a\n:class:`arrays.BooleanArray` rather than a NumPy array (:issue:`29964`).\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\n   In [2]: a\n   Out[2]:\n   <IntegerArray>\n   [1, 2, NaN]\n   Length: 3, dtype: Int64\n\n   In [3]: a > 1\n   Out[3]:\n   array([False,  True, False])\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   a = pd.array([1, 2, None], dtype=\"Int64\")\n   a > 1\n\nNote that missing values now propagate, rather than always comparing unequal\nlike :attr:`numpy.nan`. See :ref:`missing_data.NA` for more.\n\nBy default :meth:`Categorical.min` now returns the minimum instead of np.nan\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen :class:`Categorical` contains ``np.nan``,\n:meth:`Categorical.min` no longer return ``np.nan`` by default (skipna=True) (:issue:`25303`)\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]: pd.Categorical([1, 2, np.nan], ordered=True).min()\n   Out[1]: nan\n\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   pd.Categorical([1, 2, np.nan], ordered=True).min()\n\n\nDefault dtype of empty :class:`pandas.Series`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nInitialising an empty :class:`pandas.Series` without specifying a dtype will raise a ``DeprecationWarning`` now\n(:issue:`17261`). The default dtype will change from ``float64`` to ``object`` in future releases so that it is\nconsistent with the behaviour of :class:`DataFrame` and :class:`Index`.\n\n*pandas 1.0.0*\n\n.. code-block:: ipython\n\n   In [1]: pd.Series()\n   Out[2]:\n   DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n   Series([], dtype: float64)\n\nResult dtype inference changes for resample operations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe rules for the result dtype in :meth:`DataFrame.resample` aggregations have changed for extension types (:issue:`31359`).\nPreviously, pandas would attempt to convert the result back to the original dtype, falling back to the usual\ninference rules if that was not possible. Now, pandas will only return a result of the original dtype if the\nscalar values in the result are instances of the extension dtype's scalar type.\n\n.. ipython:: python\n\n   df = pd.DataFrame({\"A\": ['a', 'b']}, dtype='category',\n                     index=pd.date_range('2000', periods=2))\n   df\n\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1]> df.resample(\"2D\").agg(lambda x: 'a').A.dtype\n   Out[1]:\n   CategoricalDtype(categories=['a', 'b'], ordered=False)\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   df.resample(\"2D\").agg(lambda x: 'a').A.dtype\n\nThis fixes an inconsistency between ``resample`` and ``groupby``.\nThis also fixes a potential bug, where the **values** of the result might change\ndepending on how the results are cast back to the original dtype.\n\n*pandas 0.25.x*\n\n.. code-block:: ipython\n\n   In [1] df.resample(\"2D\").agg(lambda x: 'c')\n   Out[1]:\n\n        A\n   0  NaN\n\n*pandas 1.0.0*\n\n.. ipython:: python\n\n   df.resample(\"2D\").agg(lambda x: 'c')\n\n\n.. _whatsnew_100.api_breaking.python:\n\nIncreased minimum version for Python\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\npandas 1.0.0 supports Python 3.6.1 and higher (:issue:`29212`).\n\n.. _whatsnew_100.api_breaking.deps:\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSome minimum supported versions of dependencies were updated (:issue:`29766`, :issue:`29723`).\nIf installed, we now require:\n\n+-----------------+-----------------+----------+---------+\n| Package         | Minimum Version | Required | Changed |\n+=================+=================+==========+=========+\n| numpy           | 1.13.3          |    X     |         |\n+-----------------+-----------------+----------+---------+\n| pytz            | 2015.4          |    X     |         |\n+-----------------+-----------------+----------+---------+\n| python-dateutil | 2.6.1           |    X     |         |\n+-----------------+-----------------+----------+---------+\n| bottleneck      | 1.2.1           |          |         |\n+-----------------+-----------------+----------+---------+\n| numexpr         | 2.6.2           |          |         |\n+-----------------+-----------------+----------+---------+\n| pytest (dev)    | 4.0.2           |          |         |\n+-----------------+-----------------+----------+---------+\n\nFor `optional libraries <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\nThe following table lists the lowest version per library that is currently being tested throughout the development of pandas.\nOptional libraries below the lowest tested version may still work, but are not considered supported.\n\n+-----------------+-----------------+---------+\n| Package         | Minimum Version | Changed |\n+=================+=================+=========+\n| beautifulsoup4  | 4.6.0           |         |\n+-----------------+-----------------+---------+\n| fastparquet     | 0.3.2           |    X    |\n+-----------------+-----------------+---------+\n| gcsfs           | 0.2.2           |         |\n+-----------------+-----------------+---------+\n| lxml            | 3.8.0           |         |\n+-----------------+-----------------+---------+\n| matplotlib      | 2.2.2           |         |\n+-----------------+-----------------+---------+\n| numba           | 0.46.0          |    X    |\n+-----------------+-----------------+---------+\n| openpyxl        | 2.5.7           |    X    |\n+-----------------+-----------------+---------+\n| pyarrow         | 0.13.0          |    X    |\n+-----------------+-----------------+---------+\n| pymysql         | 0.7.1           |         |\n+-----------------+-----------------+---------+\n| pytables        | 3.4.2           |         |\n+-----------------+-----------------+---------+\n| s3fs            | 0.3.0           |    X    |\n+-----------------+-----------------+---------+\n| scipy           | 0.19.0          |         |\n+-----------------+-----------------+---------+\n| sqlalchemy      | 1.1.4           |         |\n+-----------------+-----------------+---------+\n| xarray          | 0.8.2           |         |\n+-----------------+-----------------+---------+\n| xlrd            | 1.1.0           |         |\n+-----------------+-----------------+---------+\n| xlsxwriter      | 0.9.8           |         |\n+-----------------+-----------------+---------+\n| xlwt            | 1.2.0           |         |\n+-----------------+-----------------+---------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\nBuild changes\n^^^^^^^^^^^^^\n\npandas has added a `pyproject.toml <https://www.python.org/dev/peps/pep-0517/>`_ file and will no longer include\ncythonized files in the source distribution uploaded to PyPI (:issue:`28341`, :issue:`20775`). If you're installing\na built distribution (wheel) or via conda, this shouldn't have any effect on you. If you're building pandas from\nsource, you should no longer need to install Cython into your build environment before calling ``pip install pandas``.\n\n\n.. _whatsnew_100.api.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n\n- :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` now raises on invalid operation names (:issue:`27489`)\n- :meth:`pandas.api.types.infer_dtype` will now return \"integer-na\" for integer and ``np.nan`` mix (:issue:`27283`)\n- :meth:`MultiIndex.from_arrays` will no longer infer names from arrays if ``names=None`` is explicitly provided (:issue:`27292`)\n- In order to improve tab-completion, pandas does not include most deprecated attributes when introspecting a pandas object using ``dir`` (e.g. ``dir(df)``).\n  To see which attributes are excluded, see an object's ``_deprecations`` attribute, for example ``pd.DataFrame._deprecations`` (:issue:`28805`).\n- The returned dtype of :func:`unique` now matches the input dtype. (:issue:`27874`)\n- Changed the default configuration value for ``options.matplotlib.register_converters`` from ``True`` to ``\"auto\"`` (:issue:`18720`).\n  Now, pandas custom formatters will only be applied to plots created by pandas, through :meth:`~DataFrame.plot`.\n  Previously, pandas' formatters would be applied to all plots created *after* a :meth:`~DataFrame.plot`.\n  See :ref:`units registration <whatsnew_100.matplotlib_units>` for more.\n- :meth:`Series.dropna` has dropped its ``**kwargs`` argument in favor of a single ``how`` parameter.\n  Supplying anything else than ``how`` to ``**kwargs`` raised a ``TypeError`` previously (:issue:`29388`)\n- When testing pandas, the new minimum required version of pytest is 5.0.1 (:issue:`29664`)\n- :meth:`Series.str.__iter__` was deprecated and will be removed in future releases (:issue:`28277`).\n- Added ``<NA>`` to the list of default NA values for :meth:`read_csv` (:issue:`30821`)\n\n.. _whatsnew_100.api.documentation:\n\nDocumentation improvements\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n- Added new section on :ref:`scale` (:issue:`28315`).\n- Added sub-section on :ref:`io.query_multi` for HDF5 datasets (:issue:`28791`).\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_100.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\n- :meth:`Series.item` and :meth:`Index.item` have been _undeprecated_ (:issue:`29250`)\n- ``Index.set_value`` has been deprecated. For a given index ``idx``, array ``arr``,\n  value in ``idx`` of ``idx_val`` and a new value of ``val``, ``idx.set_value(arr, idx_val, val)``\n  is equivalent to ``arr[idx.get_loc(idx_val)] = val``, which should be used instead (:issue:`28621`).\n- :func:`is_extension_type` is deprecated, :func:`is_extension_array_dtype` should be used instead (:issue:`29457`)\n- :func:`eval` keyword argument \"truediv\" is deprecated and will be removed in a future version (:issue:`29812`)\n- :meth:`DateOffset.isAnchored` and :meth:`DatetOffset.onOffset` are deprecated and will be removed in a future version, use :meth:`DateOffset.is_anchored` and :meth:`DateOffset.is_on_offset` instead (:issue:`30340`)\n- ``pandas.tseries.frequencies.get_offset`` is deprecated and will be removed in a future version, use ``pandas.tseries.frequencies.to_offset`` instead (:issue:`4205`)\n- :meth:`Categorical.take_nd` and :meth:`CategoricalIndex.take_nd` are deprecated, use :meth:`Categorical.take` and :meth:`CategoricalIndex.take` instead (:issue:`27745`)\n- The parameter ``numeric_only`` of :meth:`Categorical.min` and :meth:`Categorical.max` is deprecated and replaced with ``skipna`` (:issue:`25303`)\n- The parameter ``label`` in :func:`lreshape` has been deprecated and will be removed in a future version (:issue:`29742`)\n- ``pandas.core.index`` has been deprecated and will be removed in a future version, the public classes are available in the top-level namespace (:issue:`19711`)\n- :func:`pandas.json_normalize` is now exposed in the top-level namespace.\n  Usage of ``json_normalize`` as ``pandas.io.json.json_normalize`` is now deprecated and\n  it is recommended to use ``json_normalize`` as :func:`pandas.json_normalize` instead (:issue:`27586`).\n- The ``numpy`` argument of :meth:`pandas.read_json` is deprecated (:issue:`28512`).\n- :meth:`DataFrame.to_stata`, :meth:`DataFrame.to_feather`, and :meth:`DataFrame.to_parquet` argument \"fname\" is deprecated, use \"path\" instead (:issue:`23574`)\n- The deprecated internal attributes ``_start``, ``_stop`` and ``_step`` of :class:`RangeIndex` now raise a ``FutureWarning`` instead of a ``DeprecationWarning`` (:issue:`26581`)\n- The ``pandas.util.testing`` module has been deprecated. Use the public API in ``pandas.testing`` documented at :ref:`api.general.testing` (:issue:`16232`).\n- ``pandas.SparseArray`` has been deprecated.  Use ``pandas.arrays.SparseArray`` (:class:`arrays.SparseArray`) instead. (:issue:`30642`)\n- The parameter ``is_copy`` of :meth:`Series.take` and :meth:`DataFrame.take` has been deprecated and will be removed in a future version. (:issue:`27357`)\n- Support for multi-dimensional indexing (e.g. ``index[:, None]``) on a :class:`Index` is deprecated and will be removed in a future version, convert to a numpy array before indexing instead (:issue:`30588`)\n- The ``pandas.np`` submodule is now deprecated. Import numpy directly instead (:issue:`30296`)\n- The ``pandas.datetime`` class is now deprecated. Import from ``datetime`` instead (:issue:`30610`)\n- :class:`~DataFrame.diff` will raise a ``TypeError`` rather than implicitly losing the dtype of extension types in the future. Convert to the correct dtype before calling ``diff`` instead (:issue:`31025`)\n\n**Selecting Columns from a Grouped DataFrame**\n\nWhen selecting columns from a :class:`DataFrameGroupBy` object, passing individual keys (or a tuple of keys) inside single brackets is deprecated,\na list of items should be used instead. (:issue:`23566`) For example:\n\n.. code-block:: ipython\n\n    df = pd.DataFrame({\n        \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n        \"B\": np.random.randn(8),\n        \"C\": np.random.randn(8),\n    })\n    g = df.groupby('A')\n\n    # single key, returns SeriesGroupBy\n    g['B']\n\n    # tuple of single key, returns SeriesGroupBy\n    g[('B',)]\n\n    # tuple of multiple keys, returns DataFrameGroupBy, raises FutureWarning\n    g[('B', 'C')]\n\n    # multiple keys passed directly, returns DataFrameGroupBy, raises FutureWarning\n    # (implicitly converts the passed strings into a single tuple)\n    g['B', 'C']\n\n    # proper way, returns DataFrameGroupBy\n    g[['B', 'C']]\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_100.prior_deprecations:\n\nRemoval of prior version deprecations/changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Removed SparseSeries and SparseDataFrame**\n\n``SparseSeries``, ``SparseDataFrame`` and the ``DataFrame.to_sparse`` method\nhave been removed (:issue:`28425`). We recommend using a ``Series`` or\n``DataFrame`` with sparse values instead.\n\n.. _whatsnew_100.matplotlib_units:\n\n**Matplotlib unit registration**\n\nPreviously, pandas would register converters with matplotlib as a side effect of importing pandas (:issue:`18720`).\nThis changed the output of plots made via matplotlib plots after pandas was imported, even if you were using\nmatplotlib directly rather than :meth:`~DataFrame.plot`.\n\nTo use pandas formatters with a matplotlib plot, specify\n\n.. code-block:: ipython\n\n   In [1]: import pandas as pd\n   In [2]: pd.options.plotting.matplotlib.register_converters = True\n\nNote that plots created by :meth:`DataFrame.plot` and :meth:`Series.plot` *do* register the converters\nautomatically. The only behavior change is when plotting a date-like object via ``matplotlib.pyplot.plot``\nor ``matplotlib.Axes.plot``. See :ref:`plotting.formatters` for more.\n\n**Other removals**\n\n- Removed the previously deprecated keyword \"index\" from :func:`read_stata`, :class:`StataReader`, and :meth:`StataReader.read`, use \"index_col\" instead (:issue:`17328`)\n- Removed ``StataReader.data`` method, use :meth:`StataReader.read` instead (:issue:`9493`)\n- Removed ``pandas.plotting._matplotlib.tsplot``, use :meth:`Series.plot` instead (:issue:`19980`)\n- ``pandas.tseries.converter.register`` has been moved to :func:`pandas.plotting.register_matplotlib_converters` (:issue:`18307`)\n- :meth:`Series.plot` no longer accepts positional arguments, pass keyword arguments instead (:issue:`30003`)\n- :meth:`DataFrame.hist` and :meth:`Series.hist` no longer allows ``figsize=\"default\"``, specify figure size by passinig a tuple instead (:issue:`30003`)\n- Floordiv of integer-dtyped array by :class:`Timedelta` now raises ``TypeError`` (:issue:`21036`)\n- :class:`TimedeltaIndex` and :class:`DatetimeIndex` no longer accept non-nanosecond dtype strings like \"timedelta64\" or \"datetime64\", use \"timedelta64[ns]\" and \"datetime64[ns]\" instead (:issue:`24806`)\n- Changed the default \"skipna\" argument in :func:`pandas.api.types.infer_dtype` from ``False`` to ``True`` (:issue:`24050`)\n- Removed ``Series.ix`` and ``DataFrame.ix`` (:issue:`26438`)\n- Removed ``Index.summary`` (:issue:`18217`)\n- Removed the previously deprecated keyword \"fastpath\" from the :class:`Index` constructor (:issue:`23110`)\n- Removed ``Series.get_value``, ``Series.set_value``, ``DataFrame.get_value``, ``DataFrame.set_value`` (:issue:`17739`)\n- Removed ``Series.compound`` and ``DataFrame.compound`` (:issue:`26405`)\n- Changed the default \"inplace\" argument in :meth:`DataFrame.set_index` and :meth:`Series.set_axis` from ``None`` to ``False`` (:issue:`27600`)\n- Removed ``Series.cat.categorical``, ``Series.cat.index``, ``Series.cat.name`` (:issue:`24751`)\n- Removed the previously deprecated keyword \"box\" from :func:`to_datetime` and :func:`to_timedelta`; in addition these now always returns :class:`DatetimeIndex`, :class:`TimedeltaIndex`, :class:`Index`, :class:`Series`, or :class:`DataFrame` (:issue:`24486`)\n- :func:`to_timedelta`, :class:`Timedelta`, and :class:`TimedeltaIndex` no longer allow \"M\", \"y\", or \"Y\" for the \"unit\" argument (:issue:`23264`)\n- Removed the previously deprecated keyword \"time_rule\" from (non-public) ``offsets.generate_range``, which has been moved to :func:`core.arrays._ranges.generate_range` (:issue:`24157`)\n- :meth:`DataFrame.loc` or :meth:`Series.loc` with listlike indexers and missing labels will no longer reindex (:issue:`17295`)\n- :meth:`DataFrame.to_excel` and :meth:`Series.to_excel` with non-existent columns will no longer reindex (:issue:`17295`)\n- Removed the previously deprecated keyword \"join_axes\" from :func:`concat`; use ``reindex_like`` on the result instead (:issue:`22318`)\n- Removed the previously deprecated keyword \"by\" from :meth:`DataFrame.sort_index`, use :meth:`DataFrame.sort_values` instead (:issue:`10726`)\n- Removed support for nested renaming in :meth:`DataFrame.aggregate`, :meth:`Series.aggregate`, :meth:`core.groupby.DataFrameGroupBy.aggregate`, :meth:`core.groupby.SeriesGroupBy.aggregate`, :meth:`core.window.rolling.Rolling.aggregate` (:issue:`18529`)\n- Passing ``datetime64`` data to :class:`TimedeltaIndex` or ``timedelta64`` data to ``DatetimeIndex`` now raises ``TypeError`` (:issue:`23539`, :issue:`23937`)\n- Passing ``int64`` values to :class:`DatetimeIndex` and a timezone now interprets the values as nanosecond timestamps in UTC, not wall times in the given timezone (:issue:`24559`)\n- A tuple passed to :meth:`DataFrame.groupby` is now exclusively treated as a single key (:issue:`18314`)\n- Removed ``Index.contains``, use ``key in index`` instead (:issue:`30103`)\n- Addition and subtraction of ``int`` or integer-arrays is no longer allowed in :class:`Timestamp`, :class:`DatetimeIndex`, :class:`TimedeltaIndex`, use ``obj + n * obj.freq`` instead of ``obj + n`` (:issue:`22535`)\n- Removed ``Series.ptp`` (:issue:`21614`)\n- Removed ``Series.from_array`` (:issue:`18258`)\n- Removed ``DataFrame.from_items`` (:issue:`18458`)\n- Removed ``DataFrame.as_matrix``, ``Series.as_matrix`` (:issue:`18458`)\n- Removed ``Series.asobject`` (:issue:`18477`)\n- Removed ``DataFrame.as_blocks``, ``Series.as_blocks``, ``DataFrame.blocks``, ``Series.blocks`` (:issue:`17656`)\n- :meth:`pandas.Series.str.cat` now defaults to aligning ``others``, using ``join='left'`` (:issue:`27611`)\n- :meth:`pandas.Series.str.cat` does not accept list-likes *within* list-likes anymore (:issue:`27611`)\n- :meth:`Series.where` with ``Categorical`` dtype (or :meth:`DataFrame.where` with ``Categorical`` column) no longer allows setting new categories (:issue:`24114`)\n- Removed the previously deprecated keywords \"start\", \"end\", and \"periods\" from the :class:`DatetimeIndex`, :class:`TimedeltaIndex`, and :class:`PeriodIndex` constructors; use :func:`date_range`, :func:`timedelta_range`, and :func:`period_range` instead (:issue:`23919`)\n- Removed the previously deprecated keyword \"verify_integrity\" from the :class:`DatetimeIndex` and :class:`TimedeltaIndex` constructors (:issue:`23919`)\n- Removed the previously deprecated keyword \"fastpath\" from ``pandas.core.internals.blocks.make_block`` (:issue:`19265`)\n- Removed the previously deprecated keyword \"dtype\" from :meth:`Block.make_block_same_class` (:issue:`19434`)\n- Removed ``ExtensionArray._formatting_values``. Use :attr:`ExtensionArray._formatter` instead. (:issue:`23601`)\n- Removed ``MultiIndex.to_hierarchical`` (:issue:`21613`)\n- Removed ``MultiIndex.labels``, use :attr:`MultiIndex.codes` instead (:issue:`23752`)\n- Removed the previously deprecated keyword \"labels\" from the :class:`MultiIndex` constructor, use \"codes\" instead (:issue:`23752`)\n- Removed ``MultiIndex.set_labels``, use :meth:`MultiIndex.set_codes` instead (:issue:`23752`)\n- Removed the previously deprecated keyword \"labels\" from :meth:`MultiIndex.set_codes`, :meth:`MultiIndex.copy`, :meth:`MultiIndex.drop`, use \"codes\" instead (:issue:`23752`)\n- Removed support for legacy HDF5 formats (:issue:`29787`)\n- Passing a dtype alias (e.g. 'datetime64[ns, UTC]') to :class:`DatetimeTZDtype` is no longer allowed, use :meth:`DatetimeTZDtype.construct_from_string` instead (:issue:`23990`)\n- Removed the previously deprecated keyword \"skip_footer\" from :func:`read_excel`; use \"skipfooter\" instead (:issue:`18836`)\n- :func:`read_excel` no longer allows an integer value for the parameter ``usecols``, instead pass a list of integers from 0 to ``usecols`` inclusive (:issue:`23635`)\n- Removed the previously deprecated keyword \"convert_datetime64\" from :meth:`DataFrame.to_records` (:issue:`18902`)\n- Removed ``IntervalIndex.from_intervals`` in favor of the :class:`IntervalIndex` constructor (:issue:`19263`)\n- Changed the default \"keep_tz\" argument in :meth:`DatetimeIndex.to_series` from ``None`` to ``True`` (:issue:`23739`)\n- Removed ``api.types.is_period`` and ``api.types.is_datetimetz`` (:issue:`23917`)\n- Ability to read pickles containing :class:`Categorical` instances created with pre-0.16 version of pandas has been removed (:issue:`27538`)\n- Removed ``pandas.tseries.plotting.tsplot`` (:issue:`18627`)\n- Removed the previously deprecated keywords \"reduce\" and \"broadcast\" from :meth:`DataFrame.apply` (:issue:`18577`)\n- Removed the previously deprecated ``assert_raises_regex`` function in ``pandas._testing`` (:issue:`29174`)\n- Removed the previously deprecated ``FrozenNDArray`` class in ``pandas.core.indexes.frozen`` (:issue:`29335`)\n- Removed the previously deprecated keyword \"nthreads\" from :func:`read_feather`, use \"use_threads\" instead (:issue:`23053`)\n- Removed ``Index.is_lexsorted_for_tuple`` (:issue:`29305`)\n- Removed support for nested renaming in :meth:`DataFrame.aggregate`, :meth:`Series.aggregate`, :meth:`core.groupby.DataFrameGroupBy.aggregate`, :meth:`core.groupby.SeriesGroupBy.aggregate`, :meth:`core.window.rolling.Rolling.aggregate` (:issue:`29608`)\n- Removed ``Series.valid``; use :meth:`Series.dropna` instead (:issue:`18800`)\n- Removed ``DataFrame.is_copy``, ``Series.is_copy`` (:issue:`18812`)\n- Removed ``DataFrame.get_ftype_counts``, ``Series.get_ftype_counts`` (:issue:`18243`)\n- Removed ``DataFrame.ftypes``, ``Series.ftypes``, ``Series.ftype`` (:issue:`26744`)\n- Removed ``Index.get_duplicates``, use ``idx[idx.duplicated()].unique()`` instead (:issue:`20239`)\n- Removed ``Series.clip_upper``, ``Series.clip_lower``, ``DataFrame.clip_upper``, ``DataFrame.clip_lower`` (:issue:`24203`)\n- Removed the ability to alter :attr:`DatetimeIndex.freq`, :attr:`TimedeltaIndex.freq`, or :attr:`PeriodIndex.freq` (:issue:`20772`)\n- Removed ``DatetimeIndex.offset`` (:issue:`20730`)\n- Removed ``DatetimeIndex.asobject``, ``TimedeltaIndex.asobject``, ``PeriodIndex.asobject``, use ``astype(object)`` instead (:issue:`29801`)\n- Removed the previously deprecated keyword \"order\" from :func:`factorize` (:issue:`19751`)\n- Removed the previously deprecated keyword \"encoding\" from :func:`read_stata` and :meth:`DataFrame.to_stata` (:issue:`21400`)\n- Changed the default \"sort\" argument in :func:`concat` from ``None`` to ``False`` (:issue:`20613`)\n- Removed the previously deprecated keyword \"raise_conflict\" from :meth:`DataFrame.update`, use \"errors\" instead (:issue:`23585`)\n- Removed the previously deprecated keyword \"n\" from :meth:`DatetimeIndex.shift`, :meth:`TimedeltaIndex.shift`, :meth:`PeriodIndex.shift`, use \"periods\" instead (:issue:`22458`)\n- Removed the previously deprecated keywords \"how\", \"fill_method\", and \"limit\" from :meth:`DataFrame.resample` (:issue:`30139`)\n- Passing an integer to :meth:`Series.fillna` or :meth:`DataFrame.fillna` with ``timedelta64[ns]`` dtype now raises ``TypeError`` (:issue:`24694`)\n- Passing multiple axes to :meth:`DataFrame.dropna` is no longer supported (:issue:`20995`)\n- Removed ``Series.nonzero``, use ``to_numpy().nonzero()`` instead (:issue:`24048`)\n- Passing floating dtype ``codes`` to :meth:`Categorical.from_codes` is no longer supported, pass ``codes.astype(np.int64)`` instead (:issue:`21775`)\n- Removed the previously deprecated keyword \"pat\" from :meth:`Series.str.partition` and :meth:`Series.str.rpartition`, use \"sep\" instead (:issue:`23767`)\n- Removed ``Series.put`` (:issue:`27106`)\n- Removed ``Series.real``, ``Series.imag`` (:issue:`27106`)\n- Removed ``Series.to_dense``, ``DataFrame.to_dense`` (:issue:`26684`)\n- Removed ``Index.dtype_str``, use ``str(index.dtype)`` instead (:issue:`27106`)\n- :meth:`Categorical.ravel` returns a :class:`Categorical` instead of a ``ndarray`` (:issue:`27199`)\n- The 'outer' method on Numpy ufuncs, e.g. ``np.subtract.outer`` operating on :class:`Series` objects is no longer supported, and will raise ``NotImplementedError`` (:issue:`27198`)\n- Removed ``Series.get_dtype_counts`` and ``DataFrame.get_dtype_counts`` (:issue:`27145`)\n- Changed the default \"fill_value\" argument in :meth:`Categorical.take` from ``True`` to ``False`` (:issue:`20841`)\n- Changed the default value for the ``raw`` argument in :func:`Series.rolling().apply() <.Rolling.apply>`, :func:`DataFrame.rolling().apply() <.Rolling.apply>`, :func:`Series.expanding().apply() <.Expanding.apply>`, and :func:`DataFrame.expanding().apply() <.Expanding.apply>` from ``None`` to ``False`` (:issue:`20584`)\n- Removed deprecated behavior of :meth:`Series.argmin` and :meth:`Series.argmax`, use :meth:`Series.idxmin` and :meth:`Series.idxmax` for the old behavior (:issue:`16955`)\n- Passing a tz-aware ``datetime.datetime`` or :class:`Timestamp` into the :class:`Timestamp` constructor with the ``tz`` argument now raises a ``ValueError`` (:issue:`23621`)\n- Removed ``Series.base``, ``Index.base``, ``Categorical.base``, ``Series.flags``, ``Index.flags``, ``PeriodArray.flags``, ``Series.strides``, ``Index.strides``, ``Series.itemsize``, ``Index.itemsize``, ``Series.data``, ``Index.data`` (:issue:`20721`)\n- Changed :meth:`Timedelta.resolution` to match the behavior of the standard library ``datetime.timedelta.resolution``, for the old behavior, use :meth:`Timedelta.resolution_string` (:issue:`26839`)\n- Removed ``Timestamp.weekday_name``, ``DatetimeIndex.weekday_name``, and ``Series.dt.weekday_name`` (:issue:`18164`)\n- Removed the previously deprecated keyword \"errors\" in :meth:`Timestamp.tz_localize`, :meth:`DatetimeIndex.tz_localize`, and :meth:`Series.tz_localize` (:issue:`22644`)\n- Changed the default \"ordered\" argument in :class:`CategoricalDtype` from ``None`` to ``False`` (:issue:`26336`)\n- :meth:`Series.set_axis` and :meth:`DataFrame.set_axis` now require \"labels\" as the first argument and \"axis\" as an optional named parameter (:issue:`30089`)\n- Removed ``to_msgpack``, ``read_msgpack``, ``DataFrame.to_msgpack``, ``Series.to_msgpack`` (:issue:`27103`)\n- Removed ``Series.compress`` (:issue:`21930`)\n- Removed the previously deprecated keyword \"fill_value\" from :meth:`Categorical.fillna`, use \"value\" instead (:issue:`19269`)\n- Removed the previously deprecated keyword \"data\" from :func:`andrews_curves`, use \"frame\" instead (:issue:`6956`)\n- Removed the previously deprecated keyword \"data\" from :func:`parallel_coordinates`, use \"frame\" instead (:issue:`6956`)\n- Removed the previously deprecated keyword \"colors\" from :func:`parallel_coordinates`, use \"color\" instead (:issue:`6956`)\n- Removed the previously deprecated keywords \"verbose\" and \"private_key\" from :func:`read_gbq` (:issue:`30200`)\n- Calling ``np.array`` and ``np.asarray`` on tz-aware :class:`Series` and :class:`DatetimeIndex` will now return an object array of tz-aware :class:`Timestamp` (:issue:`24596`)\n-\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_100.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n- Performance improvement in :class:`DataFrame` arithmetic and comparison operations with scalars (:issue:`24990`, :issue:`29853`)\n- Performance improvement in indexing with a non-unique :class:`IntervalIndex` (:issue:`27489`)\n- Performance improvement in :attr:`MultiIndex.is_monotonic` (:issue:`27495`)\n- Performance improvement in :func:`cut` when ``bins`` is an :class:`IntervalIndex` (:issue:`27668`)\n- Performance improvement when initializing a :class:`DataFrame` using a ``range`` (:issue:`30171`)\n- Performance improvement in :meth:`DataFrame.corr` when ``method`` is ``\"spearman\"`` (:issue:`28139`)\n- Performance improvement in :meth:`DataFrame.replace` when provided a list of values to replace (:issue:`28099`)\n- Performance improvement in :meth:`DataFrame.select_dtypes` by using vectorization instead of iterating over a loop (:issue:`28317`)\n- Performance improvement in :meth:`Categorical.searchsorted` and  :meth:`CategoricalIndex.searchsorted` (:issue:`28795`)\n- Performance improvement when comparing a :class:`Categorical` with a scalar and the scalar is not found in the categories (:issue:`29750`)\n- Performance improvement when checking if values in a :class:`Categorical` are equal, equal or larger or larger than a given scalar.\n  The improvement is not present if checking if the :class:`Categorical` is less than or less than or equal than the scalar (:issue:`29820`)\n- Performance improvement in :meth:`Index.equals` and  :meth:`MultiIndex.equals` (:issue:`29134`)\n- Performance improvement in :func:`~pandas.api.types.infer_dtype` when ``skipna`` is ``True`` (:issue:`28814`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_100.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\n\nCategorical\n^^^^^^^^^^^\n\n- Added test to assert the :func:`fillna` raises the correct ``ValueError`` message when the value isn't a value from categories (:issue:`13628`)\n- Bug in :meth:`Categorical.astype` where ``NaN`` values were handled incorrectly when casting to int (:issue:`28406`)\n- :meth:`DataFrame.reindex` with a :class:`CategoricalIndex` would fail when the targets contained duplicates, and wouldn't fail if the source contained duplicates (:issue:`28107`)\n- Bug in :meth:`Categorical.astype` not allowing for casting to extension dtypes (:issue:`28668`)\n- Bug where :func:`merge` was unable to join on categorical and extension dtype columns (:issue:`28668`)\n- :meth:`Categorical.searchsorted` and :meth:`CategoricalIndex.searchsorted` now work on unordered categoricals also (:issue:`21667`)\n- Added test to assert roundtripping to parquet with :func:`DataFrame.to_parquet` or :func:`read_parquet` will preserve Categorical dtypes for string types (:issue:`27955`)\n- Changed the error message in :meth:`Categorical.remove_categories` to always show the invalid removals as a set (:issue:`28669`)\n- Using date accessors on a categorical dtyped :class:`Series` of datetimes was not returning an object of the\n  same type as if one used the :meth:`.str.` / :meth:`.dt.` on a :class:`Series` of that type. E.g. when accessing :meth:`Series.dt.tz_localize` on a\n  :class:`Categorical` with duplicate entries, the accessor was skipping duplicates (:issue:`27952`)\n- Bug in :meth:`DataFrame.replace` and :meth:`Series.replace` that would give incorrect results on categorical data (:issue:`26988`)\n- Bug where calling :meth:`Categorical.min` or :meth:`Categorical.max` on an empty Categorical would raise a numpy exception (:issue:`30227`)\n- The following methods now also correctly output values for unobserved categories when called through ``groupby(..., observed=False)`` (:issue:`17605`)\n  * :meth:`core.groupby.SeriesGroupBy.count`\n  * :meth:`core.groupby.SeriesGroupBy.size`\n  * :meth:`core.groupby.SeriesGroupBy.nunique`\n  * :meth:`core.groupby.SeriesGroupBy.nth`\n\n\nDatetimelike\n^^^^^^^^^^^^\n- Bug in :meth:`Series.__setitem__` incorrectly casting ``np.timedelta64(\"NaT\")`` to ``np.datetime64(\"NaT\")`` when inserting into a :class:`Series` with datetime64 dtype (:issue:`27311`)\n- Bug in :meth:`Series.dt` property lookups when the underlying data is read-only (:issue:`27529`)\n- Bug in ``HDFStore.__getitem__`` incorrectly reading tz attribute created in Python 2 (:issue:`26443`)\n- Bug in :func:`to_datetime` where passing arrays of malformed ``str`` with errors=\"coerce\" could incorrectly lead to raising ``ValueError`` (:issue:`28299`)\n- Bug in :meth:`core.groupby.SeriesGroupBy.nunique` where ``NaT`` values were interfering with the count of unique values (:issue:`27951`)\n- Bug in :class:`Timestamp` subtraction when subtracting a :class:`Timestamp` from a ``np.datetime64`` object incorrectly raising ``TypeError`` (:issue:`28286`)\n- Addition and subtraction of integer or integer-dtype arrays with :class:`Timestamp` will now raise ``NullFrequencyError`` instead of ``ValueError`` (:issue:`28268`)\n- Bug in :class:`Series` and :class:`DataFrame` with integer dtype failing to raise ``TypeError`` when adding or subtracting a ``np.datetime64`` object (:issue:`28080`)\n- Bug in :meth:`Series.astype`, :meth:`Index.astype`, and :meth:`DataFrame.astype` failing to handle ``NaT`` when casting to an integer dtype (:issue:`28492`)\n- Bug in :class:`Week` with ``weekday`` incorrectly raising ``AttributeError`` instead of ``TypeError`` when adding or subtracting an invalid type (:issue:`28530`)\n- Bug in :class:`DataFrame` arithmetic operations when operating with a :class:`Series` with dtype ``'timedelta64[ns]'`` (:issue:`28049`)\n- Bug in :func:`core.groupby.generic.SeriesGroupBy.apply` raising ``ValueError`` when a column in the original DataFrame is a datetime and the column labels are not standard integers (:issue:`28247`)\n- Bug in :func:`pandas._config.localization.get_locales` where the ``locales -a`` encodes the locales list as windows-1252 (:issue:`23638`, :issue:`24760`, :issue:`27368`)\n- Bug in :meth:`Series.var` failing to raise ``TypeError`` when called with ``timedelta64[ns]`` dtype (:issue:`28289`)\n- Bug in :meth:`DatetimeIndex.strftime` and :meth:`Series.dt.strftime` where ``NaT`` was converted to the string ``'NaT'`` instead of ``np.nan`` (:issue:`29578`)\n- Bug in masking datetime-like arrays with a boolean mask of an incorrect length not raising an ``IndexError`` (:issue:`30308`)\n- Bug in :attr:`Timestamp.resolution` being a property instead of a class attribute (:issue:`29910`)\n- Bug in :func:`pandas.to_datetime` when called with ``None`` raising ``TypeError`` instead of returning ``NaT`` (:issue:`30011`)\n- Bug in :func:`pandas.to_datetime` failing for ``deque`` objects when using ``cache=True`` (the default) (:issue:`29403`)\n- Bug in :meth:`Series.item` with ``datetime64`` or ``timedelta64`` dtype, :meth:`DatetimeIndex.item`, and :meth:`TimedeltaIndex.item` returning an integer instead of a :class:`Timestamp` or :class:`Timedelta` (:issue:`30175`)\n- Bug in :class:`DatetimeIndex` addition when adding a non-optimized :class:`DateOffset` incorrectly dropping timezone information (:issue:`30336`)\n- Bug in :meth:`DataFrame.drop` where attempting to drop non-existent values from a DatetimeIndex would yield a confusing error message (:issue:`30399`)\n- Bug in :meth:`DataFrame.append` would remove the timezone-awareness of new data (:issue:`30238`)\n- Bug in :meth:`Series.cummin` and :meth:`Series.cummax` with timezone-aware dtype incorrectly dropping its timezone (:issue:`15553`)\n- Bug in :class:`DatetimeArray`, :class:`TimedeltaArray`, and :class:`PeriodArray` where inplace addition and subtraction did not actually operate inplace (:issue:`24115`)\n- Bug in :func:`pandas.to_datetime` when called with ``Series`` storing ``IntegerArray`` raising ``TypeError`` instead of returning ``Series`` (:issue:`30050`)\n- Bug in :func:`date_range` with custom business hours as ``freq`` and given number of ``periods`` (:issue:`30593`)\n- Bug in :class:`PeriodIndex` comparisons with incorrectly casting integers to :class:`Period` objects, inconsistent with the :class:`Period` comparison behavior (:issue:`30722`)\n- Bug in :meth:`DatetimeIndex.insert` raising a ``ValueError`` instead of a ``TypeError`` when trying to insert a timezone-aware :class:`Timestamp` into a timezone-naive :class:`DatetimeIndex`, or vice-versa (:issue:`30806`)\n\nTimedelta\n^^^^^^^^^\n- Bug in subtracting a :class:`TimedeltaIndex` or :class:`TimedeltaArray` from a ``np.datetime64`` object (:issue:`29558`)\n-\n\nTimezones\n^^^^^^^^^\n\n-\n\n\nNumeric\n^^^^^^^\n- Bug in :meth:`DataFrame.quantile` with zero-column :class:`DataFrame` incorrectly raising (:issue:`23925`)\n- :class:`DataFrame` flex inequality comparisons methods (:meth:`DataFrame.lt`, :meth:`DataFrame.le`, :meth:`DataFrame.gt`, :meth:`DataFrame.ge`) with object-dtype and ``complex`` entries failing to raise ``TypeError`` like their :class:`Series` counterparts (:issue:`28079`)\n- Bug in :class:`DataFrame` logical operations (``&``, ``|``, ``^``) not matching :class:`Series` behavior by filling NA values (:issue:`28741`)\n- Bug in :meth:`DataFrame.interpolate` where specifying axis by name references variable before it is assigned (:issue:`29142`)\n- Bug in :meth:`Series.var` not computing the right value with a nullable integer dtype series not passing through ddof argument (:issue:`29128`)\n- Improved error message when using ``frac`` > 1 and ``replace`` = False (:issue:`27451`)\n- Bug in numeric indexes resulted in it being possible to instantiate an :class:`Int64Index`, :class:`UInt64Index`, or :class:`Float64Index` with an invalid dtype (e.g. datetime-like) (:issue:`29539`)\n- Bug in :class:`UInt64Index` precision loss while constructing from a list with values in the ``np.uint64`` range (:issue:`29526`)\n- Bug in :class:`NumericIndex` construction that caused indexing to fail when integers in the ``np.uint64`` range were used (:issue:`28023`)\n- Bug in :class:`NumericIndex` construction that caused :class:`UInt64Index` to be casted to :class:`Float64Index` when integers in the ``np.uint64`` range were used to index a :class:`DataFrame` (:issue:`28279`)\n- Bug in :meth:`Series.interpolate` when using method=`index` with an unsorted index, would previously return incorrect results. (:issue:`21037`)\n- Bug in :meth:`DataFrame.round` where a :class:`DataFrame` with a :class:`CategoricalIndex` of :class:`IntervalIndex` columns would incorrectly raise a ``TypeError`` (:issue:`30063`)\n- Bug in :meth:`Series.pct_change` and :meth:`DataFrame.pct_change` when there are duplicated indices (:issue:`30463`)\n- Bug in :class:`DataFrame` cumulative operations (e.g. cumsum, cummax) incorrect casting to object-dtype (:issue:`19296`)\n- Bug in :class:`~DataFrame.diff` losing the dtype for extension types (:issue:`30889`)\n- Bug in :class:`DataFrame.diff` raising an ``IndexError`` when one of the columns was a nullable integer dtype (:issue:`30967`)\n\nConversion\n^^^^^^^^^^\n\n-\n\nStrings\n^^^^^^^\n\n- Calling :meth:`Series.str.isalnum` (and other \"ismethods\") on an empty ``Series`` would return an ``object`` dtype instead of ``bool`` (:issue:`29624`)\n-\n\n\nInterval\n^^^^^^^^\n\n- Bug in :meth:`IntervalIndex.get_indexer` where a :class:`Categorical` or :class:`CategoricalIndex` ``target`` would incorrectly raise a ``TypeError`` (:issue:`30063`)\n- Bug in ``pandas.core.dtypes.cast.infer_dtype_from_scalar`` where passing ``pandas_dtype=True`` did not infer :class:`IntervalDtype` (:issue:`30337`)\n- Bug in :class:`Series` constructor where constructing a ``Series`` from a ``list`` of :class:`Interval` objects resulted in ``object`` dtype instead of :class:`IntervalDtype` (:issue:`23563`)\n- Bug in :class:`IntervalDtype` where the ``kind`` attribute was incorrectly set as ``None`` instead of ``\"O\"`` (:issue:`30568`)\n- Bug in :class:`IntervalIndex`, :class:`~arrays.IntervalArray`, and :class:`Series` with interval data where equality comparisons were incorrect (:issue:`24112`)\n\nIndexing\n^^^^^^^^\n\n- Bug in assignment using a reverse slicer (:issue:`26939`)\n- Bug in :meth:`DataFrame.explode` would duplicate frame in the presence of duplicates in the index (:issue:`28010`)\n- Bug in reindexing a :meth:`PeriodIndex` with another type of index that contained a ``Period`` (:issue:`28323`) (:issue:`28337`)\n- Fix assignment of column via ``.loc`` with numpy non-ns datetime type (:issue:`27395`)\n- Bug in :meth:`Float64Index.astype` where ``np.inf`` was not handled properly when casting to an integer dtype (:issue:`28475`)\n- :meth:`Index.union` could fail when the left contained duplicates (:issue:`28257`)\n- Bug when indexing with ``.loc`` where the index was a :class:`CategoricalIndex` with non-string categories didn't work (:issue:`17569`, :issue:`30225`)\n- :meth:`Index.get_indexer_non_unique` could fail with ``TypeError`` in some cases, such as when searching for ints in a string index (:issue:`28257`)\n- Bug in :meth:`Float64Index.get_loc` incorrectly raising ``TypeError`` instead of ``KeyError`` (:issue:`29189`)\n- Bug in :meth:`DataFrame.loc` with incorrect dtype when setting Categorical value in 1-row DataFrame (:issue:`25495`)\n- :meth:`MultiIndex.get_loc` can't find missing values when input includes missing values (:issue:`19132`)\n- Bug in :meth:`Series.__setitem__` incorrectly assigning values with boolean indexer when the length of new data matches the number of ``True`` values and new data is not a ``Series`` or an ``np.array`` (:issue:`30567`)\n- Bug in indexing with a :class:`PeriodIndex` incorrectly accepting integers representing years, use e.g. ``ser.loc[\"2007\"]`` instead of ``ser.loc[2007]`` (:issue:`30763`)\n\nMissing\n^^^^^^^\n\n-\n\nMultiIndex\n^^^^^^^^^^\n\n- Constructor for :class:`MultiIndex` verifies that the given ``sortorder`` is compatible with the actual ``lexsort_depth``  if ``verify_integrity`` parameter is ``True`` (the default) (:issue:`28735`)\n- Series and MultiIndex ``.drop`` with ``MultiIndex`` raise exception if labels not in given in level (:issue:`8594`)\n-\n\nIO\n^^\n\n- :meth:`read_csv` now accepts binary mode file buffers when using the Python csv engine (:issue:`23779`)\n- Bug in :meth:`DataFrame.to_json` where using a Tuple as a column or index value and using ``orient=\"columns\"`` or ``orient=\"index\"`` would produce invalid JSON (:issue:`20500`)\n- Improve infinity parsing. :meth:`read_csv` now interprets ``Infinity``, ``+Infinity``, ``-Infinity`` as floating point values (:issue:`10065`)\n- Bug in :meth:`DataFrame.to_csv` where values were truncated when the length of ``na_rep`` was shorter than the text input data. (:issue:`25099`)\n- Bug in :func:`DataFrame.to_string` where values were truncated using display options instead of outputting the full content (:issue:`9784`)\n- Bug in :meth:`DataFrame.to_json` where a datetime column label would not be written out in ISO format with ``orient=\"table\"`` (:issue:`28130`)\n- Bug in :func:`DataFrame.to_parquet` where writing to GCS would fail with ``engine='fastparquet'`` if the file did not already exist (:issue:`28326`)\n- Bug in :func:`read_hdf` closing stores that it didn't open when Exceptions are raised (:issue:`28699`)\n- Bug in :meth:`DataFrame.read_json` where using ``orient=\"index\"`` would not maintain the order (:issue:`28557`)\n- Bug in :meth:`DataFrame.to_html` where the length of the ``formatters`` argument was not verified (:issue:`28469`)\n- Bug in :meth:`DataFrame.read_excel` with ``engine='ods'`` when ``sheet_name`` argument references a non-existent sheet (:issue:`27676`)\n- Bug in :meth:`pandas.io.formats.style.Styler` formatting for floating values not displaying decimals correctly (:issue:`13257`)\n- Bug in :meth:`DataFrame.to_html` when using ``formatters=<list>`` and ``max_cols`` together. (:issue:`25955`)\n- Bug in :meth:`Styler.background_gradient` not able to work with dtype ``Int64`` (:issue:`28869`)\n- Bug in :meth:`DataFrame.to_clipboard` which did not work reliably in ipython (:issue:`22707`)\n- Bug in :func:`read_json` where default encoding was not set to ``utf-8`` (:issue:`29565`)\n- Bug in :class:`PythonParser` where str and bytes were being mixed when dealing with the decimal field (:issue:`29650`)\n- :meth:`read_gbq` now accepts ``progress_bar_type`` to display progress bar while the data downloads. (:issue:`29857`)\n- Bug in :func:`pandas.io.json.json_normalize` where a missing value in the location specified by ``record_path`` would raise a ``TypeError`` (:issue:`30148`)\n- :func:`read_excel` now accepts binary data (:issue:`15914`)\n- Bug in :meth:`read_csv` in which encoding handling was limited to just the string ``utf-16`` for the C engine (:issue:`24130`)\n\nPlotting\n^^^^^^^^\n\n- Bug in :meth:`Series.plot` not able to plot boolean values (:issue:`23719`)\n- Bug in :meth:`DataFrame.plot` not able to plot when no rows (:issue:`27758`)\n- Bug in :meth:`DataFrame.plot` producing incorrect legend markers when plotting multiple series on the same axis (:issue:`18222`)\n- Bug in :meth:`DataFrame.plot` when ``kind='box'`` and data contains datetime or timedelta data. These types are now automatically dropped (:issue:`22799`)\n- Bug in :meth:`DataFrame.plot.line` and :meth:`DataFrame.plot.area` produce wrong xlim in x-axis (:issue:`27686`, :issue:`25160`, :issue:`24784`)\n- Bug where :meth:`DataFrame.boxplot` would not accept a ``color`` parameter like :meth:`DataFrame.plot.box` (:issue:`26214`)\n- Bug in the ``xticks`` argument being ignored for :meth:`DataFrame.plot.bar` (:issue:`14119`)\n- :func:`set_option` now validates that the plot backend provided to ``'plotting.backend'`` implements the backend when the option is set, rather than when a plot is created (:issue:`28163`)\n- :meth:`DataFrame.plot` now allow a ``backend`` keyword argument to allow changing between backends in one session (:issue:`28619`).\n- Bug in color validation incorrectly raising for non-color styles (:issue:`29122`).\n- Allow :meth:`DataFrame.plot.scatter` to plot ``objects`` and ``datetime`` type data (:issue:`18755`, :issue:`30391`)\n- Bug in :meth:`DataFrame.hist`, ``xrot=0`` does not work with ``by`` and subplots (:issue:`30288`).\n\nGroupBy/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n- Bug in :meth:`core.groupby.DataFrameGroupBy.apply` only showing output from a single group when function returns an :class:`Index` (:issue:`28652`)\n- Bug in :meth:`DataFrame.groupby` with multiple groups where an ``IndexError`` would be raised if any group contained all NA values (:issue:`20519`)\n- Bug in :meth:`.Resampler.size` and :meth:`.Resampler.count` returning wrong dtype when used with an empty :class:`Series` or :class:`DataFrame` (:issue:`28427`)\n- Bug in :meth:`DataFrame.rolling` not allowing for rolling over datetimes when ``axis=1`` (:issue:`28192`)\n- Bug in :meth:`DataFrame.rolling` not allowing rolling over multi-index levels (:issue:`15584`).\n- Bug in :meth:`DataFrame.rolling` not allowing rolling on monotonic decreasing time indexes (:issue:`19248`).\n- Bug in :meth:`DataFrame.groupby` not offering selection by column name when ``axis=1`` (:issue:`27614`)\n- Bug in :meth:`core.groupby.DataFrameGroupby.agg` not able to use lambda function with named aggregation (:issue:`27519`)\n- Bug in :meth:`DataFrame.groupby` losing column name information when grouping by a categorical column (:issue:`28787`)\n- Remove error raised due to duplicated input functions in named aggregation in :meth:`DataFrame.groupby` and :meth:`Series.groupby`. Previously error will be raised if the same function is applied on the same column and now it is allowed if new assigned names are different. (:issue:`28426`)\n- :meth:`core.groupby.SeriesGroupBy.value_counts` will be able to handle the case even when the :class:`Grouper` makes empty groups (:issue:`28479`)\n- Bug in :meth:`core.window.rolling.Rolling.quantile` ignoring ``interpolation`` keyword argument when used within a groupby (:issue:`28779`)\n- Bug in :meth:`DataFrame.groupby` where ``any``, ``all``, ``nunique`` and transform functions would incorrectly handle duplicate column labels (:issue:`21668`)\n- Bug in :meth:`core.groupby.DataFrameGroupBy.agg` with timezone-aware datetime64 column incorrectly casting results to the original dtype (:issue:`29641`)\n- Bug in :meth:`DataFrame.groupby` when using axis=1 and having a single level columns index (:issue:`30208`)\n- Bug in :meth:`DataFrame.groupby` when using nunique on axis=1 (:issue:`30253`)\n- Bug in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` with multiple list-like q value and integer column names (:issue:`30289`)\n- Bug in :meth:`.DataFrameGroupBy.pct_change` and :meth:`.SeriesGroupBy.pct_change` causes ``TypeError`` when ``fill_method`` is ``None`` (:issue:`30463`)\n- Bug in :meth:`Rolling.count` and :meth:`Expanding.count` argument where ``min_periods`` was ignored (:issue:`26996`)\n\nReshaping\n^^^^^^^^^\n\n- Bug in :meth:`DataFrame.apply` that caused incorrect output with empty :class:`DataFrame` (:issue:`28202`, :issue:`21959`)\n- Bug in :meth:`DataFrame.stack` not handling non-unique indexes correctly when creating MultiIndex (:issue:`28301`)\n- Bug in :meth:`pivot_table` not returning correct type ``float`` when ``margins=True`` and ``aggfunc='mean'`` (:issue:`24893`)\n- Bug :func:`merge_asof` could not use :class:`datetime.timedelta` for ``tolerance`` kwarg (:issue:`28098`)\n- Bug in :func:`merge`, did not append suffixes correctly with MultiIndex (:issue:`28518`)\n- :func:`qcut` and :func:`cut` now handle boolean input (:issue:`20303`)\n- Fix to ensure all int dtypes can be used in :func:`merge_asof` when using a tolerance value. Previously every non-int64 type would raise an erroneous ``MergeError`` (:issue:`28870`).\n- Better error message in :func:`get_dummies` when ``columns`` isn't a list-like value (:issue:`28383`)\n- Bug in :meth:`Index.join` that caused infinite recursion error for mismatched ``MultiIndex`` name orders. (:issue:`25760`, :issue:`28956`)\n- Bug :meth:`Series.pct_change` where supplying an anchored frequency would throw a ``ValueError`` (:issue:`28664`)\n- Bug where :meth:`DataFrame.equals` returned True incorrectly in some cases when two DataFrames had the same columns in different orders (:issue:`28839`)\n- Bug in :meth:`DataFrame.replace` that caused non-numeric replacer's dtype not respected (:issue:`26632`)\n- Bug in :func:`melt` where supplying mixed strings and numeric values for ``id_vars`` or ``value_vars`` would incorrectly raise a ``ValueError`` (:issue:`29718`)\n- Dtypes are now preserved when transposing a ``DataFrame`` where each column is the same extension dtype (:issue:`30091`)\n- Bug in :func:`merge_asof` merging on a tz-aware ``left_index`` and ``right_on`` a tz-aware column (:issue:`29864`)\n- Improved error message and docstring in :func:`cut` and :func:`qcut` when ``labels=True`` (:issue:`13318`)\n- Bug in missing ``fill_na`` parameter to :meth:`DataFrame.unstack` with list of levels (:issue:`30740`)\n\nSparse\n^^^^^^\n- Bug in :class:`SparseDataFrame` arithmetic operations incorrectly casting inputs to float (:issue:`28107`)\n- Bug in ``DataFrame.sparse`` returning a ``Series`` when there was a column named ``sparse`` rather than the accessor (:issue:`30758`)\n- Fixed :meth:`operator.xor` with a boolean-dtype ``SparseArray``. Now returns a sparse result, rather than object dtype (:issue:`31025`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n\n- Bug in :class:`arrays.PandasArray` when setting a scalar string (:issue:`28118`, :issue:`28150`).\n- Bug where nullable integers could not be compared to strings (:issue:`28930`)\n- Bug where :class:`DataFrame` constructor raised ``ValueError`` with list-like data and ``dtype`` specified (:issue:`30280`)\n\nOther\n^^^^^\n- Trying to set the ``display.precision``, ``display.max_rows`` or ``display.max_columns`` using :meth:`set_option` to anything but a ``None`` or a positive int will raise a ``ValueError`` (:issue:`23348`)\n- Using :meth:`DataFrame.replace` with overlapping keys in a nested dictionary will no longer raise, now matching the behavior of a flat dictionary (:issue:`27660`)\n- :meth:`DataFrame.to_csv` and :meth:`Series.to_csv` now support dicts as ``compression`` argument with key ``'method'`` being the compression method and others as additional compression options when the compression method is ``'zip'``. (:issue:`26023`)\n- Bug in :meth:`Series.diff` where a boolean series would incorrectly raise a ``TypeError`` (:issue:`17294`)\n- :meth:`Series.append` will no longer raise a ``TypeError`` when passed a tuple of ``Series`` (:issue:`28410`)\n- Fix corrupted error message when calling ``pandas.libs._json.encode()`` on a 0d array (:issue:`18878`)\n- Backtick quoting in :meth:`DataFrame.query` and :meth:`DataFrame.eval` can now also be used to use invalid identifiers like names that start with a digit, are python keywords, or are using single character operators. (:issue:`27017`)\n- Bug in ``pd.core.util.hashing.hash_pandas_object`` where arrays containing tuples were incorrectly treated as non-hashable (:issue:`28969`)\n- Bug in :meth:`DataFrame.append` that raised ``IndexError`` when appending with empty list (:issue:`28769`)\n- Fix :class:`AbstractHolidayCalendar` to return correct results for\n  years after 2030 (now goes up to 2200) (:issue:`27790`)\n- Fixed :class:`~arrays.IntegerArray` returning ``inf`` rather than ``NaN`` for operations dividing by ``0`` (:issue:`27398`)\n- Fixed ``pow`` operations for :class:`~arrays.IntegerArray` when the other value is ``0`` or ``1`` (:issue:`29997`)\n- Bug in :meth:`Series.count` raises if use_inf_as_na is enabled (:issue:`29478`)\n- Bug in :class:`Index` where a non-hashable name could be set without raising ``TypeError`` (:issue:`29069`)\n- Bug in :class:`DataFrame` constructor when passing a 2D ``ndarray`` and an extension dtype (:issue:`12513`)\n- Bug in :meth:`DataFrame.to_csv` when supplied a series with a ``dtype=\"string\"`` and a ``na_rep``, the ``na_rep`` was being truncated to 2 characters. (:issue:`29975`)\n- Bug where :meth:`DataFrame.itertuples` would incorrectly determine whether or not namedtuples could be used for dataframes of 255 columns (:issue:`28282`)\n- Handle nested NumPy ``object`` arrays in :func:`testing.assert_series_equal` for ExtensionArray implementations (:issue:`30841`)\n- Bug in :class:`Index` constructor incorrectly allowing 2-dimensional input arrays (:issue:`13601`, :issue:`27125`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_100.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.25.3..v1.0.0\n", "1.3.1": ".. _whatsnew_131:\n\nWhat's new in 1.3.1 (July 25, 2021)\n-----------------------------------\n\nThese are the changes in pandas 1.3.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_131.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Pandas could not be built on PyPy (:issue:`42355`)\n- :class:`DataFrame` constructed with an older version of pandas could not be unpickled (:issue:`42345`)\n- Performance regression in constructing a :class:`DataFrame` from a dictionary of dictionaries (:issue:`42248`)\n- Fixed regression in :meth:`DataFrame.agg` dropping values when the DataFrame had an Extension Array dtype, a duplicate index, and ``axis=1`` (:issue:`42380`)\n- Fixed regression in :meth:`DataFrame.astype` changing the order of noncontiguous data (:issue:`42396`)\n- Performance regression in :class:`DataFrame` in reduction operations requiring casting such as :meth:`DataFrame.mean` on integer data (:issue:`38592`)\n- Performance regression in :meth:`DataFrame.to_dict` and :meth:`Series.to_dict` when ``orient`` argument one of \"records\", \"dict\", or \"split\" (:issue:`42352`)\n- Fixed regression in indexing with a ``list`` subclass incorrectly raising ``TypeError`` (:issue:`42433`, :issue:`42461`)\n- Fixed regression in :meth:`DataFrame.isin` and :meth:`Series.isin` raising ``TypeError`` with nullable data containing at least one missing value (:issue:`42405`)\n- Regression in :func:`concat` between objects with bool dtype and integer dtype casting to object instead of to integer (:issue:`42092`)\n- Bug in :class:`Series` constructor not accepting a ``dask.Array`` (:issue:`38645`)\n- Fixed regression for ``SettingWithCopyWarning`` displaying incorrect stacklevel (:issue:`42570`)\n- Fixed regression for :func:`merge_asof` raising ``KeyError`` when one of the ``by`` columns is in the index (:issue:`34488`)\n- Fixed regression in :func:`to_datetime` returning pd.NaT for inputs that produce duplicated values, when ``cache=True`` (:issue:`42259`)\n- Fixed regression in :meth:`SeriesGroupBy.value_counts` that resulted in an ``IndexError`` when called on a Series with one row (:issue:`42618`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_131.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fixed bug in :meth:`DataFrame.transpose` dropping values when the DataFrame had an Extension Array dtype and a duplicate index (:issue:`42380`)\n- Fixed bug in :meth:`DataFrame.to_xml` raising ``KeyError`` when called with ``index=False`` and an offset index (:issue:`42458`)\n- Fixed bug in :meth:`.Styler.set_sticky` not handling index names correctly for single index columns case (:issue:`42537`)\n- Fixed bug in :meth:`DataFrame.copy` failing to consolidate blocks in the result (:issue:`42579`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_131.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.3.0..v1.3.1\n", "1.2.3": ".. _whatsnew_123:\n\nWhat's new in 1.2.3 (March 02, 2021)\n------------------------------------\n\nThese are the changes in pandas 1.2.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_123.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n\n- Fixed regression in :meth:`~DataFrame.to_excel` raising ``KeyError`` when giving duplicate columns with ``columns`` attribute (:issue:`39695`)\n- Fixed regression in nullable integer unary ops propagating mask on assignment (:issue:`39943`)\n- Fixed regression in :meth:`DataFrame.__setitem__` not aligning :class:`DataFrame` on right-hand side for boolean indexer (:issue:`39931`)\n- Fixed regression in :meth:`~DataFrame.to_json` failing to use ``compression`` with URL-like paths that are internally opened in binary mode or with user-provided file objects that are opened in binary mode (:issue:`39985`)\n- Fixed regression in :meth:`Series.sort_index` and :meth:`DataFrame.sort_index`, which exited with an ungraceful error when having kwarg ``ascending=None`` passed. Passing ``ascending=None`` is still considered invalid, and the improved error message suggests a proper usage (``ascending`` must be a boolean or a list-like of boolean) (:issue:`39434`)\n- Fixed regression in :meth:`DataFrame.transform` and :meth:`Series.transform` giving incorrect column labels when passed a dictionary with a mix of list and non-list values (:issue:`40018`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_123.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.2.2..v1.2.3\n", "1.2.0": ".. _whatsnew_120:\n\nWhat's new in 1.2.0 (December 26, 2020)\n---------------------------------------\n\nThese are the changes in pandas 1.2.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. warning::\n\n   The `xlwt <https://xlwt.readthedocs.io/en/latest/>`_ package for writing old-style ``.xls``\n   excel files is no longer maintained.\n   The `xlrd <https://xlrd.readthedocs.io/en/latest/>`_ package is now only for reading\n   old-style ``.xls`` files.\n\n   Previously, the default argument ``engine=None`` to :func:`~pandas.read_excel`\n   would result in using the ``xlrd`` engine in many cases, including new\n   Excel 2007+ (``.xlsx``) files.\n   If `openpyxl <https://openpyxl.readthedocs.io/en/stable/>`_  is installed,\n   many of these cases will now default to using the ``openpyxl`` engine.\n   See the :func:`read_excel` documentation for more details.\n\n   Thus, it is strongly encouraged to install ``openpyxl`` to read Excel 2007+\n   (``.xlsx``) files.\n   **Please do not report issues when using ``xlrd`` to read ``.xlsx`` files.**\n   This is no longer supported, switch to using ``openpyxl`` instead.\n\n   Attempting to use the ``xlwt`` engine will raise a ``FutureWarning``\n   unless the option :attr:`io.excel.xls.writer` is set to ``\"xlwt\"``.\n   While this option is now deprecated and will also raise a ``FutureWarning``,\n   it can be globally set and the warning suppressed. Users are recommended to\n   write ``.xlsx`` files using the ``openpyxl`` engine instead.\n\n.. ---------------------------------------------------------------------------\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_120.duplicate_labels:\n\nOptionally disallow duplicate labels\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`Series` and :class:`DataFrame` can now be created with ``allows_duplicate_labels=False`` flag to\ncontrol whether the index or columns can contain duplicate labels (:issue:`28394`). This can be used to\nprevent accidental introduction of duplicate labels, which can affect downstream operations.\n\nBy default, duplicates continue to be allowed.\n\n.. code-block:: ipython\n\n    In [1]: pd.Series([1, 2], index=['a', 'a'])\n    Out[1]:\n    a    1\n    a    2\n    Length: 2, dtype: int64\n\n    In [2]: pd.Series([1, 2], index=['a', 'a']).set_flags(allows_duplicate_labels=False)\n    ...\n    DuplicateLabelError: Index has duplicates.\n          positions\n    label\n    a        [0, 1]\n\npandas will propagate the ``allows_duplicate_labels`` property through many operations.\n\n.. code-block:: ipython\n\n    In [3]: a = (\n       ...:     pd.Series([1, 2], index=['a', 'b'])\n       ...:       .set_flags(allows_duplicate_labels=False)\n       ...: )\n\n    In [4]: a\n    Out[4]:\n    a    1\n    b    2\n    Length: 2, dtype: int64\n\n    # An operation introducing duplicates\n    In [5]: a.reindex(['a', 'b', 'a'])\n    ...\n    DuplicateLabelError: Index has duplicates.\n          positions\n    label\n    a        [0, 2]\n\n    [1 rows x 1 columns]\n\n.. warning::\n\n   This is an experimental feature. Currently, many methods fail to\n   propagate the ``allows_duplicate_labels`` value. In future versions\n   it is expected that every method taking or returning one or more\n   DataFrame or Series objects will propagate ``allows_duplicate_labels``.\n\nSee :ref:`duplicates` for more.\n\nThe ``allows_duplicate_labels`` flag is stored in the new :attr:`DataFrame.flags`\nattribute. This stores global attributes that apply to the *pandas object*. This\ndiffers from :attr:`DataFrame.attrs`, which stores information that applies to\nthe dataset.\n\nPassing arguments to fsspec backends\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nMany read/write functions have acquired the ``storage_options`` optional argument,\nto pass a dictionary of parameters to the storage backend. This allows, for\nexample, for passing credentials to S3 and GCS storage. The details of what\nparameters can be passed to which backends can be found in the documentation\nof the individual storage backends (detailed from the fsspec docs for\n`builtin implementations`_ and linked to `external ones`_). See\nSection :ref:`io.remote`.\n\n:issue:`35655` added fsspec support (including ``storage_options``)\nfor reading excel files.\n\n.. _builtin implementations: https://filesystem-spec.readthedocs.io/en/latest/api.html#built-in-implementations\n.. _external ones: https://filesystem-spec.readthedocs.io/en/latest/api.html#other-known-implementations\n\n.. _whatsnew_120.binary_handle_to_csv:\n\nSupport for binary file handles in ``to_csv``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`to_csv` supports file handles in binary mode (:issue:`19827` and :issue:`35058`)\nwith ``encoding`` (:issue:`13068` and :issue:`23854`) and ``compression`` (:issue:`22555`).\nIf pandas does not automatically detect whether the file handle is opened in binary or text mode,\nit is necessary to provide ``mode=\"wb\"``.\n\nFor example:\n\n.. ipython:: python\n\n   import io\n\n   data = pd.DataFrame([0, 1, 2])\n   buffer = io.BytesIO()\n   data.to_csv(buffer, encoding=\"utf-8\", compression=\"gzip\")\n\nSupport for short caption and table position in ``to_latex``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`DataFrame.to_latex` now allows one to specify\na floating table position (:issue:`35281`)\nand a short caption (:issue:`36267`).\n\nThe keyword ``position`` has been added to set the position.\n\n.. ipython:: python\n   :okwarning:\n\n   data = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})\n   table = data.to_latex(position='ht')\n   print(table)\n\nUsage of the keyword ``caption`` has been extended.\nBesides taking a single string as an argument,\none can optionally provide a tuple ``(full_caption, short_caption)``\nto add a short caption macro.\n\n.. ipython:: python\n   :okwarning:\n\n   data = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})\n   table = data.to_latex(caption=('the full long caption', 'short caption'))\n   print(table)\n\n.. _whatsnew_120.read_csv_table_precision_default:\n\nChange in default floating precision for ``read_csv`` and ``read_table``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor the C parsing engine, the methods :meth:`read_csv` and :meth:`read_table` previously defaulted to a parser that\ncould read floating point numbers slightly incorrectly with respect to the last bit in precision.\nThe option ``floating_precision=\"high\"`` has always been available to avoid this issue.\nBeginning with this version, the default is now to use the more accurate parser by making\n``floating_precision=None`` correspond to the high precision parser, and the new option\n``floating_precision=\"legacy\"`` to use the legacy parser. The change to using the higher precision\nparser by default should have no impact on performance. (:issue:`17154`)\n\n.. _whatsnew_120.floating:\n\nExperimental nullable data types for float data\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've added :class:`Float32Dtype` / :class:`Float64Dtype` and :class:`~arrays.FloatingArray`.\nThese are extension data types dedicated to floating point data that can hold the\n``pd.NA`` missing value indicator (:issue:`32265`, :issue:`34307`).\n\nWhile the default float data type already supports missing values using ``np.nan``,\nthese new data types use ``pd.NA`` (and its corresponding behavior) as the missing\nvalue indicator, in line with the already existing nullable :ref:`integer <integer_na>`\nand :ref:`boolean <boolean>` data types.\n\nOne example where the behavior of ``np.nan`` and ``pd.NA`` is different is\ncomparison operations:\n\n.. ipython:: python\n\n  # the default NumPy float64 dtype\n  s1 = pd.Series([1.5, None])\n  s1\n  s1 > 1\n\n.. ipython:: python\n\n  # the new nullable float64 dtype\n  s2 = pd.Series([1.5, None], dtype=\"Float64\")\n  s2\n  s2 > 1\n\nSee the :ref:`missing_data.NA` doc section for more details on the behavior\nwhen using the ``pd.NA`` missing value indicator.\n\nAs shown above, the dtype can be specified using the \"Float64\" or \"Float32\"\nstring (capitalized to distinguish it from the default \"float64\" data type).\nAlternatively, you can also use the dtype object:\n\n.. ipython:: python\n\n   pd.Series([1.5, None], dtype=pd.Float32Dtype())\n\nOperations with the existing integer or boolean nullable data types that\ngive float results will now also use the nullable floating data types (:issue:`38178`).\n\n.. warning::\n\n   Experimental: the new floating data types are currently experimental, and their\n   behavior or API may still change without warning. Especially the behavior\n   regarding NaN (distinct from NA missing values) is subject to change.\n\n.. _whatsnew_120.index_name_preservation:\n\nIndex/column name preservation when aggregating\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen aggregating using :meth:`concat` or the :class:`DataFrame` constructor, pandas\nwill now attempt to preserve index and column names whenever possible (:issue:`35847`).\nIn the case where all inputs share a common name, this name will be assigned to the\nresult. When the input names do not all agree, the result will be unnamed. Here is an\nexample where the index name is preserved:\n\n.. ipython:: python\n\n    idx = pd.Index(range(5), name='abc')\n    ser = pd.Series(range(5, 10), index=idx)\n    pd.concat({'x': ser[1:], 'y': ser[:-1]}, axis=1)\n\nThe same is true for :class:`MultiIndex`, but the logic is applied separately on a\nlevel-by-level basis.\n\n.. _whatsnew_120.groupby_ewm:\n\nGroupBy supports EWM operations directly\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`.DataFrameGroupBy` now supports exponentially weighted window operations directly (:issue:`16037`).\n\n.. ipython:: python\n\n    df = pd.DataFrame({'A': ['a', 'b', 'a', 'b'], 'B': range(4)})\n    df\n    df.groupby('A').ewm(com=1.0).mean()\n\nAdditionally ``mean`` supports execution via `Numba <https://numba.pydata.org/>`__ with\nthe  ``engine`` and ``engine_kwargs`` arguments. Numba must be installed as an optional dependency\nto use this feature.\n\n.. _whatsnew_120.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n- Added ``day_of_week`` (compatibility alias ``dayofweek``) property to :class:`Timestamp`, :class:`.DatetimeIndex`, :class:`Period`, :class:`PeriodIndex` (:issue:`9605`)\n- Added ``day_of_year`` (compatibility alias ``dayofyear``) property to :class:`Timestamp`, :class:`.DatetimeIndex`, :class:`Period`, :class:`PeriodIndex` (:issue:`9605`)\n- Added :meth:`~DataFrame.set_flags` for setting table-wide flags on a Series or DataFrame (:issue:`28394`)\n- :meth:`DataFrame.applymap` now supports ``na_action`` (:issue:`23803`)\n- :class:`Index` with object dtype supports division and multiplication (:issue:`34160`)\n- :meth:`io.sql.get_schema` now supports a ``schema`` keyword argument that will add a schema into the create table statement (:issue:`28486`)\n- :meth:`DataFrame.explode` and :meth:`Series.explode` now support exploding of sets (:issue:`35614`)\n- :meth:`DataFrame.hist` now supports time series (datetime) data (:issue:`32590`)\n- :meth:`.Styler.set_table_styles` now allows the direct styling of rows and columns and can be chained (:issue:`35607`)\n- :class:`.Styler` now allows direct CSS class name addition to individual data cells (:issue:`36159`)\n- :meth:`.Rolling.mean` and :meth:`.Rolling.sum` use Kahan summation to calculate the mean to avoid numerical problems (:issue:`10319`, :issue:`11645`, :issue:`13254`, :issue:`32761`, :issue:`36031`)\n- :meth:`.DatetimeIndex.searchsorted`, :meth:`.TimedeltaIndex.searchsorted`, :meth:`PeriodIndex.searchsorted`, and :meth:`Series.searchsorted` with datetime-like dtypes will now try to cast string arguments (list-like and scalar) to the matching datetime-like type (:issue:`36346`)\n- Added methods :meth:`IntegerArray.prod`, :meth:`IntegerArray.min`, and :meth:`IntegerArray.max` (:issue:`33790`)\n- Calling a NumPy ufunc on a ``DataFrame`` with extension types now preserves the extension types when possible (:issue:`23743`)\n- Calling a binary-input NumPy ufunc on multiple ``DataFrame`` objects now aligns, matching the behavior of binary operations and ufuncs on ``Series`` (:issue:`23743`).\n  This change has been reverted in pandas 1.2.1, and the behaviour to not align DataFrames\n  is deprecated instead, see the :ref:`the 1.2.1 release notes <whatsnew_121.ufunc_deprecation>`.\n- Where possible :meth:`RangeIndex.difference` and :meth:`RangeIndex.symmetric_difference` will return :class:`RangeIndex` instead of :class:`Int64Index` (:issue:`36564`)\n- :meth:`DataFrame.to_parquet` now supports :class:`MultiIndex` for columns in parquet format (:issue:`34777`)\n- :func:`read_parquet` gained a ``use_nullable_dtypes=True`` option to use nullable dtypes that use ``pd.NA`` as missing value indicator where possible for the resulting DataFrame (default is ``False``, and only applicable for ``engine=\"pyarrow\"``) (:issue:`31242`)\n- Added :meth:`.Rolling.sem` and :meth:`Expanding.sem` to compute the standard error of the mean (:issue:`26476`)\n- :meth:`.Rolling.var` and :meth:`.Rolling.std` use Kahan summation and Welford's Method to avoid numerical issues (:issue:`37051`)\n- :meth:`DataFrame.corr` and :meth:`DataFrame.cov` use Welford's Method to avoid numerical issues (:issue:`37448`)\n- :meth:`DataFrame.plot` now recognizes ``xlabel`` and ``ylabel`` arguments for plots of type ``scatter`` and ``hexbin`` (:issue:`37001`)\n- :class:`DataFrame` now supports the ``divmod`` operation (:issue:`37165`)\n- :meth:`DataFrame.to_parquet` now returns a ``bytes`` object when no ``path`` argument is passed (:issue:`37105`)\n- :class:`.Rolling` now supports the ``closed`` argument for fixed windows (:issue:`34315`)\n- :class:`.DatetimeIndex` and :class:`Series` with ``datetime64`` or ``datetime64tz`` dtypes now support ``std`` (:issue:`37436`)\n- :class:`Window` now supports all Scipy window types in ``win_type`` with flexible keyword argument support (:issue:`34556`)\n- :meth:`testing.assert_index_equal` now has a ``check_order`` parameter that allows indexes to be checked in an order-insensitive manner (:issue:`37478`)\n- :func:`read_csv` supports memory-mapping for compressed files (:issue:`37621`)\n- Add support for ``min_count`` keyword for :meth:`DataFrame.groupby` and :meth:`DataFrame.resample` for functions ``min``, ``max``, ``first`` and ``last`` (:issue:`37821`, :issue:`37768`)\n- Improve error reporting for :meth:`DataFrame.merge` when invalid merge column definitions were given (:issue:`16228`)\n- Improve numerical stability for :meth:`.Rolling.skew`, :meth:`.Rolling.kurt`, :meth:`Expanding.skew` and :meth:`Expanding.kurt` through implementation of Kahan summation (:issue:`6929`)\n- Improved error reporting for subsetting columns of a :class:`.DataFrameGroupBy` with ``axis=1`` (:issue:`37725`)\n- Implement method ``cross`` for :meth:`DataFrame.merge` and :meth:`DataFrame.join` (:issue:`5401`)\n- When :func:`read_csv`, :func:`read_sas` and :func:`read_json` are called with ``chunksize``/``iterator`` they can be used in a ``with`` statement as they return context-managers (:issue:`38225`)\n- Augmented the list of named colors available for styling Excel exports, enabling all of CSS4 colors (:issue:`38247`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_120.notable_bug_fixes:\n\nNotable bug fixes\n~~~~~~~~~~~~~~~~~\n\nThese are bug fixes that might have notable behavior changes.\n\nConsistency of DataFrame Reductions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n:meth:`DataFrame.any` and :meth:`DataFrame.all` with ``bool_only=True`` now\ndetermines whether to exclude object-dtype columns on a column-by-column basis,\ninstead of checking if *all* object-dtype columns can be considered boolean.\n\nThis prevents pathological behavior where applying the reduction on a subset\nof columns could result in a larger Series result. See (:issue:`37799`).\n\n.. ipython:: python\n\n    df = pd.DataFrame({\"A\": [\"foo\", \"bar\"], \"B\": [True, False]}, dtype=object)\n    df[\"C\"] = pd.Series([True, True])\n\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [5]: df.all(bool_only=True)\n    Out[5]:\n    C    True\n    dtype: bool\n\n    In [6]: df[[\"B\", \"C\"]].all(bool_only=True)\n    Out[6]:\n    B    False\n    C    True\n    dtype: bool\n\n*New behavior*:\n\n.. ipython:: python\n   :okwarning:\n\n    In [5]: df.all(bool_only=True)\n\n    In [6]: df[[\"B\", \"C\"]].all(bool_only=True)\n\n\nOther DataFrame reductions with ``numeric_only=None`` will also avoid\nthis pathological behavior (:issue:`37827`):\n\n.. ipython:: python\n\n    df = pd.DataFrame({\"A\": [0, 1, 2], \"B\": [\"a\", \"b\", \"c\"]}, dtype=object)\n\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [3]: df.mean()\n    Out[3]: Series([], dtype: float64)\n\n    In [4]: df[[\"A\"]].mean()\n    Out[4]:\n    A    1.0\n    dtype: float64\n\n*New behavior*:\n\n.. code-block:: ipython\n\n    In [3]: df.mean()\n    Out[3]:\n    A    1.0\n    dtype: float64\n\n    In [4]: df[[\"A\"]].mean()\n    Out[4]:\n    A    1.0\n    dtype: float64\n\nMoreover, DataFrame reductions with ``numeric_only=None`` will now be\nconsistent with their Series counterparts.  In particular, for\nreductions where the Series method raises ``TypeError``, the\nDataFrame reduction will now consider that column non-numeric\ninstead of casting to a NumPy array which may have different semantics (:issue:`36076`,\n:issue:`28949`, :issue:`21020`).\n\n.. ipython:: python\n   :okwarning:\n\n    ser = pd.Series([0, 1], dtype=\"category\", name=\"A\")\n    df = ser.to_frame()\n\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [5]: df.any()\n    Out[5]:\n    A    True\n    dtype: bool\n\n*New behavior*:\n\n.. code-block:: ipython\n\n    In [5]: df.any()\n    Out[5]: Series([], dtype: bool)\n\n\n.. _whatsnew_120.api_breaking.python:\n\nIncreased minimum version for Python\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\npandas 1.2.0 supports Python 3.7.1 and higher (:issue:`35214`).\n\n.. _whatsnew_120.api_breaking.deps:\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSome minimum supported versions of dependencies were updated (:issue:`35214`).\nIf installed, we now require:\n\n+-----------------+-----------------+----------+---------+\n| Package         | Minimum Version | Required | Changed |\n+=================+=================+==========+=========+\n| numpy           | 1.16.5          |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| pytz            | 2017.3          |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| python-dateutil | 2.7.3           |    X     |         |\n+-----------------+-----------------+----------+---------+\n| bottleneck      | 1.2.1           |          |         |\n+-----------------+-----------------+----------+---------+\n| numexpr         | 2.6.8           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| pytest (dev)    | 5.0.1           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| mypy (dev)      | 0.782           |          |    X    |\n+-----------------+-----------------+----------+---------+\n\nFor `optional libraries <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\nThe following table lists the lowest version per library that is currently being tested throughout the development of pandas.\nOptional libraries below the lowest tested version may still work, but are not considered supported.\n\n+-----------------+-----------------+---------+\n| Package         | Minimum Version | Changed |\n+=================+=================+=========+\n| beautifulsoup4  | 4.6.0           |         |\n+-----------------+-----------------+---------+\n| fastparquet     | 0.3.2           |         |\n+-----------------+-----------------+---------+\n| fsspec          | 0.7.4           |         |\n+-----------------+-----------------+---------+\n| gcsfs           | 0.6.0           |         |\n+-----------------+-----------------+---------+\n| lxml            | 4.3.0           |    X    |\n+-----------------+-----------------+---------+\n| matplotlib      | 2.2.3           |    X    |\n+-----------------+-----------------+---------+\n| numba           | 0.46.0          |         |\n+-----------------+-----------------+---------+\n| openpyxl        | 2.6.0           |    X    |\n+-----------------+-----------------+---------+\n| pyarrow         | 0.15.0          |    X    |\n+-----------------+-----------------+---------+\n| pymysql         | 0.7.11          |    X    |\n+-----------------+-----------------+---------+\n| pytables        | 3.5.1           |    X    |\n+-----------------+-----------------+---------+\n| s3fs            | 0.4.0           |         |\n+-----------------+-----------------+---------+\n| scipy           | 1.2.0           |         |\n+-----------------+-----------------+---------+\n| sqlalchemy      | 1.2.8           |    X    |\n+-----------------+-----------------+---------+\n| xarray          | 0.12.3          |    X    |\n+-----------------+-----------------+---------+\n| xlrd            | 1.2.0           |    X    |\n+-----------------+-----------------+---------+\n| xlsxwriter      | 1.0.2           |    X    |\n+-----------------+-----------------+---------+\n| xlwt            | 1.3.0           |    X    |\n+-----------------+-----------------+---------+\n| pandas-gbq      | 0.12.0          |         |\n+-----------------+-----------------+---------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\n.. _whatsnew_120.api.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n\n- Sorting in descending order is now stable for :meth:`Series.sort_values` and :meth:`Index.sort_values` for Datetime-like :class:`Index` subclasses. This will affect sort order when sorting a DataFrame on multiple columns, sorting with a key function that produces duplicates, or requesting the sorting index when using :meth:`Index.sort_values`. When using :meth:`Series.value_counts`, the count of missing values is no longer necessarily last in the list of duplicate counts. Instead, its position corresponds to the position in the original Series. When using :meth:`Index.sort_values` for Datetime-like :class:`Index` subclasses, NaTs ignored the ``na_position`` argument and were sorted to the beginning. Now they respect ``na_position``, the default being ``last``, same as other :class:`Index` subclasses (:issue:`35992`)\n- Passing an invalid ``fill_value`` to :meth:`Categorical.take`, :meth:`.DatetimeArray.take`, :meth:`TimedeltaArray.take`, or :meth:`PeriodArray.take` now raises a ``TypeError`` instead of a ``ValueError`` (:issue:`37733`)\n- Passing an invalid ``fill_value`` to :meth:`Series.shift` with a ``CategoricalDtype`` now raises a ``TypeError`` instead of a ``ValueError`` (:issue:`37733`)\n- Passing an invalid value to :meth:`IntervalIndex.insert` or :meth:`CategoricalIndex.insert` now raises a ``TypeError`` instead of a ``ValueError`` (:issue:`37733`)\n- Attempting to reindex a Series with a :class:`CategoricalIndex` with an invalid ``fill_value`` now raises a ``TypeError`` instead of a ``ValueError`` (:issue:`37733`)\n- :meth:`CategoricalIndex.append` with an index that contains non-category values will now cast instead of raising ``TypeError`` (:issue:`38098`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_120.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n- Deprecated parameter ``inplace`` in :meth:`MultiIndex.set_codes` and :meth:`MultiIndex.set_levels` (:issue:`35626`)\n- Deprecated parameter ``dtype`` of method :meth:`~Index.copy` for all :class:`Index` subclasses. Use the :meth:`~Index.astype` method instead for changing dtype (:issue:`35853`)\n- Deprecated parameters ``levels`` and ``codes`` in :meth:`MultiIndex.copy`. Use the :meth:`~MultiIndex.set_levels` and :meth:`~MultiIndex.set_codes` methods instead (:issue:`36685`)\n- Date parser functions :func:`~pandas.io.date_converters.parse_date_time`, :func:`~pandas.io.date_converters.parse_date_fields`, :func:`~pandas.io.date_converters.parse_all_fields` and :func:`~pandas.io.date_converters.generic_parser` from ``pandas.io.date_converters`` are deprecated and will be removed in a future version; use :func:`to_datetime` instead (:issue:`35741`)\n- :meth:`DataFrame.lookup` is deprecated and will be removed in a future version, use :meth:`DataFrame.melt` and :meth:`DataFrame.loc` instead (:issue:`35224`)\n- The method :meth:`Index.to_native_types` is deprecated. Use ``.astype(str)`` instead (:issue:`28867`)\n- Deprecated indexing :class:`DataFrame` rows with a single datetime-like string as ``df[string]`` (given the ambiguity whether it is indexing the rows or selecting a column), use ``df.loc[string]`` instead (:issue:`36179`)\n- Deprecated :meth:`Index.is_all_dates` (:issue:`27744`)\n- The default value of ``regex`` for :meth:`Series.str.replace` will change from ``True`` to ``False`` in a future release. In addition, single character regular expressions will *not* be treated as literal strings when ``regex=True`` is set (:issue:`24804`)\n- Deprecated automatic alignment on comparison operations between :class:`DataFrame` and :class:`Series`, do ``frame, ser = frame.align(ser, axis=1, copy=False)`` before e.g. ``frame == ser`` (:issue:`28759`)\n- :meth:`Rolling.count` with ``min_periods=None`` will default to the size of the window in a future version (:issue:`31302`)\n- Using \"outer\" ufuncs on DataFrames to return 4d ndarray is now deprecated. Convert to an ndarray first (:issue:`23743`)\n- Deprecated slice-indexing on tz-aware :class:`DatetimeIndex` with naive ``datetime`` objects, to match scalar indexing behavior (:issue:`36148`)\n- :meth:`Index.ravel` returning a ``np.ndarray`` is deprecated, in the future this will return a view on the same index (:issue:`19956`)\n- Deprecate use of strings denoting units with 'M', 'Y' or 'y' in :func:`~pandas.to_timedelta` (:issue:`36666`)\n- :class:`Index` methods ``&``, ``|``, and ``^`` behaving as the set operations :meth:`Index.intersection`, :meth:`Index.union`, and :meth:`Index.symmetric_difference`, respectively, are deprecated and in the future will behave as pointwise boolean operations matching :class:`Series` behavior.  Use the named set methods instead (:issue:`36758`)\n- :meth:`Categorical.is_dtype_equal` and :meth:`CategoricalIndex.is_dtype_equal` are deprecated, will be removed in a future version (:issue:`37545`)\n- :meth:`Series.slice_shift` and :meth:`DataFrame.slice_shift` are deprecated, use :meth:`Series.shift` or :meth:`DataFrame.shift` instead (:issue:`37601`)\n- Partial slicing on unordered :class:`.DatetimeIndex` objects with keys that are not in the index is deprecated and will be removed in a future version (:issue:`18531`)\n- The ``how`` keyword in :meth:`PeriodIndex.astype` is deprecated and will be removed in a future version, use ``index.to_timestamp(how=how)`` instead (:issue:`37982`)\n- Deprecated :meth:`Index.asi8` for :class:`Index` subclasses other than :class:`.DatetimeIndex`, :class:`.TimedeltaIndex`, and :class:`PeriodIndex` (:issue:`37877`)\n- The ``inplace`` parameter of :meth:`Categorical.remove_unused_categories` is deprecated and will be removed in a future version (:issue:`37643`)\n- The ``null_counts`` parameter of :meth:`DataFrame.info` is deprecated and replaced by ``show_counts``. It will be removed in a future version (:issue:`37999`)\n\n**Calling NumPy ufuncs on non-aligned DataFrames**\n\nCalling NumPy ufuncs on non-aligned DataFrames changed behaviour in pandas\n1.2.0 (to align the inputs before calling the ufunc), but this change is\nreverted in pandas 1.2.1. The behaviour to not align is now deprecated instead,\nsee the :ref:`the 1.2.1 release notes <whatsnew_121.ufunc_deprecation>` for\nmore details.\n\n.. ---------------------------------------------------------------------------\n\n\n.. _whatsnew_120.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n- Performance improvements when creating DataFrame or Series with dtype ``str`` or :class:`StringDtype` from array with many string elements (:issue:`36304`, :issue:`36317`, :issue:`36325`, :issue:`36432`, :issue:`37371`)\n- Performance improvement in :meth:`.DataFrameGroupBy.agg` and :meth:`.SeriesGroupBy.agg` with the ``numba`` engine (:issue:`35759`)\n- Performance improvements when creating :meth:`Series.map` from a huge dictionary (:issue:`34717`)\n- Performance improvement in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` with the ``numba`` engine (:issue:`36240`)\n- :class:`.Styler` uuid method altered to compress data transmission over web whilst maintaining reasonably low table collision probability (:issue:`36345`)\n- Performance improvement in :func:`to_datetime` with non-ns time unit for ``float`` ``dtype`` columns (:issue:`20445`)\n- Performance improvement in setting values on an :class:`IntervalArray` (:issue:`36310`)\n- The internal index method :meth:`~Index._shallow_copy` now makes the new index and original index share cached attributes, avoiding creating these again, if created on either. This can speed up operations that depend on creating copies of existing indexes (:issue:`36840`)\n- Performance improvement in :meth:`.RollingGroupby.count` (:issue:`35625`)\n- Small performance decrease to :meth:`.Rolling.min` and :meth:`.Rolling.max` for fixed windows (:issue:`36567`)\n- Reduced peak memory usage in :meth:`DataFrame.to_pickle` when using ``protocol=5`` in python 3.8+ (:issue:`34244`)\n- Faster ``dir`` calls when the object has many index labels, e.g. ``dir(ser)`` (:issue:`37450`)\n- Performance improvement in :class:`ExpandingGroupby` (:issue:`37064`)\n- Performance improvement in :meth:`Series.astype` and :meth:`DataFrame.astype` for :class:`Categorical` (:issue:`8628`)\n- Performance improvement in :meth:`DataFrame.groupby` for ``float`` ``dtype`` (:issue:`28303`), changes of the underlying hash-function can lead to changes in float based indexes sort ordering for ties (e.g. :meth:`Index.value_counts`)\n- Performance improvement in :meth:`pd.isin` for inputs with more than 1e6 elements (:issue:`36611`)\n- Performance improvement for :meth:`DataFrame.__setitem__` with list-like indexers (:issue:`37954`)\n- :meth:`read_json` now avoids reading entire file into memory when chunksize is specified (:issue:`34548`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_120.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n- :meth:`Categorical.fillna` will always return a copy, validate a passed fill value regardless of whether there are any NAs to fill, and disallow an ``NaT`` as a fill value for numeric categories (:issue:`36530`)\n- Bug in :meth:`Categorical.__setitem__` that incorrectly raised when trying to set a tuple value (:issue:`20439`)\n- Bug in :meth:`CategoricalIndex.equals` incorrectly casting non-category entries to ``np.nan`` (:issue:`37667`)\n- Bug in :meth:`CategoricalIndex.where` incorrectly setting non-category entries to ``np.nan`` instead of raising ``TypeError`` (:issue:`37977`)\n- Bug in :meth:`Categorical.to_numpy` and ``np.array(categorical)`` with tz-aware ``datetime64`` categories incorrectly dropping the time zone information instead of casting to object dtype (:issue:`38136`)\n\nDatetime-like\n^^^^^^^^^^^^^\n- Bug in :meth:`DataFrame.combine_first` that would convert datetime-like column on other :class:`DataFrame` to integer when the column is not present in original :class:`DataFrame` (:issue:`28481`)\n- Bug in :attr:`.DatetimeArray.date` where a ``ValueError`` would be raised with a read-only backing array (:issue:`33530`)\n- Bug in ``NaT`` comparisons failing to raise ``TypeError`` on invalid inequality comparisons (:issue:`35046`)\n- Bug in :class:`.DateOffset` where attributes reconstructed from pickle files differ from original objects when input values exceed normal ranges (e.g. months=12) (:issue:`34511`)\n- Bug in :meth:`.DatetimeIndex.get_slice_bound` where ``datetime.date`` objects were not accepted or naive :class:`Timestamp` with a tz-aware :class:`.DatetimeIndex` (:issue:`35690`)\n- Bug in :meth:`.DatetimeIndex.slice_locs` where ``datetime.date`` objects were not accepted (:issue:`34077`)\n- Bug in :meth:`.DatetimeIndex.searchsorted`, :meth:`.TimedeltaIndex.searchsorted`, :meth:`PeriodIndex.searchsorted`, and :meth:`Series.searchsorted` with ``datetime64``, ``timedelta64`` or :class:`Period` dtype placement of ``NaT`` values being inconsistent with NumPy (:issue:`36176`, :issue:`36254`)\n- Inconsistency in :class:`.DatetimeArray`, :class:`.TimedeltaArray`, and :class:`.PeriodArray` method ``__setitem__`` casting arrays of strings to datetime-like scalars but not scalar strings (:issue:`36261`)\n- Bug in :meth:`.DatetimeArray.take` incorrectly allowing ``fill_value`` with a mismatched time zone (:issue:`37356`)\n- Bug in :class:`.DatetimeIndex.shift` incorrectly raising when shifting empty indexes (:issue:`14811`)\n- :class:`Timestamp` and :class:`.DatetimeIndex` comparisons between tz-aware and tz-naive objects now follow the standard library ``datetime`` behavior, returning ``True``/``False`` for ``!=``/``==`` and raising for inequality comparisons (:issue:`28507`)\n- Bug in :meth:`.DatetimeIndex.equals` and :meth:`.TimedeltaIndex.equals` incorrectly considering ``int64`` indexes as equal (:issue:`36744`)\n- :meth:`Series.to_json`, :meth:`DataFrame.to_json`, and :meth:`read_json` now implement time zone parsing when orient structure is ``table`` (:issue:`35973`)\n- :meth:`astype` now attempts to convert to ``datetime64[ns, tz]`` directly from ``object`` with inferred time zone from string (:issue:`35973`)\n- Bug in :meth:`.TimedeltaIndex.sum` and :meth:`Series.sum` with ``timedelta64`` dtype on an empty index or series returning ``NaT`` instead of ``Timedelta(0)`` (:issue:`31751`)\n- Bug in :meth:`.DatetimeArray.shift` incorrectly allowing ``fill_value`` with a mismatched time zone (:issue:`37299`)\n- Bug in adding a :class:`.BusinessDay` with nonzero ``offset`` to a non-scalar other (:issue:`37457`)\n- Bug in :func:`to_datetime` with a read-only array incorrectly raising (:issue:`34857`)\n- Bug in :meth:`Series.isin` with ``datetime64[ns]`` dtype and :meth:`.DatetimeIndex.isin` incorrectly casting integers to datetimes (:issue:`36621`)\n- Bug in :meth:`Series.isin` with ``datetime64[ns]`` dtype and :meth:`.DatetimeIndex.isin` failing to consider tz-aware and tz-naive datetimes as always different (:issue:`35728`)\n- Bug in :meth:`Series.isin` with ``PeriodDtype`` dtype and :meth:`PeriodIndex.isin` failing to consider arguments with different ``PeriodDtype`` as always different (:issue:`37528`)\n- Bug in :class:`Period` constructor now correctly handles nanoseconds in the ``value`` argument (:issue:`34621` and :issue:`17053`)\n\nTimedelta\n^^^^^^^^^\n- Bug in :class:`.TimedeltaIndex`, :class:`Series`, and :class:`DataFrame` floor-division with ``timedelta64`` dtypes and ``NaT`` in the denominator (:issue:`35529`)\n- Bug in parsing of ISO 8601 durations in :class:`Timedelta` and :func:`to_datetime` (:issue:`29773`, :issue:`36204`)\n- Bug in :func:`to_timedelta` with a read-only array incorrectly raising (:issue:`34857`)\n- Bug in :class:`Timedelta` incorrectly truncating to sub-second portion of a string input when it has precision higher than nanoseconds (:issue:`36738`)\n\nTimezones\n^^^^^^^^^\n\n- Bug in :func:`date_range` was raising ``AmbiguousTimeError`` for valid input with ``ambiguous=False`` (:issue:`35297`)\n- Bug in :meth:`Timestamp.replace` was losing fold information (:issue:`37610`)\n\n\nNumeric\n^^^^^^^\n- Bug in :func:`to_numeric` where float precision was incorrect (:issue:`31364`)\n- Bug in :meth:`DataFrame.any` with ``axis=1`` and ``bool_only=True`` ignoring the ``bool_only`` keyword (:issue:`32432`)\n- Bug in :meth:`Series.equals` where a ``ValueError`` was raised when NumPy arrays were compared to scalars (:issue:`35267`)\n- Bug in :class:`Series` where two Series each have a :class:`.DatetimeIndex` with different time zones having those indexes incorrectly changed when performing arithmetic operations (:issue:`33671`)\n- Bug in :mod:`pandas.testing` module functions when used with ``check_exact=False`` on complex numeric types (:issue:`28235`)\n- Bug in :meth:`DataFrame.__rmatmul__` error handling reporting transposed shapes (:issue:`21581`)\n- Bug in :class:`Series` flex arithmetic methods where the result when operating with a ``list``, ``tuple`` or ``np.ndarray`` would have an incorrect name (:issue:`36760`)\n- Bug in :class:`.IntegerArray` multiplication with ``timedelta`` and ``np.timedelta64`` objects (:issue:`36870`)\n- Bug in :class:`MultiIndex` comparison with tuple incorrectly treating tuple as array-like (:issue:`21517`)\n- Bug in :meth:`DataFrame.diff` with ``datetime64`` dtypes including ``NaT`` values failing to fill ``NaT`` results correctly (:issue:`32441`)\n- Bug in :class:`DataFrame` arithmetic ops incorrectly accepting keyword arguments (:issue:`36843`)\n- Bug in :class:`.IntervalArray` comparisons with :class:`Series` not returning Series (:issue:`36908`)\n- Bug in :class:`DataFrame` allowing arithmetic operations with list of array-likes with undefined results. Behavior changed to raising ``ValueError`` (:issue:`36702`)\n- Bug in :meth:`DataFrame.std` with ``timedelta64`` dtype and ``skipna=False`` (:issue:`37392`)\n- Bug in :meth:`DataFrame.min` and :meth:`DataFrame.max` with ``datetime64`` dtype and ``skipna=False`` (:issue:`36907`)\n- Bug in :meth:`DataFrame.idxmax` and :meth:`DataFrame.idxmin` with mixed dtypes incorrectly raising ``TypeError`` (:issue:`38195`)\n\nConversion\n^^^^^^^^^^\n\n- Bug in :meth:`DataFrame.to_dict` with ``orient='records'`` now returns python native datetime objects for datetime-like columns (:issue:`21256`)\n- Bug in :meth:`Series.astype` conversion from ``string`` to ``float`` raised in presence of ``pd.NA`` values (:issue:`37626`)\n\nStrings\n^^^^^^^\n- Bug in :meth:`Series.to_string`, :meth:`DataFrame.to_string`, and :meth:`DataFrame.to_latex` adding a leading space when ``index=False`` (:issue:`24980`)\n- Bug in :func:`to_numeric` raising a ``TypeError`` when attempting to convert a string dtype Series containing only numeric strings and ``NA`` (:issue:`37262`)\n\nInterval\n^^^^^^^^\n\n- Bug in :meth:`DataFrame.replace` and :meth:`Series.replace` where :class:`Interval` dtypes would be converted to object dtypes (:issue:`34871`)\n- Bug in :meth:`IntervalIndex.take` with negative indices and ``fill_value=None`` (:issue:`37330`)\n- Bug in :meth:`IntervalIndex.putmask` with datetime-like dtype incorrectly casting to object dtype (:issue:`37968`)\n- Bug in :meth:`IntervalArray.astype` incorrectly dropping dtype information with a :class:`CategoricalDtype` object (:issue:`37984`)\n\nIndexing\n^^^^^^^^\n\n- Bug in :meth:`PeriodIndex.get_loc` incorrectly raising ``ValueError`` on non-datelike strings instead of ``KeyError``, causing similar errors in :meth:`Series.__getitem__`, :meth:`Series.__contains__`, and :meth:`Series.loc.__getitem__` (:issue:`34240`)\n- Bug in :meth:`Index.sort_values` where, when empty values were passed, the method would break by trying to compare missing values instead of pushing them to the end of the sort order (:issue:`35584`)\n- Bug in :meth:`Index.get_indexer` and :meth:`Index.get_indexer_non_unique` where ``int64`` arrays are returned instead of ``intp`` (:issue:`36359`)\n- Bug in :meth:`DataFrame.sort_index` where parameter ascending passed as a list on a single level index gives wrong result (:issue:`32334`)\n- Bug in :meth:`DataFrame.reset_index` was incorrectly raising a ``ValueError`` for input with a :class:`MultiIndex` with missing values in a level with ``Categorical`` dtype (:issue:`24206`)\n- Bug in indexing with boolean masks on datetime-like values sometimes returning a view instead of a copy (:issue:`36210`)\n- Bug in :meth:`DataFrame.__getitem__` and :meth:`DataFrame.loc.__getitem__` with :class:`IntervalIndex` columns and a numeric indexer (:issue:`26490`)\n- Bug in :meth:`Series.loc.__getitem__` with a non-unique :class:`MultiIndex` and an empty-list indexer (:issue:`13691`)\n- Bug in indexing on a :class:`Series` or :class:`DataFrame` with a :class:`MultiIndex` and a level named ``\"0\"`` (:issue:`37194`)\n- Bug in :meth:`Series.__getitem__` when using an unsigned integer array as an indexer giving incorrect results or segfaulting instead of raising ``KeyError`` (:issue:`37218`)\n- Bug in :meth:`Index.where` incorrectly casting numeric values to strings (:issue:`37591`)\n- Bug in :meth:`DataFrame.loc` returning empty result when indexer is a slice with negative step size (:issue:`38071`)\n- Bug in :meth:`Series.loc` and :meth:`DataFrame.loc` raises when the index was of ``object`` dtype and the given numeric label was in the index (:issue:`26491`)\n- Bug in :meth:`DataFrame.loc` returned requested key plus missing values when ``loc`` was applied to single level from a :class:`MultiIndex` (:issue:`27104`)\n- Bug in indexing on a :class:`Series` or :class:`DataFrame` with a :class:`CategoricalIndex` using a list-like indexer containing NA values (:issue:`37722`)\n- Bug in :meth:`DataFrame.loc.__setitem__` expanding an empty :class:`DataFrame` with mixed dtypes (:issue:`37932`)\n- Bug in :meth:`DataFrame.xs` ignored ``droplevel=False`` for columns (:issue:`19056`)\n- Bug in :meth:`DataFrame.reindex` raising ``IndexingError`` wrongly for empty DataFrame with ``tolerance`` not ``None`` or ``method=\"nearest\"`` (:issue:`27315`)\n- Bug in indexing on a :class:`Series` or :class:`DataFrame` with a :class:`CategoricalIndex` using list-like indexer that contains elements that are in the index's ``categories`` but not in the index itself failing to raise ``KeyError`` (:issue:`37901`)\n- Bug on inserting a boolean label into a :class:`DataFrame` with a numeric :class:`Index` columns incorrectly casting to integer (:issue:`36319`)\n- Bug in :meth:`DataFrame.iloc` and :meth:`Series.iloc` aligning objects in ``__setitem__`` (:issue:`22046`)\n- Bug in :meth:`MultiIndex.drop` does not raise if labels are partially found (:issue:`37820`)\n- Bug in :meth:`DataFrame.loc` did not raise ``KeyError`` when missing combination was given with ``slice(None)`` for remaining levels (:issue:`19556`)\n- Bug in :meth:`DataFrame.loc` raising ``TypeError`` when non-integer slice was given to select values from :class:`MultiIndex` (:issue:`25165`, :issue:`24263`)\n- Bug in :meth:`Series.at` returning :class:`Series` with one element instead of scalar when index is a :class:`MultiIndex` with one level (:issue:`38053`)\n- Bug in :meth:`DataFrame.loc` returning and assigning elements in wrong order when indexer is differently ordered than the :class:`MultiIndex` to filter (:issue:`31330`, :issue:`34603`)\n- Bug in :meth:`DataFrame.loc` and :meth:`DataFrame.__getitem__`  raising ``KeyError`` when columns were :class:`MultiIndex` with only one level (:issue:`29749`)\n- Bug in :meth:`Series.__getitem__` and :meth:`DataFrame.__getitem__` raising blank ``KeyError`` without missing keys for :class:`IntervalIndex` (:issue:`27365`)\n- Bug in setting a new label on a :class:`DataFrame` or :class:`Series` with a :class:`CategoricalIndex` incorrectly raising ``TypeError`` when the new label is not among the index's categories (:issue:`38098`)\n- Bug in :meth:`Series.loc` and :meth:`Series.iloc` raising ``ValueError`` when inserting a list-like ``np.array``, ``list`` or ``tuple`` in an ``object`` Series of equal length (:issue:`37748`, :issue:`37486`)\n- Bug in :meth:`Series.loc` and :meth:`Series.iloc` setting all the values of an ``object`` Series with those of a list-like ``ExtensionArray`` instead of inserting it (:issue:`38271`)\n\nMissing\n^^^^^^^\n\n- Bug in :meth:`.SeriesGroupBy.transform` now correctly handles missing values for ``dropna=False`` (:issue:`35014`)\n- Bug in :meth:`Series.nunique` with ``dropna=True`` was returning incorrect results when both ``NA`` and ``None`` missing values were present (:issue:`37566`)\n- Bug in :meth:`Series.interpolate` where kwarg ``limit_area`` and ``limit_direction`` had no effect when using methods ``pad`` and ``backfill`` (:issue:`31048`)\n\nMultiIndex\n^^^^^^^^^^\n\n- Bug in :meth:`DataFrame.xs` when used with :class:`IndexSlice` raises ``TypeError`` with message ``\"Expected label or tuple of labels\"`` (:issue:`35301`)\n- Bug in :meth:`DataFrame.reset_index` with ``NaT`` values in index raises ``ValueError`` with message ``\"cannot convert float NaN to integer\"`` (:issue:`36541`)\n- Bug in :meth:`DataFrame.combine_first` when used with :class:`MultiIndex` containing string and ``NaN`` values raises ``TypeError`` (:issue:`36562`)\n- Bug in :meth:`MultiIndex.drop` dropped ``NaN`` values when non existing key was given as input (:issue:`18853`)\n- Bug in :meth:`MultiIndex.drop` dropping more values than expected when index has duplicates and is not sorted (:issue:`33494`)\n\nI/O\n^^^\n\n- :func:`read_sas` no longer leaks resources on failure (:issue:`35566`)\n- Bug in :meth:`DataFrame.to_csv` and :meth:`Series.to_csv` caused a ``ValueError`` when it was called with a filename in combination with ``mode`` containing a ``b`` (:issue:`35058`)\n- Bug in :meth:`read_csv` with ``float_precision='round_trip'`` did not handle ``decimal`` and ``thousands`` parameters (:issue:`35365`)\n- :meth:`to_pickle` and :meth:`read_pickle` were closing user-provided file objects (:issue:`35679`)\n- :meth:`to_csv` passes compression arguments for ``'gzip'`` always to ``gzip.GzipFile`` (:issue:`28103`)\n- :meth:`to_csv` did not support zip compression for binary file object not having a filename (:issue:`35058`)\n- :meth:`to_csv` and :meth:`read_csv` did not honor ``compression`` and ``encoding`` for path-like objects that are internally converted to file-like objects (:issue:`35677`, :issue:`26124`, :issue:`32392`)\n- :meth:`DataFrame.to_pickle`, :meth:`Series.to_pickle`, and :meth:`read_pickle` did not support compression for file-objects (:issue:`26237`, :issue:`29054`, :issue:`29570`)\n- Bug in :func:`LongTableBuilder.middle_separator` was duplicating LaTeX longtable entries in the List of Tables of a LaTeX document (:issue:`34360`)\n- Bug in :meth:`read_csv` with ``engine='python'`` truncating data if multiple items present in first row and first element started with BOM (:issue:`36343`)\n- Removed ``private_key`` and ``verbose`` from :func:`read_gbq` as they are no longer supported in ``pandas-gbq`` (:issue:`34654`, :issue:`30200`)\n- Bumped minimum pytables version to 3.5.1 to avoid a ``ValueError`` in :meth:`read_hdf` (:issue:`24839`)\n- Bug in :func:`read_table` and :func:`read_csv` when ``delim_whitespace=True`` and ``sep=default`` (:issue:`36583`)\n- Bug in :meth:`DataFrame.to_json` and :meth:`Series.to_json` when used with ``lines=True`` and ``orient='records'`` the last line of the record is not appended with 'new line character' (:issue:`36888`)\n- Bug in :meth:`read_parquet` with fixed offset time zones. String representation of time zones was not recognized (:issue:`35997`, :issue:`36004`)\n- Bug in :meth:`DataFrame.to_html`, :meth:`DataFrame.to_string`, and :meth:`DataFrame.to_latex` ignoring the ``na_rep`` argument when ``float_format`` was also specified (:issue:`9046`, :issue:`13828`)\n- Bug in output rendering of complex numbers showing too many trailing zeros (:issue:`36799`)\n- Bug in :class:`HDFStore` threw a ``TypeError`` when exporting an empty DataFrame with ``datetime64[ns, tz]`` dtypes with a fixed HDF5 store (:issue:`20594`)\n- Bug in :class:`HDFStore` was dropping time zone information when exporting a Series with ``datetime64[ns, tz]`` dtypes with a fixed HDF5 store (:issue:`20594`)\n- :func:`read_csv` was closing user-provided binary file handles when ``engine=\"c\"`` and an ``encoding`` was requested (:issue:`36980`)\n- Bug in :meth:`DataFrame.to_hdf` was not dropping missing rows with ``dropna=True`` (:issue:`35719`)\n- Bug in :func:`read_html` was raising a ``TypeError`` when supplying a ``pathlib.Path`` argument to the ``io`` parameter (:issue:`37705`)\n- :meth:`DataFrame.to_excel`, :meth:`Series.to_excel`, :meth:`DataFrame.to_markdown`, and :meth:`Series.to_markdown` now support writing to fsspec URLs such as S3 and Google Cloud Storage (:issue:`33987`)\n- Bug in :func:`read_fwf` with ``skip_blank_lines=True`` was not skipping blank lines (:issue:`37758`)\n- Parse missing values using :func:`read_json` with ``dtype=False`` to ``NaN`` instead of ``None`` (:issue:`28501`)\n- :meth:`read_fwf` was inferring compression with ``compression=None`` which was not consistent with the other ``read_*`` functions (:issue:`37909`)\n- :meth:`DataFrame.to_html` was ignoring ``formatters`` argument for ``ExtensionDtype`` columns (:issue:`36525`)\n- Bumped minimum xarray version to 0.12.3 to avoid reference to the removed ``Panel`` class (:issue:`27101`, :issue:`37983`)\n- :meth:`DataFrame.to_csv` was re-opening file-like handles that also implement ``os.PathLike`` (:issue:`38125`)\n- Bug in the conversion of a sliced ``pyarrow.Table`` with missing values to a DataFrame (:issue:`38525`)\n- Bug in :func:`read_sql_table` raising a ``sqlalchemy.exc.OperationalError`` when column names contained a percentage sign (:issue:`37517`)\n\nPeriod\n^^^^^^\n\n- Bug in :meth:`DataFrame.replace` and :meth:`Series.replace` where :class:`Period` dtypes would be converted to object dtypes (:issue:`34871`)\n\nPlotting\n^^^^^^^^\n\n- Bug in :meth:`DataFrame.plot` was rotating xticklabels when ``subplots=True``, even if the x-axis wasn't an irregular time series (:issue:`29460`)\n- Bug in :meth:`DataFrame.plot` where a marker letter in the ``style`` keyword sometimes caused a ``ValueError`` (:issue:`21003`)\n- Bug in :meth:`DataFrame.plot.bar` and :meth:`Series.plot.bar` where ticks positions were assigned by value order instead of using the actual value for numeric or a smart ordering for string (:issue:`26186`, :issue:`11465`). This fix has been reverted in pandas 1.2.1, see :doc:`v1.2.1`\n- Twinned axes were losing their tick labels which should only happen to all but the last row or column of 'externally' shared axes (:issue:`33819`)\n- Bug in :meth:`Series.plot` and :meth:`DataFrame.plot` was throwing a :exc:`ValueError` when the Series or DataFrame was\n  indexed by a :class:`.TimedeltaIndex` with a fixed frequency and the x-axis lower limit was greater than the upper limit (:issue:`37454`)\n- Bug in :meth:`.DataFrameGroupBy.boxplot` when ``subplots=False`` would raise a ``KeyError`` (:issue:`16748`)\n- Bug in :meth:`DataFrame.plot` and :meth:`Series.plot` was overwriting matplotlib's shared y axes behavior when no ``sharey`` parameter was passed (:issue:`37942`)\n- Bug in :meth:`DataFrame.plot` was raising a ``TypeError`` with ``ExtensionDtype`` columns (:issue:`32073`)\n\nStyler\n^^^^^^\n\n- Bug in :meth:`Styler.render` HTML was generated incorrectly because of formatting error in ``rowspan`` attribute, it now matches with w3 syntax (:issue:`38234`)\n\nGroupby/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n- Bug in :meth:`.DataFrameGroupBy.count` and :meth:`SeriesGroupBy.sum` returning ``NaN`` for missing categories when grouped on multiple ``Categoricals``. Now returning ``0`` (:issue:`35028`)\n- Bug in :meth:`.DataFrameGroupBy.apply` that would sometimes throw an erroneous ``ValueError`` if the grouping axis had duplicate entries (:issue:`16646`)\n- Bug in :meth:`DataFrame.resample` that would throw a ``ValueError`` when resampling from ``\"D\"`` to ``\"24H\"`` over a transition into daylight savings time (DST) (:issue:`35219`)\n- Bug when combining methods :meth:`DataFrame.groupby` with :meth:`DataFrame.resample` and :meth:`DataFrame.interpolate` raising a ``TypeError`` (:issue:`35325`)\n- Bug in :meth:`.DataFrameGroupBy.apply` where a non-nuisance grouping column would be dropped from the output columns if another groupby method was called before ``.apply`` (:issue:`34656`)\n- Bug when subsetting columns on a :class:`.DataFrameGroupBy` (e.g. ``df.groupby('a')[['b']])``) would reset the attributes ``axis``, ``dropna``, ``group_keys``, ``level``, ``mutated``, ``sort``, and ``squeeze`` to their default values (:issue:`9959`)\n- Bug in :meth:`.DataFrameGroupBy.tshift` failing to raise ``ValueError`` when a frequency cannot be inferred for the index of a group (:issue:`35937`)\n- Bug in :meth:`DataFrame.groupby` does not always maintain column index name for ``any``, ``all``, ``bfill``, ``ffill``, ``shift`` (:issue:`29764`)\n- Bug in :meth:`.DataFrameGroupBy.apply` raising error with ``np.nan`` group(s) when ``dropna=False`` (:issue:`35889`)\n- Bug in :meth:`.Rolling.sum` returned wrong values when dtypes where mixed between float and integer and ``axis=1`` (:issue:`20649`, :issue:`35596`)\n- Bug in :meth:`.Rolling.count` returned ``np.nan`` with :class:`~pandas.api.indexers.FixedForwardWindowIndexer` as window, ``min_periods=0`` and only missing values in the window (:issue:`35579`)\n- Bug where :class:`.Rolling` produces incorrect window sizes when using a ``PeriodIndex`` (:issue:`34225`)\n- Bug in :meth:`.DataFrameGroupBy.ffill` and :meth:`.DataFrameGroupBy.bfill` where a ``NaN`` group would return filled values instead of ``NaN`` when ``dropna=True`` (:issue:`34725`)\n- Bug in :meth:`.RollingGroupby.count` where a ``ValueError`` was raised when specifying the ``closed`` parameter (:issue:`35869`)\n- Bug in :meth:`.DataFrameGroupBy.rolling` returning wrong values with partial centered window (:issue:`36040`)\n- Bug in :meth:`.DataFrameGroupBy.rolling` returned wrong values with time aware window containing ``NaN``. Raises ``ValueError`` because windows are not monotonic now (:issue:`34617`)\n- Bug in :meth:`.Rolling.__iter__` where a ``ValueError`` was not raised when ``min_periods`` was larger than ``window`` (:issue:`37156`)\n- Using :meth:`.Rolling.var` instead of :meth:`.Rolling.std` avoids numerical issues for :meth:`.Rolling.corr` when :meth:`.Rolling.var` is still within floating point precision while :meth:`.Rolling.std` is not (:issue:`31286`)\n- Bug in :meth:`.DataFrameGroupBy.quantile` and :meth:`.Resampler.quantile` raised ``TypeError`` when values were of type ``Timedelta`` (:issue:`29485`)\n- Bug in :meth:`.Rolling.median` and :meth:`.Rolling.quantile` returned wrong values for :class:`.BaseIndexer` subclasses with non-monotonic starting or ending points for windows (:issue:`37153`)\n- Bug in :meth:`DataFrame.groupby` dropped ``nan`` groups from result with ``dropna=False`` when grouping over a single column (:issue:`35646`, :issue:`35542`)\n- Bug in :meth:`.DataFrameGroupBy.head`, :meth:`DataFrameGroupBy.tail`, :meth:`SeriesGroupBy.head`, and :meth:`SeriesGroupBy.tail` would raise when used with ``axis=1`` (:issue:`9772`)\n- Bug in :meth:`.DataFrameGroupBy.transform` would raise when used with ``axis=1`` and a transformation kernel (e.g. \"shift\") (:issue:`36308`)\n- Bug in :meth:`.DataFrameGroupBy.resample` using ``.agg`` with sum produced different result than just calling ``.sum`` (:issue:`33548`)\n- Bug in :meth:`.DataFrameGroupBy.apply` dropped values on ``nan`` group when returning the same axes with the original frame (:issue:`38227`)\n- Bug in :meth:`.DataFrameGroupBy.quantile` couldn't handle with arraylike ``q`` when grouping by columns (:issue:`33795`)\n- Bug in :meth:`DataFrameGroupBy.rank` with ``datetime64tz`` or period dtype incorrectly casting results to those dtypes instead of returning ``float64`` dtype (:issue:`38187`)\n\nReshaping\n^^^^^^^^^\n\n- Bug in :meth:`DataFrame.crosstab` was returning incorrect results on inputs with duplicate row names, duplicate column names or duplicate names between row and column labels (:issue:`22529`)\n- Bug in :meth:`DataFrame.pivot_table` with ``aggfunc='count'`` or ``aggfunc='sum'`` returning ``NaN`` for missing categories when pivoted on a ``Categorical``. Now returning ``0`` (:issue:`31422`)\n- Bug in :func:`concat` and :class:`DataFrame` constructor where input index names are not preserved in some cases (:issue:`13475`)\n- Bug in func :meth:`crosstab` when using multiple columns with ``margins=True`` and ``normalize=True`` (:issue:`35144`)\n- Bug in :meth:`DataFrame.stack` where an empty DataFrame.stack would raise an error (:issue:`36113`). Now returning an empty Series with empty MultiIndex.\n- Bug in :meth:`Series.unstack`. Now a Series with single level of Index trying to unstack would raise a ``ValueError`` (:issue:`36113`)\n- Bug in :meth:`DataFrame.agg` with ``func={'name':<FUNC>}`` incorrectly raising ``TypeError`` when ``DataFrame.columns==['Name']`` (:issue:`36212`)\n- Bug in :meth:`Series.transform` would give incorrect results or raise when the argument ``func`` was a dictionary (:issue:`35811`)\n- Bug in :meth:`DataFrame.pivot` did not preserve :class:`MultiIndex` level names for columns when rows and columns are both multiindexed (:issue:`36360`)\n- Bug in :meth:`DataFrame.pivot` modified ``index`` argument when ``columns`` was passed but ``values`` was not (:issue:`37635`)\n- Bug in :meth:`DataFrame.join` returned a non deterministic level-order for the resulting :class:`MultiIndex` (:issue:`36910`)\n- Bug in :meth:`DataFrame.combine_first` caused wrong alignment with dtype ``string`` and one level of ``MultiIndex`` containing only ``NA`` (:issue:`37591`)\n- Fixed regression in :func:`merge` on merging :class:`.DatetimeIndex` with empty DataFrame (:issue:`36895`)\n- Bug in :meth:`DataFrame.apply` not setting index of return value when ``func`` return type is ``dict`` (:issue:`37544`)\n- Bug in :meth:`DataFrame.merge` and :meth:`pandas.merge` returning inconsistent ordering in result for ``how=right`` and ``how=left`` (:issue:`35382`)\n- Bug in :func:`merge_ordered` couldn't handle list-like ``left_by`` or ``right_by`` (:issue:`35269`)\n- Bug in :func:`merge_ordered` returned wrong join result when length of ``left_by`` or ``right_by`` equals to the rows of ``left`` or ``right`` (:issue:`38166`)\n- Bug in :func:`merge_ordered` didn't raise when elements in ``left_by`` or ``right_by`` not exist in ``left`` columns or ``right`` columns (:issue:`38167`)\n- Bug in :func:`DataFrame.drop_duplicates` not validating bool dtype for ``ignore_index`` keyword (:issue:`38274`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n\n- Fixed bug where :class:`DataFrame` column set to scalar extension type via a dict instantiation was considered an object type rather than the extension type (:issue:`35965`)\n- Fixed bug where ``astype()`` with equal dtype and ``copy=False`` would return a new object (:issue:`28488`)\n- Fixed bug when applying a NumPy ufunc with multiple outputs to an :class:`.IntegerArray` returning ``None`` (:issue:`36913`)\n- Fixed an inconsistency in :class:`.PeriodArray`'s ``__init__`` signature to those of :class:`.DatetimeArray` and :class:`.TimedeltaArray` (:issue:`37289`)\n- Reductions for :class:`.BooleanArray`, :class:`.Categorical`, :class:`.DatetimeArray`, :class:`.FloatingArray`, :class:`.IntegerArray`, :class:`.PeriodArray`, :class:`.TimedeltaArray`, and :class:`.PandasArray` are now keyword-only methods (:issue:`37541`)\n- Fixed a bug where a  ``TypeError`` was wrongly raised if a membership check was made on an ``ExtensionArray`` containing nan-like values (:issue:`37867`)\n\nOther\n^^^^^\n\n- Bug in :meth:`DataFrame.replace` and :meth:`Series.replace` incorrectly raising an ``AssertionError`` instead of a ``ValueError`` when invalid parameter combinations are passed (:issue:`36045`)\n- Bug in :meth:`DataFrame.replace` and :meth:`Series.replace` with numeric values and string ``to_replace`` (:issue:`34789`)\n- Fixed metadata propagation in :meth:`Series.abs` and ufuncs called on Series and DataFrames (:issue:`28283`)\n- Bug in :meth:`DataFrame.replace` and :meth:`Series.replace` incorrectly casting from ``PeriodDtype`` to object dtype (:issue:`34871`)\n- Fixed bug in metadata propagation incorrectly copying DataFrame columns as metadata when the column name overlaps with the metadata name (:issue:`37037`)\n- Fixed metadata propagation in the :class:`Series.dt`, :class:`Series.str` accessors, :class:`DataFrame.duplicated`, :class:`DataFrame.stack`, :class:`DataFrame.unstack`, :class:`DataFrame.pivot`, :class:`DataFrame.append`, :class:`DataFrame.diff`, :class:`DataFrame.applymap` and :class:`DataFrame.update` methods (:issue:`28283`, :issue:`37381`)\n- Fixed metadata propagation when selecting columns with ``DataFrame.__getitem__`` (:issue:`28283`)\n- Bug in :meth:`Index.intersection` with non-:class:`Index` failing to set the correct name on the returned :class:`Index` (:issue:`38111`)\n- Bug in :meth:`RangeIndex.intersection` failing to set the correct name on the returned :class:`Index` in some corner cases (:issue:`38197`)\n- Bug in :meth:`Index.difference` failing to set the correct name on the returned :class:`Index` in some corner cases (:issue:`38268`)\n- Bug in :meth:`Index.union` behaving differently depending on whether operand is an :class:`Index` or other list-like (:issue:`36384`)\n- Bug in :meth:`Index.intersection` with non-matching numeric dtypes casting to ``object`` dtype instead of minimal common dtype (:issue:`38122`)\n- Bug in :meth:`IntervalIndex.union` returning an incorrectly-typed :class:`Index` when empty (:issue:`38282`)\n- Passing an array with 2 or more dimensions to the :class:`Series` constructor now raises the more specific ``ValueError`` rather than a bare ``Exception`` (:issue:`35744`)\n- Bug in ``dir`` where ``dir(obj)`` wouldn't show attributes defined on the instance for pandas objects (:issue:`37173`)\n- Bug in :meth:`Index.drop` raising ``InvalidIndexError`` when index has duplicates (:issue:`38051`)\n- Bug in :meth:`RangeIndex.difference` returning :class:`Int64Index` in some cases where it should return :class:`RangeIndex` (:issue:`38028`)\n- Fixed bug in :func:`assert_series_equal` when comparing a datetime-like array with an equivalent non extension dtype array (:issue:`37609`)\n- Bug in :func:`.is_bool_dtype` would raise when passed a valid string such as ``\"boolean\"`` (:issue:`38386`)\n- Fixed regression in logical operators raising ``ValueError`` when columns of :class:`DataFrame` are a :class:`CategoricalIndex` with unused categories (:issue:`38367`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_120.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.1.5..v1.2.0\n", "0.7.3": ".. _whatsnew_0703:\n\nVersion 0.7.3 (April 12, 2012)\n------------------------------\n\n{{ header }}\n\n\nThis is a minor release from 0.7.2 and fixes many minor bugs and adds a number\nof nice new features. There are also a couple of API changes to note; these\nshould not affect very many users, and we are inclined to call them \"bug fixes\"\neven though they do constitute a change in behavior. See the :ref:`full release\nnotes <release>` or issue\ntracker on GitHub for a complete list.\n\nNew features\n~~~~~~~~~~~~\n\n- New :ref:`fixed width file reader <io.fwf>`, ``read_fwf``\n- New :ref:`scatter_matrix <visualization.scatter_matrix>` function for making\n  a scatter plot matrix\n\n.. code-block:: python\n\n   from pandas.tools.plotting import scatter_matrix\n\n   scatter_matrix(df, alpha=0.2)  # noqa F821\n\n\n- Add ``stacked`` argument to Series and DataFrame's ``plot`` method for\n  :ref:`stacked bar plots <visualization.barplot>`.\n\n.. code-block:: python\n\n   df.plot(kind=\"bar\", stacked=True)  # noqa F821\n\n\n.. code-block:: python\n\n   df.plot(kind=\"barh\", stacked=True)  # noqa F821\n\n\n- Add log x and y :ref:`scaling options <visualization.basic>` to\n  ``DataFrame.plot`` and ``Series.plot``\n- Add ``kurt`` methods to Series and DataFrame for computing kurtosis\n\n\nNA boolean comparison API change\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nReverted some changes to how NA values (represented typically as ``NaN`` or\n``None``) are handled in non-numeric Series:\n\n.. code-block:: ipython\n\n   In [1]: series = pd.Series([\"Steve\", np.nan, \"Joe\"])\n\n   In [2]: series == \"Steve\"\n   Out[2]:\n   0     True\n   1    False\n   2    False\n   Length: 3, dtype: bool\n\n   In [3]: series != \"Steve\"\n   Out[3]:\n   0    False\n   1     True\n   2     True\n   Length: 3, dtype: bool\n\nIn comparisons, NA / NaN will always come through as ``False`` except with\n``!=`` which is ``True``. *Be very careful* with boolean arithmetic, especially\nnegation, in the presence of NA data. You may wish to add an explicit NA\nfilter into boolean array operations if you are worried about this:\n\n.. code-block:: ipython\n\n   In [4]: mask = series == \"Steve\"\n\n   In [5]: series[mask & series.notnull()]\n   Out[5]:\n   0    Steve\n   Length: 1, dtype: object\n\nWhile propagating NA in comparisons may seem like the right behavior to some\nusers (and you could argue on purely technical grounds that this is the right\nthing to do), the evaluation was made that propagating NA everywhere, including\nin numerical arrays, would cause a large amount of problems for users. Thus, a\n\"practicality beats purity\" approach was taken. This issue may be revisited at\nsome point in the future.\n\nOther API changes\n~~~~~~~~~~~~~~~~~\n\nWhen calling ``apply`` on a grouped Series, the return value will also be a\nSeries, to be more consistent with the ``groupby`` behavior with DataFrame:\n\n.. code-block:: ipython\n\n      In [6]: df = pd.DataFrame(\n         ...:     {\n         ...:         \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n         ...:         \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n         ...:         \"C\": np.random.randn(8),\n         ...:         \"D\": np.random.randn(8),\n         ...:     }\n         ...: )\n         ...:\n\n      In [7]: df\n      Out[7]:\n         A      B         C         D\n      0  foo    one  0.469112 -0.861849\n      1  bar    one -0.282863 -2.104569\n      2  foo    two -1.509059 -0.494929\n      3  bar  three -1.135632  1.071804\n      4  foo    two  1.212112  0.721555\n      5  bar    two -0.173215 -0.706771\n      6  foo    one  0.119209 -1.039575\n      7  foo  three -1.044236  0.271860\n\n      [8 rows x 4 columns]\n\n      In [8]: grouped = df.groupby(\"A\")[\"C\"]\n\n      In [9]: grouped.describe()\n      Out[9]:\n         count      mean       std       min       25%       50%       75%       max\n      A\n      bar    3.0 -0.530570  0.526860 -1.135632 -0.709248 -0.282863 -0.228039 -0.173215\n      foo    5.0 -0.150572  1.113308 -1.509059 -1.044236  0.119209  0.469112  1.212112\n\n      [2 rows x 8 columns]\n\n      In [10]: grouped.apply(lambda x: x.sort_values()[-2:])  # top 2 values\n      Out[10]:\n      A\n      bar  1   -0.282863\n           5   -0.173215\n      foo  0    0.469112\n           4    1.212112\n      Name: C, Length: 4, dtype: float64\n\n\n.. _whatsnew_0.7.3.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.7.2..v0.7.3\n", "0.8.0": ".. _whatsnew_080:\n\nVersion 0.8.0 (June 29, 2012)\n-----------------------------\n\n{{ header }}\n\n\nThis is a major release from 0.7.3 and includes extensive work on the time\nseries handling and processing infrastructure as well as a great deal of new\nfunctionality throughout the library. It includes over 700 commits from more\nthan 20 distinct authors. Most pandas 0.7.3 and earlier users should not\nexperience any issues upgrading, but due to the migration to the NumPy\ndatetime64 dtype, there may be a number of bugs and incompatibilities\nlurking. Lingering incompatibilities will be fixed ASAP in a 0.8.1 release if\nnecessary. See the :ref:`full release notes\n<release>` or issue tracker\non GitHub for a complete list.\n\nSupport for non-unique indexes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAll objects can now work with non-unique indexes. Data alignment / join\noperations work according to SQL join semantics (including, if application,\nindex duplication in many-to-many joins)\n\nNumPy datetime64 dtype and 1.6 dependency\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTime series data are now represented using NumPy's datetime64 dtype; thus,\npandas 0.8.0 now requires at least NumPy 1.6. It has been tested and verified\nto work with the development version (1.7+) of NumPy as well which includes\nsome significant user-facing API changes. NumPy 1.6 also has a number of bugs\nhaving to do with nanosecond resolution data, so I recommend that you steer\nclear of NumPy 1.6's datetime64 API functions (though limited as they are) and\nonly interact with this data using the interface that pandas provides.\n\nSee the end of the 0.8.0 section for a \"porting\" guide listing potential issues\nfor users migrating legacy code bases from pandas 0.7 or earlier to 0.8.0.\n\nBug fixes to the 0.7.x series for legacy NumPy < 1.6 users will be provided as\nthey arise. There will be no more further development in 0.7.x beyond bug\nfixes.\n\nTime Series changes and improvements\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. note::\n\n    With this release, legacy scikits.timeseries users should be able to port\n    their code to use pandas.\n\n.. note::\n\n    See :ref:`documentation <timeseries>` for overview of pandas timeseries API.\n\n- New datetime64 representation **speeds up join operations and data\n  alignment**, **reduces memory usage**, and improve serialization /\n  deserialization performance significantly over datetime.datetime\n- High performance and flexible **resample** method for converting from\n  high-to-low and low-to-high frequency. Supports interpolation, user-defined\n  aggregation functions, and control over how the intervals and result labeling\n  are defined. A suite of high performance Cython/C-based resampling functions\n  (including Open-High-Low-Close) have also been implemented.\n- Revamp of :ref:`frequency aliases <timeseries.offset_aliases>` and support for\n  **frequency shortcuts** like '15min', or '1h30min'\n- New :ref:`DatetimeIndex class <timeseries.datetimeindex>` supports both fixed\n  frequency and irregular time\n  series. Replaces now deprecated DateRange class\n- New ``PeriodIndex`` and ``Period`` classes for representing\n  :ref:`time spans <timeseries.periods>` and performing **calendar logic**,\n  including the ``12 fiscal quarterly frequencies <timeseries.quarterly>``.\n  This is a partial port of, and a substantial enhancement to,\n  elements of the scikits.timeseries code base. Support for conversion between\n  PeriodIndex and DatetimeIndex\n- New Timestamp data type subclasses ``datetime.datetime``, providing the same\n  interface while enabling working with nanosecond-resolution data. Also\n  provides :ref:`easy time zone conversions <timeseries.timezone>`.\n- Enhanced support for :ref:`time zones <timeseries.timezone>`. Add\n  ``tz_convert`` and ``tz_localize`` methods to TimeSeries and DataFrame. All\n  timestamps are stored as UTC; Timestamps from DatetimeIndex objects with time\n  zone set will be localized to local time. Time zone conversions are therefore\n  essentially free. User needs to know very little about pytz library now; only\n  time zone names as strings are required. Time zone-aware timestamps are\n  equal if and only if their UTC timestamps match. Operations between time\n  zone-aware time series with different time zones will result in a UTC-indexed\n  time series.\n- Time series **string indexing conveniences** / shortcuts: slice years, year\n  and month, and index values with strings\n- Enhanced time series **plotting**; adaptation of scikits.timeseries\n  matplotlib-based plotting code\n- New ``date_range``, ``bdate_range``, and ``period_range`` :ref:`factory\n  functions <timeseries.daterange>`\n- Robust **frequency inference** function ``infer_freq`` and ``inferred_freq``\n  property of DatetimeIndex, with option to infer frequency on construction of\n  DatetimeIndex\n- to_datetime function efficiently **parses array of strings** to\n  DatetimeIndex. DatetimeIndex will parse array or list of strings to\n  datetime64\n- **Optimized** support for datetime64-dtype data in Series and DataFrame\n  columns\n- New NaT (Not-a-Time) type to represent **NA** in timestamp arrays\n- Optimize Series.asof for looking up **\"as of\" values** for arrays of\n  timestamps\n- Milli, Micro, Nano date offset objects\n- Can index time series with datetime.time objects to select all data at\n  particular **time of day** (``TimeSeries.at_time``) or **between two times**\n  (``TimeSeries.between_time``)\n- Add :ref:`tshift <timeseries.advanced_datetime>` method for leading/lagging\n  using the frequency (if any) of the index, as opposed to a naive lead/lag\n  using shift\n\nOther new features\n~~~~~~~~~~~~~~~~~~\n\n- New :ref:`cut <reshaping.tile.cut>` and ``qcut`` functions (like R's cut\n  function) for computing a categorical variable from a continuous variable by\n  binning values either into value-based (``cut``) or quantile-based (``qcut``)\n  bins\n- Rename ``Factor`` to ``Categorical`` and add a number of usability features\n- Add :ref:`limit <missing_data.fillna.limit>` argument to fillna/reindex\n- More flexible multiple function application in GroupBy, and can pass list\n  (name, function) tuples to get result in particular order with given names\n- Add flexible :ref:`replace <missing_data.replace>` method for efficiently\n  substituting values\n- Enhanced :ref:`read_csv/read_table <io.parse_dates>` for reading time series\n  data and converting multiple columns to dates\n- Add :ref:`comments <io.comments>` option to parser functions: read_csv, etc.\n- Add :ref:`dayfirst <io.dayfirst>` option to parser functions for parsing\n  international DD/MM/YYYY dates\n- Allow the user to specify the CSV reader :ref:`dialect <io.dialect>` to\n  control quoting etc.\n- Handling :ref:`thousands <io.thousands>` separators in read_csv to improve\n  integer parsing.\n- Enable unstacking of multiple levels in one shot. Alleviate ``pivot_table``\n  bugs (empty columns being introduced)\n- Move to klib-based hash tables for indexing; better performance and less\n  memory usage than Python's dict\n- Add first, last, min, max, and prod optimized GroupBy functions\n- New :ref:`ordered_merge <merging.merge_ordered>` function\n- Add flexible :ref:`comparison <basics.binop>` instance methods eq, ne, lt,\n  gt, etc. to DataFrame, Series\n- Improve :ref:`scatter_matrix <visualization.scatter_matrix>` plotting\n  function and add histogram or kernel density estimates to diagonal\n- Add :ref:`'kde' <visualization.kde>` plot option for density plots\n- Support for converting DataFrame to R data.frame through rpy2\n- Improved support for complex numbers in Series and DataFrame\n- Add ``pct_change`` method to all data structures\n- Add max_colwidth configuration option for DataFrame console output\n- :ref:`Interpolate <missing_data.interpolate>` Series values using index values\n- Can select multiple columns from GroupBy\n- Add :ref:`update <merging.combine_first.update>` methods to Series/DataFrame\n  for updating values in place\n- Add ``any`` and ``all`` method to DataFrame\n\nNew plotting methods\n~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n   import pandas as pd\n\n   fx = pd.read_pickle(\"data/fx_prices\")\n   import matplotlib.pyplot as plt\n\n``Series.plot`` now supports a ``secondary_y`` option:\n\n.. code-block:: python\n\n   plt.figure()\n\n   fx[\"FR\"].plot(style=\"g\")\n\n   fx[\"IT\"].plot(style=\"k--\", secondary_y=True)\n\nVytautas Jancauskas, the 2012 GSOC participant, has added many new plot\ntypes. For example, ``'kde'`` is a new option:\n\n.. code-block:: python\n\n   s = pd.Series(\n       np.concatenate((np.random.randn(1000), np.random.randn(1000) * 0.5 + 3))\n   )\n   plt.figure()\n   s.hist(density=True, alpha=0.2)\n   s.plot(kind=\"kde\")\n\nSee :ref:`the plotting page <visualization.other>` for much more.\n\nOther API changes\n~~~~~~~~~~~~~~~~~\n\n- Deprecation of ``offset``, ``time_rule``, and ``timeRule`` arguments names in\n  time series functions. Warnings will be printed until pandas 0.9 or 1.0.\n\nPotential porting issues for pandas <= 0.7.3 users\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe major change that may affect you in pandas 0.8.0 is that time series\nindexes use NumPy's ``datetime64`` data type instead of ``dtype=object`` arrays\nof Python's built-in ``datetime.datetime`` objects. ``DateRange`` has been\nreplaced by ``DatetimeIndex`` but otherwise behaved identically. But, if you\nhave code that converts ``DateRange`` or ``Index`` objects that used to contain\n``datetime.datetime`` values to plain NumPy arrays, you may have bugs lurking\nwith code using scalar values because you are handing control over to NumPy:\n\n.. ipython:: python\n\n   import datetime\n\n   rng = pd.date_range(\"1/1/2000\", periods=10)\n   rng[5]\n   isinstance(rng[5], datetime.datetime)\n   rng_asarray = np.asarray(rng)\n   scalar_val = rng_asarray[5]\n   type(scalar_val)\n\npandas's ``Timestamp`` object is a subclass of ``datetime.datetime`` that has\nnanosecond support (the ``nanosecond`` field store the nanosecond value between\n0 and 999). It should substitute directly into any code that used\n``datetime.datetime`` values before. Thus, I recommend not casting\n``DatetimeIndex`` to regular NumPy arrays.\n\nIf you have code that requires an array of ``datetime.datetime`` objects, you\nhave a couple of options. First, the ``astype(object)`` method of ``DatetimeIndex``\nproduces an array of ``Timestamp`` objects:\n\n.. ipython:: python\n\n   stamp_array = rng.astype(object)\n   stamp_array\n   stamp_array[5]\n\nTo get an array of proper ``datetime.datetime`` objects, use the\n``to_pydatetime`` method:\n\n.. ipython:: python\n\n   dt_array = rng.to_pydatetime()\n   dt_array\n   dt_array[5]\n\nmatplotlib knows how to handle ``datetime.datetime`` but not Timestamp\nobjects. While I recommend that you plot time series using ``TimeSeries.plot``,\nyou can either use ``to_pydatetime`` or register a converter for the Timestamp\ntype. See `matplotlib documentation\n<http://matplotlib.org/api/units_api.html>`__ for more on this.\n\n.. warning::\n\n    There are bugs in the user-facing API with the nanosecond datetime64 unit\n    in NumPy 1.6. In particular, the string version of the array shows garbage\n    values, and conversion to ``dtype=object`` is similarly broken.\n\n    .. ipython:: python\n\n       rng = pd.date_range(\"1/1/2000\", periods=10)\n       rng\n       np.asarray(rng)\n       converted = np.asarray(rng, dtype=object)\n       converted[5]\n\n    **Trust me: don't panic**. If you are using NumPy 1.6 and restrict your\n    interaction with ``datetime64`` values to pandas's API you will be just\n    fine. There is nothing wrong with the data-type (a 64-bit integer\n    internally); all of the important data processing happens in pandas and is\n    heavily tested. I strongly recommend that you **do not work directly with\n    datetime64 arrays in NumPy 1.6** and only use the pandas API.\n\n\n**Support for non-unique indexes**: In the latter case, you may have code\ninside a ``try:... catch:`` block that failed due to the index not being\nunique. In many cases it will no longer fail (some method like ``append`` still\ncheck for uniqueness unless disabled). However, all is not lost: you can\ninspect ``index.is_unique`` and raise an exception explicitly if it is\n``False`` or go to a different code branch.\n\n\n.. _whatsnew_0.8.0.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.7.3..v0.8.0\n", "1.1.3": ".. _whatsnew_113:\n\nWhat's new in 1.1.3 (October 5, 2020)\n-------------------------------------\n\nThese are the changes in pandas 1.1.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\nEnhancements\n~~~~~~~~~~~~\n\nAdded support for new Python version\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\npandas 1.1.3 now supports Python 3.9 (:issue:`36296`).\n\nDevelopment Changes\n^^^^^^^^^^^^^^^^^^^\n\n- The minimum version of Cython is now the most recent bug-fix version (0.29.21) (:issue:`36296`).\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_113.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`DataFrame.agg`, :meth:`DataFrame.apply`, :meth:`Series.agg`, and :meth:`Series.apply` where internal suffix is exposed to the users when no relabelling is applied (:issue:`36189`)\n- Fixed regression in :class:`IntegerArray` unary plus and minus operations raising a ``TypeError`` (:issue:`36063`)\n- Fixed regression when adding a :meth:`timedelta_range` to a :class:`Timestamp` raised a ``ValueError`` (:issue:`35897`)\n- Fixed regression in :meth:`Series.__getitem__` incorrectly raising when the input was a tuple (:issue:`35534`)\n- Fixed regression in :meth:`Series.__getitem__` incorrectly raising when the input was a frozenset (:issue:`35747`)\n- Fixed regression in modulo of :class:`Index`, :class:`Series` and :class:`DataFrame` using ``numexpr`` using C not Python semantics (:issue:`36047`, :issue:`36526`)\n- Fixed regression in :meth:`read_excel` with ``engine=\"odf\"`` caused ``UnboundLocalError`` in some cases where cells had nested child nodes (:issue:`36122`, :issue:`35802`)\n- Fixed regression in :meth:`DataFrame.replace` inconsistent replace when using a float in the replace method (:issue:`35376`)\n- Fixed regression in :meth:`Series.loc` on a :class:`Series` with a :class:`MultiIndex` containing :class:`Timestamp` raising ``InvalidIndexError`` (:issue:`35858`)\n- Fixed regression in :class:`DataFrame` and :class:`Series` comparisons between numeric arrays and strings (:issue:`35700`, :issue:`36377`)\n- Fixed regression in :meth:`DataFrame.apply` with ``raw=True`` and user-function returning string (:issue:`35940`)\n- Fixed regression when setting empty :class:`DataFrame` column to a :class:`Series` in preserving name of index in frame (:issue:`36527`)\n- Fixed regression in :class:`Period` incorrect value for ordinal over the maximum timestamp (:issue:`36430`)\n- Fixed regression in :func:`read_table` raised ``ValueError`` when ``delim_whitespace`` was set to ``True`` (:issue:`35958`)\n- Fixed regression in :meth:`Series.dt.normalize` when normalizing pre-epoch dates the result was shifted one day (:issue:`36294`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_113.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :func:`read_spss` where passing a ``pathlib.Path`` as ``path`` would raise a ``TypeError`` (:issue:`33666`)\n- Bug in :meth:`Series.str.startswith` and :meth:`Series.str.endswith` with ``category`` dtype not propagating ``na`` parameter (:issue:`36241`)\n- Bug in :class:`Series` constructor where integer overflow would occur for sufficiently large scalar inputs when an index was provided (:issue:`36291`)\n- Bug in :meth:`DataFrame.sort_values` raising an ``AttributeError`` when sorting on a key that casts column to categorical dtype (:issue:`36383`)\n- Bug in :meth:`DataFrame.stack` raising a ``ValueError`` when stacking :class:`MultiIndex` columns based on position when the levels had duplicate names (:issue:`36353`)\n- Bug in :meth:`Series.astype` showing too much precision when casting from ``np.float32`` to string dtype (:issue:`36451`)\n- Bug in :meth:`Series.isin` and :meth:`DataFrame.isin` when using ``NaN`` and a row length above 1,000,000 (:issue:`22205`)\n- Bug in :func:`cut` raising a ``ValueError`` when passed a :class:`Series` of labels with ``ordered=False`` (:issue:`36603`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_113.other:\n\nOther\n~~~~~\n- Reverted enhancement added in pandas-1.1.0 where :func:`timedelta_range` infers a frequency when passed ``start``, ``stop``, and ``periods`` (:issue:`32377`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_113.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.1.2..v1.1.3\n", "2.0.3": ".. _whatsnew_203:\n\nWhat's new in 2.0.3 (June 28, 2023)\n-----------------------------------\n\nThese are the changes in pandas 2.0.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_203.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Bug in :meth:`Timestamp.weekday`` was returning incorrect results before ``'0000-02-29'`` (:issue:`53738`)\n- Fixed performance regression in merging on datetime-like columns (:issue:`53231`)\n- Fixed regression when :meth:`DataFrame.to_string` creates extra space for string dtypes (:issue:`52690`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_203.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :func:`DataFrame.convert_dtype` and :func:`Series.convert_dtype` when trying to convert :class:`ArrowDtype` with ``dtype_backend=\"nullable_numpy\"`` (:issue:`53648`)\n- Bug in :func:`RangeIndex.union` when using ``sort=True`` with another :class:`RangeIndex` (:issue:`53490`)\n- Bug in :func:`Series.reindex` when expanding a non-nanosecond datetime or timedelta :class:`Series` would not fill with ``NaT`` correctly (:issue:`53497`)\n- Bug in :func:`read_csv` when defining ``dtype`` with ``bool[pyarrow]`` for the ``\"c\"`` and ``\"python\"`` engines (:issue:`53390`)\n- Bug in :meth:`Series.str.split` and :meth:`Series.str.rsplit` with ``expand=True`` for :class:`ArrowDtype` with ``pyarrow.string`` (:issue:`53532`)\n- Bug in indexing methods (e.g. :meth:`DataFrame.__getitem__`) where taking the entire :class:`DataFrame`/:class:`Series` would raise an ``OverflowError`` when Copy on Write was enabled and the length of the array was over the maximum size a 32-bit integer can hold (:issue:`53616`)\n- Bug when constructing a :class:`DataFrame` with columns of an :class:`ArrowDtype` with a ``pyarrow.dictionary`` type that reindexes the data (:issue:`53617`)\n- Bug when indexing a :class:`DataFrame` or :class:`Series` with an :class:`Index` with a timestamp :class:`ArrowDtype` would raise an ``AttributeError`` (:issue:`53644`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_203.other:\n\nOther\n~~~~~\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_203.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.0.2..v2.0.3\n", "2.2.0": ".. _whatsnew_220:\n\nWhat's new in 2.2.0 (January 19, 2024)\n--------------------------------------\n\nThese are the changes in pandas 2.2.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_220.upcoming_changes:\n\nUpcoming changes in pandas 3.0\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\npandas 3.0 will bring two bigger changes to the default behavior of pandas.\n\nCopy-on-Write\n^^^^^^^^^^^^^\n\nThe currently optional mode Copy-on-Write will be enabled by default in pandas 3.0. There\nwon't be an option to keep the current behavior enabled. The new behavioral semantics are\nexplained in the :ref:`user guide about Copy-on-Write <copy_on_write>`.\n\nThe new behavior can be enabled since pandas 2.0 with the following option:\n\n.. code-block:: ipython\n\n   pd.options.mode.copy_on_write = True\n\nThis change brings different changes in behavior in how pandas operates with respect to\ncopies and views. Some of these changes allow a clear deprecation, like the changes in\nchained assignment. Other changes are more subtle and thus, the warnings are hidden behind\nan option that can be enabled in pandas 2.2.\n\n.. code-block:: ipython\n\n   pd.options.mode.copy_on_write = \"warn\"\n\nThis mode will warn in many different scenarios that aren't actually relevant to\nmost queries. We recommend exploring this mode, but it is not necessary to get rid\nof all of these warnings. The :ref:`migration guide <copy_on_write.migration_guide>`\nexplains the upgrade process in more detail.\n\nDedicated string data type (backed by Arrow) by default\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nHistorically, pandas represented string columns with NumPy object data type. This\nrepresentation has numerous problems, including slow performance and a large memory\nfootprint. This will change in pandas 3.0. pandas will start inferring string columns\nas a new ``string`` data type, backed by Arrow, which represents strings contiguous in memory. This brings\na huge performance and memory improvement.\n\nOld behavior:\n\n.. code-block:: ipython\n\n    In [1]: ser = pd.Series([\"a\", \"b\"])\n    Out[1]:\n    0    a\n    1    b\n    dtype: object\n\nNew behavior:\n\n\n.. code-block:: ipython\n\n    In [1]: ser = pd.Series([\"a\", \"b\"])\n    Out[1]:\n    0    a\n    1    b\n    dtype: string\n\nThe string data type that is used in these scenarios will mostly behave as NumPy\nobject would, including missing value semantics and general operations on these\ncolumns.\n\nThis change includes a few additional changes across the API:\n\n- Currently, specifying ``dtype=\"string\"`` creates a dtype that is backed by Python strings\n  which are stored in a NumPy array. This will change in pandas 3.0, this dtype\n  will create an Arrow backed string column.\n- The column names and the Index will also be backed by Arrow strings.\n- PyArrow will become a required dependency with pandas 3.0 to accommodate this change.\n\nThis future dtype inference logic can be enabled with:\n\n.. code-block:: ipython\n\n   pd.options.future.infer_string = True\n\n.. _whatsnew_220.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_220.enhancements.adbc_support:\n\nADBC Driver support in to_sql and read_sql\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:func:`read_sql` and :meth:`~DataFrame.to_sql` now work with `Apache Arrow ADBC\n<https://arrow.apache.org/adbc/current/index.html>`_ drivers. Compared to\ntraditional drivers used via SQLAlchemy, ADBC drivers should provide\nsignificant performance improvements, better type support and cleaner\nnullability handling.\n\n.. code-block:: ipython\n\n   import adbc_driver_postgresql.dbapi as pg_dbapi\n\n   df = pd.DataFrame(\n       [\n           [1, 2, 3],\n           [4, 5, 6],\n       ],\n       columns=['a', 'b', 'c']\n   )\n   uri = \"postgresql://postgres:postgres@localhost/postgres\"\n   with pg_dbapi.connect(uri) as conn:\n       df.to_sql(\"pandas_table\", conn, index=False)\n\n   # for round-tripping\n   with pg_dbapi.connect(uri) as conn:\n       df2 = pd.read_sql(\"pandas_table\", conn)\n\nThe Arrow type system offers a wider array of types that can more closely match\nwhat databases like PostgreSQL can offer. To illustrate, note this (non-exhaustive)\nlisting of types available in different databases and pandas backends:\n\n+-----------------+-----------------------+----------------+---------+\n|numpy/pandas     |arrow                  |postgres        |sqlite   |\n+=================+=======================+================+=========+\n|int16/Int16      |int16                  |SMALLINT        |INTEGER  |\n+-----------------+-----------------------+----------------+---------+\n|int32/Int32      |int32                  |INTEGER         |INTEGER  |\n+-----------------+-----------------------+----------------+---------+\n|int64/Int64      |int64                  |BIGINT          |INTEGER  |\n+-----------------+-----------------------+----------------+---------+\n|float32          |float32                |REAL            |REAL     |\n+-----------------+-----------------------+----------------+---------+\n|float64          |float64                |DOUBLE PRECISION|REAL     |\n+-----------------+-----------------------+----------------+---------+\n|object           |string                 |TEXT            |TEXT     |\n+-----------------+-----------------------+----------------+---------+\n|bool             |``bool_``              |BOOLEAN         |         |\n+-----------------+-----------------------+----------------+---------+\n|datetime64[ns]   |timestamp(us)          |TIMESTAMP       |         |\n+-----------------+-----------------------+----------------+---------+\n|datetime64[ns,tz]|timestamp(us,tz)       |TIMESTAMPTZ     |         |\n+-----------------+-----------------------+----------------+---------+\n|                 |date32                 |DATE            |         |\n+-----------------+-----------------------+----------------+---------+\n|                 |month_day_nano_interval|INTERVAL        |         |\n+-----------------+-----------------------+----------------+---------+\n|                 |binary                 |BINARY          |BLOB     |\n+-----------------+-----------------------+----------------+---------+\n|                 |decimal128             |DECIMAL [#f1]_  |         |\n+-----------------+-----------------------+----------------+---------+\n|                 |list                   |ARRAY [#f1]_    |         |\n+-----------------+-----------------------+----------------+---------+\n|                 |struct                 |COMPOSITE TYPE  |         |\n|                 |                       | [#f1]_         |         |\n+-----------------+-----------------------+----------------+---------+\n\n.. rubric:: Footnotes\n\n.. [#f1] Not implemented as of writing, but theoretically possible\n\nIf you are interested in preserving database types as best as possible\nthroughout the lifecycle of your DataFrame, users are encouraged to\nleverage the ``dtype_backend=\"pyarrow\"`` argument of :func:`~pandas.read_sql`\n\n.. code-block:: ipython\n\n   # for round-tripping\n   with pg_dbapi.connect(uri) as conn:\n       df2 = pd.read_sql(\"pandas_table\", conn, dtype_backend=\"pyarrow\")\n\nThis will prevent your data from being converted to the traditional pandas/NumPy\ntype system, which often converts SQL types in ways that make them impossible to\nround-trip.\n\nFor a full list of ADBC drivers and their development status, see the `ADBC Driver\nImplementation Status <https://arrow.apache.org/adbc/current/driver/status.html>`_\ndocumentation.\n\n.. _whatsnew_220.enhancements.case_when:\n\nCreate a pandas Series based on one or more conditions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe :meth:`Series.case_when` function has been added to create a Series object based on one or more conditions. (:issue:`39154`)\n\n.. ipython:: python\n\n   import pandas as pd\n\n   df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6]))\n   default=pd.Series('default', index=df.index)\n   default.case_when(\n        caselist=[\n            (df.a == 1, 'first'),                              # condition, replacement\n            (df.a.gt(1) & df.b.eq(5), 'second'),  # condition, replacement\n        ],\n   )\n\n.. _whatsnew_220.enhancements.to_numpy_ea:\n\n``to_numpy`` for NumPy nullable and Arrow types converts to suitable NumPy dtype\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``to_numpy`` for NumPy nullable and Arrow types will now convert to a\nsuitable NumPy dtype instead of ``object`` dtype for nullable and PyArrow backed extension dtypes.\n\n*Old behavior:*\n\n.. code-block:: ipython\n\n    In [1]: ser = pd.Series([1, 2, 3], dtype=\"Int64\")\n    In [2]: ser.to_numpy()\n    Out[2]: array([1, 2, 3], dtype=object)\n\n*New behavior:*\n\n.. ipython:: python\n\n    ser = pd.Series([1, 2, 3], dtype=\"Int64\")\n    ser.to_numpy()\n\n    ser = pd.Series([1, 2, 3], dtype=\"timestamp[ns][pyarrow]\")\n    ser.to_numpy()\n\nThe default NumPy dtype (without any arguments) is determined as follows:\n\n- float dtypes are cast to NumPy floats\n- integer dtypes without missing values are cast to NumPy integer dtypes\n- integer dtypes with missing values are cast to NumPy float dtypes and ``NaN`` is used as missing value indicator\n- boolean dtypes without missing values are cast to NumPy bool dtype\n- boolean dtypes with missing values keep object dtype\n- datetime and timedelta types are cast to Numpy datetime64 and timedelta64 types respectively and ``NaT`` is used as missing value indicator\n\n.. _whatsnew_220.enhancements.struct_accessor:\n\nSeries.struct accessor for PyArrow structured data\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``Series.struct`` accessor provides attributes and methods for processing\ndata with ``struct[pyarrow]`` dtype Series. For example,\n:meth:`Series.struct.explode` converts PyArrow structured data to a pandas\nDataFrame. (:issue:`54938`)\n\n.. ipython:: python\n\n    import pyarrow as pa\n    series = pd.Series(\n        [\n            {\"project\": \"pandas\", \"version\": \"2.2.0\"},\n            {\"project\": \"numpy\", \"version\": \"1.25.2\"},\n            {\"project\": \"pyarrow\", \"version\": \"13.0.0\"},\n        ],\n        dtype=pd.ArrowDtype(\n            pa.struct([\n                (\"project\", pa.string()),\n                (\"version\", pa.string()),\n            ])\n        ),\n    )\n    series.struct.explode()\n\nUse :meth:`Series.struct.field` to index into a (possible nested)\nstruct field.\n\n\n.. ipython:: python\n\n    series.struct.field(\"project\")\n\n.. _whatsnew_220.enhancements.list_accessor:\n\nSeries.list accessor for PyArrow list data\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``Series.list`` accessor provides attributes and methods for processing\ndata with ``list[pyarrow]`` dtype Series. For example,\n:meth:`Series.list.__getitem__` allows indexing pyarrow lists in\na Series. (:issue:`55323`)\n\n.. ipython:: python\n\n    import pyarrow as pa\n    series = pd.Series(\n        [\n            [1, 2, 3],\n            [4, 5],\n            [6],\n        ],\n        dtype=pd.ArrowDtype(\n            pa.list_(pa.int64())\n        ),\n    )\n    series.list[0]\n\n.. _whatsnew_220.enhancements.calamine:\n\nCalamine engine for :func:`read_excel`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``calamine`` engine was added to :func:`read_excel`.\nIt uses ``python-calamine``, which provides Python bindings for the Rust library `calamine <https://crates.io/crates/calamine>`__.\nThis engine supports Excel files (``.xlsx``, ``.xlsm``, ``.xls``, ``.xlsb``) and OpenDocument spreadsheets (``.ods``) (:issue:`50395`).\n\nThere are two advantages of this engine:\n\n1. Calamine is often faster than other engines, some benchmarks show results up to 5x faster than 'openpyxl', 20x - 'odf', 4x - 'pyxlsb', and 1.5x - 'xlrd'.\n   But, 'openpyxl' and 'pyxlsb' are faster in reading a few rows from large files because of lazy iteration over rows.\n2. Calamine supports the recognition of datetime in ``.xlsb`` files, unlike 'pyxlsb' which is the only other engine in pandas that can read ``.xlsb`` files.\n\n.. code-block:: python\n\n   pd.read_excel(\"path_to_file.xlsb\", engine=\"calamine\")\n\n\nFor more, see :ref:`io.calamine` in the user guide on IO tools.\n\n.. _whatsnew_220.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n\n- :meth:`~DataFrame.to_sql` with method parameter set to ``multi`` works with Oracle on the backend\n- :attr:`Series.attrs` / :attr:`DataFrame.attrs` now uses a deepcopy for propagating ``attrs`` (:issue:`54134`).\n- :func:`get_dummies` now returning  extension dtypes ``boolean`` or ``bool[pyarrow]`` that are compatible with the input dtype (:issue:`56273`)\n- :func:`read_csv` now supports ``on_bad_lines`` parameter with ``engine=\"pyarrow\"`` (:issue:`54480`)\n- :func:`read_sas` returns ``datetime64`` dtypes with resolutions better matching those stored natively in SAS, and avoids returning object-dtype in cases that cannot be stored with ``datetime64[ns]`` dtype (:issue:`56127`)\n- :func:`read_spss` now returns a :class:`DataFrame` that stores the metadata in :attr:`DataFrame.attrs` (:issue:`54264`)\n- :func:`tseries.api.guess_datetime_format` is now part of the public API (:issue:`54727`)\n- :meth:`DataFrame.apply` now allows the usage of numba (via ``engine=\"numba\"``) to JIT compile the passed function, allowing for potential speedups (:issue:`54666`)\n- :meth:`ExtensionArray._explode` interface method added to allow extension type implementations of the ``explode`` method (:issue:`54833`)\n- :meth:`ExtensionArray.duplicated` added to allow extension type implementations of the ``duplicated`` method (:issue:`55255`)\n- :meth:`Series.ffill`, :meth:`Series.bfill`, :meth:`DataFrame.ffill`, and :meth:`DataFrame.bfill` have gained the argument ``limit_area``; 3rd party :class:`.ExtensionArray` authors need to add this argument to the method ``_pad_or_backfill`` (:issue:`56492`)\n- Allow passing ``read_only``, ``data_only`` and ``keep_links`` arguments to openpyxl using ``engine_kwargs`` of :func:`read_excel` (:issue:`55027`)\n- Implement :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` for :class:`ArrowDtype` and masked dtypes (:issue:`56267`)\n- Implement masked algorithms for :meth:`Series.value_counts` (:issue:`54984`)\n- Implemented :meth:`Series.dt` methods and attributes for :class:`ArrowDtype` with ``pyarrow.duration`` type (:issue:`52284`)\n- Implemented :meth:`Series.str.extract` for :class:`ArrowDtype` (:issue:`56268`)\n- Improved error message that appears in :meth:`DatetimeIndex.to_period` with frequencies which are not supported as period frequencies, such as ``\"BMS\"`` (:issue:`56243`)\n- Improved error message when constructing :class:`Period` with invalid offsets such as ``\"QS\"`` (:issue:`55785`)\n- The dtypes ``string[pyarrow]`` and ``string[pyarrow_numpy]`` now both utilize the ``large_string`` type from PyArrow to avoid overflow for long columns (:issue:`56259`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_220.notable_bug_fixes:\n\nNotable bug fixes\n~~~~~~~~~~~~~~~~~\n\nThese are bug fixes that might have notable behavior changes.\n\n.. _whatsnew_220.notable_bug_fixes.merge_sort_behavior:\n\n:func:`merge` and :meth:`DataFrame.join` now consistently follow documented sort behavior\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn previous versions of pandas, :func:`merge` and :meth:`DataFrame.join` did not\nalways return a result that followed the documented sort behavior. pandas now\nfollows the documented sort behavior in merge and join operations (:issue:`54611`, :issue:`56426`, :issue:`56443`).\n\nAs documented, ``sort=True`` sorts the join keys lexicographically in the resulting\n:class:`DataFrame`. With ``sort=False``, the order of the join keys depends on the\njoin type (``how`` keyword):\n\n- ``how=\"left\"``: preserve the order of the left keys\n- ``how=\"right\"``: preserve the order of the right keys\n- ``how=\"inner\"``: preserve the order of the left keys\n- ``how=\"outer\"``: sort keys lexicographically\n\nOne example with changing behavior is inner joins with non-unique left join keys\nand ``sort=False``:\n\n.. ipython:: python\n\n    left = pd.DataFrame({\"a\": [1, 2, 1]})\n    right = pd.DataFrame({\"a\": [1, 2]})\n    result = pd.merge(left, right, how=\"inner\", on=\"a\", sort=False)\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [5]: result\n    Out[5]:\n       a\n    0  1\n    1  1\n    2  2\n\n*New Behavior*\n\n.. ipython:: python\n\n    result\n\n.. _whatsnew_220.notable_bug_fixes.multiindex_join_different_levels:\n\n:func:`merge` and :meth:`DataFrame.join` no longer reorder levels when levels differ\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn previous versions of pandas, :func:`merge` and :meth:`DataFrame.join` would reorder\nindex levels when joining on two indexes with different levels (:issue:`34133`).\n\n.. ipython:: python\n\n    left = pd.DataFrame({\"left\": 1}, index=pd.MultiIndex.from_tuples([(\"x\", 1), (\"x\", 2)], names=[\"A\", \"B\"]))\n    right = pd.DataFrame({\"right\": 2}, index=pd.MultiIndex.from_tuples([(1, 1), (2, 2)], names=[\"B\", \"C\"]))\n    left\n    right\n    result = left.join(right)\n\n*Old Behavior*\n\n.. code-block:: ipython\n\n    In [5]: result\n    Out[5]:\n           left  right\n    B A C\n    1 x 1     1      2\n    2 x 2     1      2\n\n*New Behavior*\n\n.. ipython:: python\n\n    result\n\n.. _whatsnew_220.api_breaking.deps:\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nFor `optional dependencies <https://pandas.pydata.org/docs/getting_started/install.html>`_ the general recommendation is to use the latest version.\nOptional dependencies below the lowest tested version may still work but are not considered supported.\nThe following table lists the optional dependencies that have had their minimum tested version increased.\n\n+-----------------+---------------------+\n| Package         | New Minimum Version |\n+=================+=====================+\n| beautifulsoup4  | 4.11.2              |\n+-----------------+---------------------+\n| blosc           | 1.21.3              |\n+-----------------+---------------------+\n| bottleneck      | 1.3.6               |\n+-----------------+---------------------+\n| fastparquet     | 2022.12.0           |\n+-----------------+---------------------+\n| fsspec          | 2022.11.0           |\n+-----------------+---------------------+\n| gcsfs           | 2022.11.0           |\n+-----------------+---------------------+\n| lxml            | 4.9.2               |\n+-----------------+---------------------+\n| matplotlib      | 3.6.3               |\n+-----------------+---------------------+\n| numba           | 0.56.4              |\n+-----------------+---------------------+\n| numexpr         | 2.8.4               |\n+-----------------+---------------------+\n| qtpy            | 2.3.0               |\n+-----------------+---------------------+\n| openpyxl        | 3.1.0               |\n+-----------------+---------------------+\n| psycopg2        | 2.9.6               |\n+-----------------+---------------------+\n| pyreadstat      | 1.2.0               |\n+-----------------+---------------------+\n| pytables        | 3.8.0               |\n+-----------------+---------------------+\n| pyxlsb          | 1.0.10              |\n+-----------------+---------------------+\n| s3fs            | 2022.11.0           |\n+-----------------+---------------------+\n| scipy           | 1.10.0              |\n+-----------------+---------------------+\n| sqlalchemy      | 2.0.0               |\n+-----------------+---------------------+\n| tabulate        | 0.9.0               |\n+-----------------+---------------------+\n| xarray          | 2022.12.0           |\n+-----------------+---------------------+\n| xlsxwriter      | 3.0.5               |\n+-----------------+---------------------+\n| zstandard       | 0.19.0              |\n+-----------------+---------------------+\n| pyqt5           | 5.15.8              |\n+-----------------+---------------------+\n| tzdata          | 2022.7              |\n+-----------------+---------------------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\n.. _whatsnew_220.api_breaking.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n- The hash values of nullable extension dtypes changed to improve the performance of the hashing operation (:issue:`56507`)\n- ``check_exact`` now only takes effect for floating-point dtypes in :func:`testing.assert_frame_equal` and :func:`testing.assert_series_equal`. In particular, integer dtypes are always checked exactly (:issue:`55882`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_220.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\nChained assignment\n^^^^^^^^^^^^^^^^^^\n\nIn preparation of larger upcoming changes to the copy / view behaviour in pandas 3.0\n(:ref:`copy_on_write`, PDEP-7), we started deprecating *chained assignment*.\n\nChained assignment occurs when you try to update a pandas DataFrame or Series through\ntwo subsequent indexing operations. Depending on the type and order of those operations\nthis currently does or does not work.\n\nA typical example is as follows:\n\n.. code-block:: python\n\n    df = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\n\n    # first selecting rows with a mask, then assigning values to a column\n    # -> this has never worked and raises a SettingWithCopyWarning\n    df[df[\"bar\"] > 5][\"foo\"] = 100\n\n    # first selecting the column, and then assigning to a subset of that column\n    # -> this currently works\n    df[\"foo\"][df[\"bar\"] > 5] = 100\n\nThis second example of chained assignment currently works to update the original ``df``.\nThis will no longer work in pandas 3.0, and therefore we started deprecating this:\n\n.. code-block:: python\n\n    >>> df[\"foo\"][df[\"bar\"] > 5] = 100\n    FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n    A typical example is when you are setting values in a column of a DataFrame, like:\n\n    df[\"col\"][row_indexer] = value\n\n    Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\n    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nYou can fix this warning and ensure your code is ready for pandas 3.0 by removing\nthe usage of chained assignment. Typically, this can be done by doing the assignment\nin a single step using for example ``.loc``. For the example above, we can do:\n\n.. code-block:: python\n\n    df.loc[df[\"bar\"] > 5, \"foo\"] = 100\n\nThe same deprecation applies to inplace methods that are done in a chained manner, such as:\n\n.. code-block:: python\n\n    >>> df[\"foo\"].fillna(0, inplace=True)\n    FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\n    The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n\n    For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n\nWhen the goal is to update the column in the DataFrame ``df``, the alternative here is\nto call the method on ``df`` itself, such as ``df.fillna({\"foo\": 0}, inplace=True)``.\n\nSee more details in the :ref:`migration guide <copy_on_write.migration_guide>`.\n\n\nDeprecate aliases ``M``, ``Q``, ``Y``, etc. in favour of ``ME``, ``QE``, ``YE``, etc. for offsets\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated the following frequency aliases (:issue:`9586`):\n\n+-------------------------------+------------------+------------------+\n|offsets                        |deprecated aliases|new aliases       |\n+===============================+==================+==================+\n|:class:`MonthEnd`              |      ``M``       |     ``ME``       |\n+-------------------------------+------------------+------------------+\n|:class:`BusinessMonthEnd`      |      ``BM``      |     ``BME``      |\n+-------------------------------+------------------+------------------+\n|:class:`SemiMonthEnd`          |      ``SM``      |     ``SME``      |\n+-------------------------------+------------------+------------------+\n|:class:`CustomBusinessMonthEnd`|      ``CBM``     |     ``CBME``     |\n+-------------------------------+------------------+------------------+\n|:class:`QuarterEnd`            |      ``Q``       |     ``QE``       |\n+-------------------------------+------------------+------------------+\n|:class:`BQuarterEnd`           |      ``BQ``      |     ``BQE``      |\n+-------------------------------+------------------+------------------+\n|:class:`YearEnd`               |      ``Y``       |     ``YE``       |\n+-------------------------------+------------------+------------------+\n|:class:`BYearEnd`              |      ``BY``      |     ``BYE``      |\n+-------------------------------+------------------+------------------+\n\nFor example:\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [8]: pd.date_range('2020-01-01', periods=3, freq='Q-NOV')\n    Out[8]:\n    DatetimeIndex(['2020-02-29', '2020-05-31', '2020-08-31'],\n                  dtype='datetime64[ns]', freq='Q-NOV')\n\n*Future behavior*:\n\n.. ipython:: python\n\n    pd.date_range('2020-01-01', periods=3, freq='QE-NOV')\n\nDeprecated automatic downcasting\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nDeprecated the automatic downcasting of object dtype results in a number of\nmethods. These would silently change the dtype in a hard to predict manner since the\nbehavior was value dependent. Additionally, pandas is moving away from silent dtype\nchanges (:issue:`54710`, :issue:`54261`).\n\nThese methods are:\n\n- :meth:`Series.replace` and :meth:`DataFrame.replace`\n- :meth:`DataFrame.fillna`, :meth:`Series.fillna`\n- :meth:`DataFrame.ffill`, :meth:`Series.ffill`\n- :meth:`DataFrame.bfill`, :meth:`Series.bfill`\n- :meth:`DataFrame.mask`, :meth:`Series.mask`\n- :meth:`DataFrame.where`, :meth:`Series.where`\n- :meth:`DataFrame.clip`, :meth:`Series.clip`\n\nExplicitly call :meth:`DataFrame.infer_objects` to replicate the current behavior in the future.\n\n.. code-block:: ipython\n\n    result = result.infer_objects(copy=False)\n\nOr explicitly cast all-round floats to ints using ``astype``.\n\nSet the following option to opt into the future behavior:\n\n.. code-block:: ipython\n\n    In [9]: pd.set_option(\"future.no_silent_downcasting\", True)\n\nOther Deprecations\n^^^^^^^^^^^^^^^^^^\n- Changed :meth:`Timedelta.resolution_string` to return ``h``, ``min``, ``s``, ``ms``, ``us``, and ``ns`` instead of ``H``, ``T``, ``S``, ``L``, ``U``, and ``N``, for compatibility with respective deprecations in frequency aliases (:issue:`52536`)\n- Deprecated :attr:`offsets.Day.delta`, :attr:`offsets.Hour.delta`, :attr:`offsets.Minute.delta`, :attr:`offsets.Second.delta`, :attr:`offsets.Milli.delta`, :attr:`offsets.Micro.delta`, :attr:`offsets.Nano.delta`, use ``pd.Timedelta(obj)`` instead (:issue:`55498`)\n- Deprecated :func:`pandas.api.types.is_interval` and :func:`pandas.api.types.is_period`, use ``isinstance(obj, pd.Interval)`` and ``isinstance(obj, pd.Period)`` instead (:issue:`55264`)\n- Deprecated :func:`read_gbq` and :meth:`DataFrame.to_gbq`. Use ``pandas_gbq.read_gbq`` and ``pandas_gbq.to_gbq`` instead https://pandas-gbq.readthedocs.io/en/latest/api.html (:issue:`55525`)\n- Deprecated :meth:`.DataFrameGroupBy.fillna` and :meth:`.SeriesGroupBy.fillna`; use :meth:`.DataFrameGroupBy.ffill`, :meth:`.DataFrameGroupBy.bfill` for forward and backward filling or :meth:`.DataFrame.fillna` to fill with a single value (or the Series equivalents) (:issue:`55718`)\n- Deprecated :meth:`DateOffset.is_anchored`, use ``obj.n == 1`` for non-Tick subclasses (for Tick this was always False) (:issue:`55388`)\n- Deprecated :meth:`DatetimeArray.__init__` and :meth:`TimedeltaArray.__init__`, use :func:`array` instead (:issue:`55623`)\n- Deprecated :meth:`Index.format`, use ``index.astype(str)`` or ``index.map(formatter)`` instead (:issue:`55413`)\n- Deprecated :meth:`Series.ravel`, the underlying array is already 1D, so ravel is not necessary (:issue:`52511`)\n- Deprecated :meth:`Series.resample` and :meth:`DataFrame.resample` with a :class:`PeriodIndex` (and the 'convention' keyword), convert to :class:`DatetimeIndex` (with ``.to_timestamp()``) before resampling instead (:issue:`53481`)\n- Deprecated :meth:`Series.view`, use :meth:`Series.astype` instead to change the dtype (:issue:`20251`)\n- Deprecated :meth:`offsets.Tick.is_anchored`, use ``False`` instead (:issue:`55388`)\n- Deprecated ``core.internals`` members ``Block``, ``ExtensionBlock``, and ``DatetimeTZBlock``, use public APIs instead (:issue:`55139`)\n- Deprecated ``year``, ``month``, ``quarter``, ``day``, ``hour``, ``minute``, and ``second`` keywords in the :class:`PeriodIndex` constructor, use :meth:`PeriodIndex.from_fields` instead (:issue:`55960`)\n- Deprecated accepting a type as an argument in :meth:`Index.view`, call without any arguments instead (:issue:`55709`)\n- Deprecated allowing non-integer ``periods`` argument in :func:`date_range`, :func:`timedelta_range`, :func:`period_range`, and :func:`interval_range` (:issue:`56036`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_clipboard` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_csv` except ``path_or_buf`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_dict` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_excel` except ``excel_writer`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_gbq` except ``destination_table`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_hdf` except ``path_or_buf`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_html` except ``buf`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_json` except ``path_or_buf`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_latex` except ``buf`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_markdown` except ``buf`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_parquet` except ``path`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_pickle` except ``path`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_string` except ``buf`` (:issue:`54229`)\n- Deprecated allowing non-keyword arguments in :meth:`DataFrame.to_xml` except ``path_or_buffer`` (:issue:`54229`)\n- Deprecated allowing passing :class:`BlockManager` objects to :class:`DataFrame` or :class:`SingleBlockManager` objects to :class:`Series` (:issue:`52419`)\n- Deprecated behavior of :meth:`Index.insert` with an object-dtype index silently performing type inference on the result, explicitly call ``result.infer_objects(copy=False)`` for the old behavior instead (:issue:`51363`)\n- Deprecated casting non-datetimelike values (mainly strings) in :meth:`Series.isin` and :meth:`Index.isin` with ``datetime64``, ``timedelta64``, and :class:`PeriodDtype` dtypes (:issue:`53111`)\n- Deprecated dtype inference in :class:`Index`, :class:`Series` and :class:`DataFrame` constructors when giving a pandas input, call ``.infer_objects`` on the input to keep the current behavior (:issue:`56012`)\n- Deprecated dtype inference when setting a :class:`Index` into a :class:`DataFrame`, cast explicitly instead (:issue:`56102`)\n- Deprecated including the groups in computations when using :meth:`.DataFrameGroupBy.apply` and :meth:`.DataFrameGroupBy.resample`; pass ``include_groups=False`` to exclude the groups (:issue:`7155`)\n- Deprecated indexing an :class:`Index`  with a boolean indexer of length zero (:issue:`55820`)\n- Deprecated not passing a tuple to :class:`.DataFrameGroupBy.get_group` or :class:`.SeriesGroupBy.get_group` when grouping by a length-1 list-like (:issue:`25971`)\n- Deprecated string ``AS`` denoting frequency in :class:`YearBegin` and strings ``AS-DEC``, ``AS-JAN``, etc. denoting annual frequencies with various fiscal year starts (:issue:`54275`)\n- Deprecated string ``A`` denoting frequency in :class:`YearEnd` and strings ``A-DEC``, ``A-JAN``, etc. denoting annual frequencies with various fiscal year ends (:issue:`54275`)\n- Deprecated string ``BAS`` denoting frequency in :class:`BYearBegin` and strings ``BAS-DEC``, ``BAS-JAN``, etc. denoting annual frequencies with various fiscal year starts (:issue:`54275`)\n- Deprecated string ``BA`` denoting frequency in :class:`BYearEnd` and strings ``BA-DEC``, ``BA-JAN``, etc. denoting annual frequencies with various fiscal year ends (:issue:`54275`)\n- Deprecated strings ``H``, ``BH``, and ``CBH`` denoting frequencies in :class:`Hour`, :class:`BusinessHour`, :class:`CustomBusinessHour` (:issue:`52536`)\n- Deprecated strings ``H``, ``S``, ``U``, and ``N`` denoting units in :func:`to_timedelta` (:issue:`52536`)\n- Deprecated strings ``H``, ``T``, ``S``, ``L``, ``U``, and ``N`` denoting units in :class:`Timedelta` (:issue:`52536`)\n- Deprecated strings ``T``, ``S``, ``L``, ``U``, and ``N`` denoting frequencies in :class:`Minute`, :class:`Second`, :class:`Milli`, :class:`Micro`, :class:`Nano` (:issue:`52536`)\n- Deprecated support for combining parsed datetime columns in :func:`read_csv` along with the ``keep_date_col`` keyword (:issue:`55569`)\n- Deprecated the :attr:`.DataFrameGroupBy.grouper` and :attr:`SeriesGroupBy.grouper`; these attributes will be removed in a future version of pandas (:issue:`56521`)\n- Deprecated the :class:`.Grouping` attributes ``group_index``, ``result_index``, and ``group_arraylike``; these will be removed in a future version of pandas (:issue:`56148`)\n- Deprecated the ``delim_whitespace`` keyword in :func:`read_csv` and :func:`read_table`, use ``sep=\"\\\\s+\"`` instead (:issue:`55569`)\n- Deprecated the ``errors=\"ignore\"`` option in :func:`to_datetime`, :func:`to_timedelta`, and :func:`to_numeric`; explicitly catch exceptions instead (:issue:`54467`)\n- Deprecated the ``fastpath`` keyword in the :class:`Series` constructor (:issue:`20110`)\n- Deprecated the ``kind`` keyword in :meth:`Series.resample` and :meth:`DataFrame.resample`, explicitly cast the object's ``index`` instead (:issue:`55895`)\n- Deprecated the ``ordinal`` keyword in :class:`PeriodIndex`, use :meth:`PeriodIndex.from_ordinals` instead (:issue:`55960`)\n- Deprecated the ``unit`` keyword in :class:`TimedeltaIndex` construction, use :func:`to_timedelta` instead (:issue:`55499`)\n- Deprecated the ``verbose`` keyword in :func:`read_csv` and :func:`read_table` (:issue:`55569`)\n- Deprecated the behavior of :meth:`DataFrame.replace` and :meth:`Series.replace` with :class:`CategoricalDtype`; in a future version replace will change the values while preserving the categories. To change the categories, use ``ser.cat.rename_categories`` instead (:issue:`55147`)\n- Deprecated the behavior of :meth:`Series.value_counts` and :meth:`Index.value_counts` with object dtype; in a future version these will not perform dtype inference on the resulting :class:`Index`, do ``result.index = result.index.infer_objects()`` to retain the old behavior (:issue:`56161`)\n- Deprecated the default of ``observed=False`` in :meth:`DataFrame.pivot_table`; will be ``True`` in a future version (:issue:`56236`)\n- Deprecated the extension test classes ``BaseNoReduceTests``, ``BaseBooleanReduceTests``, and ``BaseNumericReduceTests``, use ``BaseReduceTests`` instead (:issue:`54663`)\n- Deprecated the option ``mode.data_manager`` and the ``ArrayManager``; only the ``BlockManager`` will be available in future versions (:issue:`55043`)\n- Deprecated the previous implementation of :class:`DataFrame.stack`; specify ``future_stack=True`` to adopt the future version (:issue:`53515`)\n-\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_220.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- Performance improvement in :func:`.testing.assert_frame_equal` and :func:`.testing.assert_series_equal` (:issue:`55949`, :issue:`55971`)\n- Performance improvement in :func:`concat` with ``axis=1`` and objects with unaligned indexes (:issue:`55084`)\n- Performance improvement in :func:`get_dummies` (:issue:`56089`)\n- Performance improvement in :func:`merge` and :func:`merge_ordered` when joining on sorted ascending keys (:issue:`56115`)\n- Performance improvement in :func:`merge_asof` when ``by`` is not ``None`` (:issue:`55580`, :issue:`55678`)\n- Performance improvement in :func:`read_stata` for files with many variables (:issue:`55515`)\n- Performance improvement in :meth:`DataFrame.groupby` when aggregating pyarrow timestamp and duration dtypes (:issue:`55031`)\n- Performance improvement in :meth:`DataFrame.join` when joining on unordered categorical indexes (:issue:`56345`)\n- Performance improvement in :meth:`DataFrame.loc` and :meth:`Series.loc` when indexing with a :class:`MultiIndex` (:issue:`56062`)\n- Performance improvement in :meth:`DataFrame.sort_index` and :meth:`Series.sort_index` when indexed by a :class:`MultiIndex` (:issue:`54835`)\n- Performance improvement in :meth:`DataFrame.to_dict` on converting DataFrame to dictionary (:issue:`50990`)\n- Performance improvement in :meth:`Index.difference` (:issue:`55108`)\n- Performance improvement in :meth:`Index.sort_values` when index is already sorted (:issue:`56128`)\n- Performance improvement in :meth:`MultiIndex.get_indexer` when ``method`` is not ``None`` (:issue:`55839`)\n- Performance improvement in :meth:`Series.duplicated` for pyarrow dtypes (:issue:`55255`)\n- Performance improvement in :meth:`Series.str.get_dummies` when dtype is ``\"string[pyarrow]\"`` or ``\"string[pyarrow_numpy]\"`` (:issue:`56110`)\n- Performance improvement in :meth:`Series.str` methods (:issue:`55736`)\n- Performance improvement in :meth:`Series.value_counts` and :meth:`Series.mode` for masked dtypes (:issue:`54984`, :issue:`55340`)\n- Performance improvement in :meth:`.DataFrameGroupBy.nunique` and :meth:`.SeriesGroupBy.nunique` (:issue:`55972`)\n- Performance improvement in :meth:`.SeriesGroupBy.idxmax`, :meth:`.SeriesGroupBy.idxmin`, :meth:`.DataFrameGroupBy.idxmax`, :meth:`.DataFrameGroupBy.idxmin` (:issue:`54234`)\n- Performance improvement when hashing a nullable extension array (:issue:`56507`)\n- Performance improvement when indexing into a non-unique index (:issue:`55816`)\n- Performance improvement when indexing with more than 4 keys (:issue:`54550`)\n- Performance improvement when localizing time to UTC (:issue:`55241`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_220.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n- :meth:`Categorical.isin` raising ``InvalidIndexError`` for categorical containing overlapping :class:`Interval` values (:issue:`34974`)\n- Bug in :meth:`CategoricalDtype.__eq__` returning ``False`` for unordered categorical data with mixed types (:issue:`55468`)\n- Bug when casting ``pa.dictionary`` to :class:`CategoricalDtype` using a ``pa.DictionaryArray`` as categories (:issue:`56672`)\n\nDatetimelike\n^^^^^^^^^^^^\n- Bug in :class:`DatetimeIndex` construction when passing both a ``tz`` and either ``dayfirst`` or ``yearfirst`` ignoring dayfirst/yearfirst (:issue:`55813`)\n- Bug in :class:`DatetimeIndex` when passing an object-dtype ndarray of float objects and a ``tz`` incorrectly localizing the result (:issue:`55780`)\n- Bug in :func:`Series.isin` with :class:`DatetimeTZDtype` dtype and comparison values that are all ``NaT`` incorrectly returning all-``False`` even if the series contains ``NaT`` entries (:issue:`56427`)\n- Bug in :func:`concat` raising ``AttributeError`` when concatenating all-NA DataFrame with :class:`DatetimeTZDtype` dtype DataFrame (:issue:`52093`)\n- Bug in :func:`testing.assert_extension_array_equal` that could use the wrong unit when comparing resolutions (:issue:`55730`)\n- Bug in :func:`to_datetime` and :class:`DatetimeIndex` when passing a list of mixed-string-and-numeric types incorrectly raising (:issue:`55780`)\n- Bug in :func:`to_datetime` and :class:`DatetimeIndex` when passing mixed-type objects with a mix of timezones or mix of timezone-awareness failing to raise ``ValueError`` (:issue:`55693`)\n- Bug in :meth:`.Tick.delta` with very large ticks raising ``OverflowError`` instead of ``OutOfBoundsTimedelta`` (:issue:`55503`)\n- Bug in :meth:`DatetimeIndex.shift` with non-nanosecond resolution incorrectly returning with nanosecond resolution (:issue:`56117`)\n- Bug in :meth:`DatetimeIndex.union` returning object dtype for tz-aware indexes with the same timezone but different units (:issue:`55238`)\n- Bug in :meth:`Index.is_monotonic_increasing` and :meth:`Index.is_monotonic_decreasing` always caching :meth:`Index.is_unique` as ``True`` when first value in index is ``NaT`` (:issue:`55755`)\n- Bug in :meth:`Index.view` to a datetime64 dtype with non-supported resolution incorrectly raising (:issue:`55710`)\n- Bug in :meth:`Series.dt.round` with non-nanosecond resolution and ``NaT`` entries incorrectly raising ``OverflowError`` (:issue:`56158`)\n- Bug in :meth:`Series.fillna` with non-nanosecond resolution dtypes and higher-resolution vector values returning incorrect (internally-corrupted) results (:issue:`56410`)\n- Bug in :meth:`Timestamp.unit` being inferred incorrectly from an ISO8601 format string with minute or hour resolution and a timezone offset (:issue:`56208`)\n- Bug in ``.astype`` converting from a higher-resolution ``datetime64`` dtype to a lower-resolution ``datetime64`` dtype (e.g. ``datetime64[us]->datetime64[ms]``) silently overflowing with values near the lower implementation bound (:issue:`55979`)\n- Bug in adding or subtracting a :class:`Week` offset to a ``datetime64`` :class:`Series`, :class:`Index`, or :class:`DataFrame` column with non-nanosecond resolution returning incorrect results (:issue:`55583`)\n- Bug in addition or subtraction of :class:`BusinessDay` offset with ``offset`` attribute to non-nanosecond :class:`Index`, :class:`Series`, or :class:`DataFrame` column giving incorrect results (:issue:`55608`)\n- Bug in addition or subtraction of :class:`DateOffset` objects with microsecond components to ``datetime64`` :class:`Index`, :class:`Series`, or :class:`DataFrame` columns with non-nanosecond resolution (:issue:`55595`)\n- Bug in addition or subtraction of very large :class:`.Tick` objects with :class:`Timestamp` or :class:`Timedelta` objects raising ``OverflowError`` instead of ``OutOfBoundsTimedelta`` (:issue:`55503`)\n- Bug in creating a :class:`Index`, :class:`Series`, or :class:`DataFrame` with a non-nanosecond :class:`DatetimeTZDtype` and inputs that would be out of bounds with nanosecond resolution incorrectly raising ``OutOfBoundsDatetime`` (:issue:`54620`)\n- Bug in creating a :class:`Index`, :class:`Series`, or :class:`DataFrame` with a non-nanosecond ``datetime64`` (or :class:`DatetimeTZDtype`) from mixed-numeric inputs treating those as nanoseconds instead of as multiples of the dtype's unit (which would happen with non-mixed numeric inputs) (:issue:`56004`)\n- Bug in creating a :class:`Index`, :class:`Series`, or :class:`DataFrame` with a non-nanosecond ``datetime64`` dtype and inputs that would be out of bounds for a ``datetime64[ns]`` incorrectly raising ``OutOfBoundsDatetime`` (:issue:`55756`)\n- Bug in parsing datetime strings with nanosecond resolution with non-ISO8601 formats incorrectly truncating sub-microsecond components (:issue:`56051`)\n- Bug in parsing datetime strings with sub-second resolution and trailing zeros incorrectly inferring second or millisecond resolution (:issue:`55737`)\n- Bug in the results of :func:`to_datetime` with an floating-dtype argument with ``unit`` not matching the pointwise results of :class:`Timestamp` (:issue:`56037`)\n- Fixed regression where :func:`concat` would raise an error when concatenating ``datetime64`` columns with differing resolutions (:issue:`53641`)\n\nTimedelta\n^^^^^^^^^\n- Bug in :class:`Timedelta` construction raising ``OverflowError`` instead of ``OutOfBoundsTimedelta`` (:issue:`55503`)\n- Bug in rendering (``__repr__``) of :class:`TimedeltaIndex` and :class:`Series` with timedelta64 values with non-nanosecond resolution entries that are all multiples of 24 hours failing to use the compact representation used in the nanosecond cases (:issue:`55405`)\n\nTimezones\n^^^^^^^^^\n- Bug in :class:`AbstractHolidayCalendar` where timezone data was not propagated when computing holiday observances (:issue:`54580`)\n- Bug in :class:`Timestamp` construction with an ambiguous value and a ``pytz`` timezone failing to raise ``pytz.AmbiguousTimeError`` (:issue:`55657`)\n- Bug in :meth:`Timestamp.tz_localize` with ``nonexistent=\"shift_forward`` around UTC+0 during DST (:issue:`51501`)\n\nNumeric\n^^^^^^^\n- Bug in :func:`read_csv` with ``engine=\"pyarrow\"`` causing rounding errors for large integers (:issue:`52505`)\n- Bug in :meth:`Series.__floordiv__` and :meth:`Series.__truediv__` for :class:`ArrowDtype` with integral dtypes raising for large divisors (:issue:`56706`)\n- Bug in :meth:`Series.__floordiv__` for :class:`ArrowDtype` with integral dtypes raising for large values (:issue:`56645`)\n- Bug in :meth:`Series.pow` not filling missing values correctly (:issue:`55512`)\n- Bug in :meth:`Series.replace` and :meth:`DataFrame.replace` matching float ``0.0`` with ``False`` and vice versa (:issue:`55398`)\n- Bug in :meth:`Series.round` raising for nullable boolean dtype (:issue:`55936`)\n\nConversion\n^^^^^^^^^^\n- Bug in :meth:`DataFrame.astype` when called with ``str`` on unpickled array - the array might change in-place (:issue:`54654`)\n- Bug in :meth:`DataFrame.astype` where ``errors=\"ignore\"`` had no effect for extension types (:issue:`54654`)\n- Bug in :meth:`Series.convert_dtypes` not converting all NA column to ``null[pyarrow]`` (:issue:`55346`)\n- Bug in :meth:``DataFrame.loc`` was not throwing \"incompatible dtype warning\" (see `PDEP6 <https://pandas.pydata.org/pdeps/0006-ban-upcasting.html>`_) when assigning a ``Series`` with a different dtype using a full column setter (e.g. ``df.loc[:, 'a'] = incompatible_value``) (:issue:`39584`)\n\nStrings\n^^^^^^^\n- Bug in :func:`pandas.api.types.is_string_dtype` while checking object array with no elements is of the string dtype (:issue:`54661`)\n- Bug in :meth:`DataFrame.apply` failing when ``engine=\"numba\"`` and columns or index have ``StringDtype`` (:issue:`56189`)\n- Bug in :meth:`DataFrame.reindex` not matching :class:`Index` with ``string[pyarrow_numpy]`` dtype (:issue:`56106`)\n- Bug in :meth:`Index.str.cat` always casting result to object dtype (:issue:`56157`)\n- Bug in :meth:`Series.__mul__` for :class:`ArrowDtype` with ``pyarrow.string`` dtype and ``string[pyarrow]`` for the pyarrow backend (:issue:`51970`)\n- Bug in :meth:`Series.str.find` when ``start < 0`` for :class:`ArrowDtype` with ``pyarrow.string`` (:issue:`56411`)\n- Bug in :meth:`Series.str.fullmatch` when ``dtype=pandas.ArrowDtype(pyarrow.string()))`` allows partial matches when regex ends in literal //$ (:issue:`56652`)\n- Bug in :meth:`Series.str.replace` when ``n < 0`` for :class:`ArrowDtype` with ``pyarrow.string`` (:issue:`56404`)\n- Bug in :meth:`Series.str.startswith` and :meth:`Series.str.endswith` with arguments of type ``tuple[str, ...]`` for :class:`ArrowDtype` with ``pyarrow.string`` dtype (:issue:`56579`)\n- Bug in :meth:`Series.str.startswith` and :meth:`Series.str.endswith` with arguments of type ``tuple[str, ...]`` for ``string[pyarrow]`` (:issue:`54942`)\n- Bug in comparison operations for ``dtype=\"string[pyarrow_numpy]\"`` raising if dtypes can't be compared (:issue:`56008`)\n\nInterval\n^^^^^^^^\n- Bug in :class:`Interval` ``__repr__`` not displaying UTC offsets for :class:`Timestamp` bounds. Additionally the hour, minute and second components will now be shown (:issue:`55015`)\n- Bug in :meth:`IntervalIndex.factorize` and :meth:`Series.factorize` with :class:`IntervalDtype` with datetime64 or timedelta64 intervals not preserving non-nanosecond units (:issue:`56099`)\n- Bug in :meth:`IntervalIndex.from_arrays` when passed ``datetime64`` or ``timedelta64`` arrays with mismatched resolutions constructing an invalid ``IntervalArray`` object (:issue:`55714`)\n- Bug in :meth:`IntervalIndex.from_tuples` raising if subtype is a nullable extension dtype (:issue:`56765`)\n- Bug in :meth:`IntervalIndex.get_indexer` with datetime or timedelta intervals incorrectly matching on integer targets (:issue:`47772`)\n- Bug in :meth:`IntervalIndex.get_indexer` with timezone-aware datetime intervals incorrectly matching on a sequence of timezone-naive targets (:issue:`47772`)\n- Bug in setting values on a :class:`Series` with an :class:`IntervalIndex` using a slice incorrectly raising (:issue:`54722`)\n\nIndexing\n^^^^^^^^\n- Bug in :meth:`DataFrame.loc` mutating a boolean indexer when :class:`DataFrame` has a :class:`MultiIndex` (:issue:`56635`)\n- Bug in :meth:`DataFrame.loc` when setting :class:`Series` with extension dtype into NumPy dtype (:issue:`55604`)\n- Bug in :meth:`Index.difference` not returning a unique set of values when ``other`` is empty or ``other`` is considered non-comparable (:issue:`55113`)\n- Bug in setting :class:`Categorical` values into a :class:`DataFrame` with numpy dtypes raising ``RecursionError`` (:issue:`52927`)\n- Fixed bug when creating new column with missing values when setting a single string value (:issue:`56204`)\n\nMissing\n^^^^^^^\n- Bug in :meth:`DataFrame.update` wasn't updating in-place for tz-aware datetime64 dtypes (:issue:`56227`)\n\nMultiIndex\n^^^^^^^^^^\n- Bug in :meth:`MultiIndex.get_indexer` not raising ``ValueError`` when ``method`` provided and index is non-monotonic (:issue:`53452`)\n\nI/O\n^^^\n- Bug in :func:`read_csv` where ``engine=\"python\"`` did not respect ``chunksize`` arg when ``skiprows`` was specified (:issue:`56323`)\n- Bug in :func:`read_csv` where ``engine=\"python\"`` was causing a ``TypeError`` when a callable ``skiprows`` and a chunk size was specified (:issue:`55677`)\n- Bug in :func:`read_csv` where ``on_bad_lines=\"warn\"`` would write to ``stderr`` instead of raising a Python warning; this now yields a :class:`.errors.ParserWarning` (:issue:`54296`)\n- Bug in :func:`read_csv` with ``engine=\"pyarrow\"`` where ``quotechar`` was ignored (:issue:`52266`)\n- Bug in :func:`read_csv` with ``engine=\"pyarrow\"`` where ``usecols`` wasn't working with a CSV with no headers (:issue:`54459`)\n- Bug in :func:`read_excel`, with ``engine=\"xlrd\"`` (``xls`` files) erroring when the file contains ``NaN`` or ``Inf`` (:issue:`54564`)\n- Bug in :func:`read_json` not handling dtype conversion properly if ``infer_string`` is set (:issue:`56195`)\n- Bug in :meth:`DataFrame.to_excel`, with ``OdsWriter`` (``ods`` files) writing Boolean/string value (:issue:`54994`)\n- Bug in :meth:`DataFrame.to_hdf` and :func:`read_hdf` with ``datetime64`` dtypes with non-nanosecond resolution failing to round-trip correctly (:issue:`55622`)\n- Bug in :meth:`DataFrame.to_stata` raising for extension dtypes (:issue:`54671`)\n- Bug in :meth:`~pandas.read_excel` with ``engine=\"odf\"`` (``ods`` files) when a string cell contains an annotation (:issue:`55200`)\n- Bug in :meth:`~pandas.read_excel` with an ODS file without cached formatted cell for float values (:issue:`55219`)\n- Bug where :meth:`DataFrame.to_json` would raise an ``OverflowError`` instead of a ``TypeError`` with unsupported NumPy types (:issue:`55403`)\n\nPeriod\n^^^^^^\n- Bug in :class:`PeriodIndex` construction when more than one of ``data``, ``ordinal`` and ``**fields`` are passed failing to raise ``ValueError`` (:issue:`55961`)\n- Bug in :class:`Period` addition silently wrapping around instead of raising ``OverflowError`` (:issue:`55503`)\n- Bug in casting from :class:`PeriodDtype` with ``astype`` to ``datetime64`` or :class:`DatetimeTZDtype` with non-nanosecond unit incorrectly returning with nanosecond unit (:issue:`55958`)\n\nPlotting\n^^^^^^^^\n- Bug in :meth:`DataFrame.plot.box` with ``vert=False`` and a Matplotlib ``Axes`` created with ``sharey=True`` (:issue:`54941`)\n- Bug in :meth:`DataFrame.plot.scatter` discarding string columns (:issue:`56142`)\n- Bug in :meth:`Series.plot` when reusing an ``ax`` object failing to raise when a ``how`` keyword is passed (:issue:`55953`)\n\nGroupby/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n- Bug in :meth:`.DataFrameGroupBy.idxmin`, :meth:`.DataFrameGroupBy.idxmax`, :meth:`.SeriesGroupBy.idxmin`, and :meth:`.SeriesGroupBy.idxmax` would not retain :class:`.Categorical` dtype when the index was a :class:`.CategoricalIndex` that contained NA values (:issue:`54234`)\n- Bug in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` when ``observed=False`` and ``f=\"idxmin\"`` or ``f=\"idxmax\"`` would incorrectly raise on unobserved categories (:issue:`54234`)\n- Bug in :meth:`.DataFrameGroupBy.value_counts` and :meth:`.SeriesGroupBy.value_counts` could result in incorrect sorting if the columns of the DataFrame or name of the Series are integers (:issue:`55951`)\n- Bug in :meth:`.DataFrameGroupBy.value_counts` and :meth:`.SeriesGroupBy.value_counts` would not respect ``sort=False`` in :meth:`DataFrame.groupby` and :meth:`Series.groupby` (:issue:`55951`)\n- Bug in :meth:`.DataFrameGroupBy.value_counts` and :meth:`.SeriesGroupBy.value_counts` would sort by proportions rather than frequencies when ``sort=True`` and ``normalize=True`` (:issue:`55951`)\n- Bug in :meth:`DataFrame.asfreq` and :meth:`Series.asfreq` with a :class:`DatetimeIndex` with non-nanosecond resolution incorrectly converting to nanosecond resolution (:issue:`55958`)\n- Bug in :meth:`DataFrame.ewm` when passed ``times`` with non-nanosecond ``datetime64`` or :class:`DatetimeTZDtype` dtype (:issue:`56262`)\n- Bug in :meth:`DataFrame.groupby` and :meth:`Series.groupby` where grouping by a combination of ``Decimal`` and NA values would fail when ``sort=True`` (:issue:`54847`)\n- Bug in :meth:`DataFrame.groupby` for DataFrame subclasses when selecting a subset of columns to apply the function to (:issue:`56761`)\n- Bug in :meth:`DataFrame.resample` not respecting ``closed`` and ``label`` arguments for :class:`~pandas.tseries.offsets.BusinessDay` (:issue:`55282`)\n- Bug in :meth:`DataFrame.resample` when resampling on a :class:`ArrowDtype` of ``pyarrow.timestamp`` or ``pyarrow.duration`` type (:issue:`55989`)\n- Bug in :meth:`DataFrame.resample` where bin edges were not correct for :class:`~pandas.tseries.offsets.BusinessDay` (:issue:`55281`)\n- Bug in :meth:`DataFrame.resample` where bin edges were not correct for :class:`~pandas.tseries.offsets.MonthBegin` (:issue:`55271`)\n- Bug in :meth:`DataFrame.rolling` and :meth:`Series.rolling` where duplicate datetimelike indexes are treated as consecutive rather than equal with ``closed='left'`` and ``closed='neither'`` (:issue:`20712`)\n- Bug in :meth:`DataFrame.rolling` and :meth:`Series.rolling` where either the ``index`` or ``on`` column was :class:`ArrowDtype` with ``pyarrow.timestamp`` type (:issue:`55849`)\n\nReshaping\n^^^^^^^^^\n- Bug in :func:`concat` ignoring ``sort`` parameter when passed :class:`DatetimeIndex` indexes (:issue:`54769`)\n- Bug in :func:`concat` renaming :class:`Series` when ``ignore_index=False`` (:issue:`15047`)\n- Bug in :func:`merge_asof` raising ``TypeError`` when ``by`` dtype is not ``object``, ``int64``, or ``uint64`` (:issue:`22794`)\n- Bug in :func:`merge_asof` raising incorrect error for string dtype (:issue:`56444`)\n- Bug in :func:`merge_asof` when using a :class:`Timedelta` tolerance on a :class:`ArrowDtype` column (:issue:`56486`)\n- Bug in :func:`merge` not raising when merging datetime columns with timedelta columns (:issue:`56455`)\n- Bug in :func:`merge` not raising when merging string columns with numeric columns (:issue:`56441`)\n- Bug in :func:`merge` not sorting for new string dtype (:issue:`56442`)\n- Bug in :func:`merge` returning columns in incorrect order when left and/or right is empty (:issue:`51929`)\n- Bug in :meth:`DataFrame.melt` where an exception was raised if ``var_name`` was not a string (:issue:`55948`)\n- Bug in :meth:`DataFrame.melt` where it would not preserve the datetime (:issue:`55254`)\n- Bug in :meth:`DataFrame.pivot_table` where the row margin is incorrect when the columns have numeric names (:issue:`26568`)\n- Bug in :meth:`DataFrame.pivot` with numeric columns and extension dtype for data (:issue:`56528`)\n- Bug in :meth:`DataFrame.stack` with ``future_stack=True`` would not preserve NA values in the index (:issue:`56573`)\n\nSparse\n^^^^^^\n- Bug in :meth:`arrays.SparseArray.take` when using a different fill value than the array's fill value (:issue:`55181`)\n\nOther\n^^^^^\n- :meth:`DataFrame.__dataframe__` did not support pyarrow large strings (:issue:`56702`)\n- Bug in :func:`DataFrame.describe` when formatting percentiles in the resulting percentile 99.999% is rounded to 100% (:issue:`55765`)\n- Bug in :func:`api.interchange.from_dataframe` where it raised  ``NotImplementedError`` when handling empty string columns (:issue:`56703`)\n- Bug in :func:`cut` and :func:`qcut` with ``datetime64`` dtype values with non-nanosecond units incorrectly returning nanosecond-unit bins (:issue:`56101`)\n- Bug in :func:`cut` incorrectly allowing cutting of timezone-aware datetimes with timezone-naive bins (:issue:`54964`)\n- Bug in :func:`infer_freq` and :meth:`DatetimeIndex.inferred_freq` with weekly frequencies and non-nanosecond resolutions (:issue:`55609`)\n- Bug in :meth:`DataFrame.apply` where passing ``raw=True`` ignored ``args`` passed to the applied function (:issue:`55009`)\n- Bug in :meth:`DataFrame.from_dict` which would always sort the rows of the created :class:`DataFrame`.  (:issue:`55683`)\n- Bug in :meth:`DataFrame.sort_index` when passing ``axis=\"columns\"`` and ``ignore_index=True`` raising a ``ValueError`` (:issue:`56478`)\n- Bug in rendering ``inf`` values inside a :class:`DataFrame` with the ``use_inf_as_na`` option enabled (:issue:`55483`)\n- Bug in rendering a :class:`Series` with a :class:`MultiIndex` when one of the index level's names is 0 not having that name displayed (:issue:`55415`)\n- Bug in the error message when assigning an empty :class:`DataFrame` to a column (:issue:`55956`)\n- Bug when time-like strings were being cast to :class:`ArrowDtype` with ``pyarrow.time64`` type (:issue:`56463`)\n- Fixed a spurious deprecation warning from ``numba`` >= 0.58.0 when passing a numpy ufunc in :class:`core.window.Rolling.apply` with ``engine=\"numba\"`` (:issue:`55247`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_220.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.1.4..v2.2.0\n", "1.4.0": ".. _whatsnew_140:\n\nWhat's new in 1.4.0 (January 22, 2022)\n--------------------------------------\n\nThese are the changes in pandas 1.4.0. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_140.enhancements:\n\nEnhancements\n~~~~~~~~~~~~\n\n.. _whatsnew_140.enhancements.warning_lineno:\n\nImproved warning messages\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously, warning messages may have pointed to lines within the pandas\nlibrary. Running the script ``setting_with_copy_warning.py``\n\n.. code-block:: python\n\n    import pandas as pd\n\n    df = pd.DataFrame({'a': [1, 2, 3]})\n    df[:2].loc[:, 'a'] = 5\n\nwith pandas 1.3 resulted in::\n\n    .../site-packages/pandas/core/indexing.py:1951: SettingWithCopyWarning:\n    A value is trying to be set on a copy of a slice from a DataFrame.\n\nThis made it difficult to determine where the warning was being generated from.\nNow pandas will inspect the call stack, reporting the first line outside of the\npandas library that gave rise to the warning. The output of the above script is\nnow::\n\n    setting_with_copy_warning.py:4: SettingWithCopyWarning:\n    A value is trying to be set on a copy of a slice from a DataFrame.\n\n\n\n\n.. _whatsnew_140.enhancements.ExtensionIndex:\n\nIndex can hold arbitrary ExtensionArrays\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUntil now, passing a custom :class:`ExtensionArray` to ``pd.Index`` would cast\nthe array to ``object`` dtype. Now :class:`Index` can directly hold arbitrary\nExtensionArrays (:issue:`43930`).\n\n*Previous behavior*:\n\n.. ipython:: python\n\n   arr = pd.array([1, 2, pd.NA])\n   idx = pd.Index(arr)\n\nIn the old behavior, ``idx`` would be object-dtype:\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n   In [1]: idx\n   Out[1]: Index([1, 2, <NA>], dtype='object')\n\nWith the new behavior, we keep the original dtype:\n\n*New behavior*:\n\n.. ipython:: python\n\n   idx\n\nOne exception to this is ``SparseArray``, which will continue to cast to numpy\ndtype until pandas 2.0. At that point it will retain its dtype like other\nExtensionArrays.\n\n.. _whatsnew_140.enhancements.styler:\n\nStyler\n^^^^^^\n\n:class:`.Styler` has been further developed in 1.4.0. The following general enhancements have been made:\n\n  - Styling and formatting of indexes has been added, with :meth:`.Styler.apply_index`, :meth:`.Styler.applymap_index` and :meth:`.Styler.format_index`. These mirror the signature of the methods already used to style and format data values, and work with both HTML, LaTeX and Excel format (:issue:`41893`, :issue:`43101`, :issue:`41993`, :issue:`41995`)\n  - The new method :meth:`.Styler.hide` deprecates :meth:`.Styler.hide_index` and :meth:`.Styler.hide_columns` (:issue:`43758`)\n  - The keyword arguments ``level`` and ``names`` have been added to :meth:`.Styler.hide` (and implicitly to the deprecated methods :meth:`.Styler.hide_index` and :meth:`.Styler.hide_columns`) for additional control of visibility of MultiIndexes and of Index names (:issue:`25475`, :issue:`43404`, :issue:`43346`)\n  - The :meth:`.Styler.export` and :meth:`.Styler.use` have been updated to address all of the added functionality from v1.2.0 and v1.3.0 (:issue:`40675`)\n  - Global options under the category ``pd.options.styler`` have been extended to configure default ``Styler`` properties which address formatting, encoding, and HTML and LaTeX rendering. Note that formerly ``Styler`` relied on ``display.html.use_mathjax``, which has now been replaced by ``styler.html.mathjax`` (:issue:`41395`)\n  - Validation of certain keyword arguments, e.g. ``caption`` (:issue:`43368`)\n  - Various bug fixes as recorded below\n\nAdditionally there are specific enhancements to the HTML specific rendering:\n\n  - :meth:`.Styler.bar` introduces additional arguments to control alignment and display (:issue:`26070`, :issue:`36419`), and it also validates the input arguments ``width`` and ``height`` (:issue:`42511`)\n  - :meth:`.Styler.to_html` introduces keyword arguments ``sparse_index``, ``sparse_columns``, ``bold_headers``, ``caption``, ``max_rows`` and ``max_columns`` (:issue:`41946`, :issue:`43149`, :issue:`42972`)\n  - :meth:`.Styler.to_html` omits CSSStyle rules for hidden table elements as a performance enhancement (:issue:`43619`)\n  - Custom CSS classes can now be directly specified without string replacement (:issue:`43686`)\n  - Ability to render hyperlinks automatically via a new ``hyperlinks`` formatting keyword argument (:issue:`45058`)\n\nThere are also some LaTeX specific enhancements:\n\n  - :meth:`.Styler.to_latex` introduces keyword argument ``environment``, which also allows a specific \"longtable\" entry through a separate jinja2 template (:issue:`41866`)\n  - Naive sparsification is now possible for LaTeX without the necessity of including the multirow package (:issue:`43369`)\n  - *cline* support has been added for :class:`MultiIndex` row sparsification through a keyword argument (:issue:`45138`)\n\n.. _whatsnew_140.enhancements.pyarrow_csv_engine:\n\nMulti-threaded CSV reading with a new CSV Engine based on pyarrow\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:func:`pandas.read_csv` now accepts ``engine=\"pyarrow\"`` (requires at least\n``pyarrow`` 1.0.1) as an argument, allowing for faster csv parsing on multicore\nmachines with pyarrow installed. See the :doc:`I/O docs </user_guide/io>` for\nmore info. (:issue:`23697`, :issue:`43706`)\n\n.. _whatsnew_140.enhancements.window_rank:\n\nRank function for rolling and expanding windows\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAdded ``rank`` function to :class:`Rolling` and :class:`Expanding`. The new\nfunction supports the ``method``, ``ascending``, and ``pct`` flags of\n:meth:`DataFrame.rank`. The ``method`` argument supports ``min``, ``max``, and\n``average`` ranking methods.\nExample:\n\n.. ipython:: python\n\n    s = pd.Series([1, 4, 2, 3, 5, 3])\n    s.rolling(3).rank()\n\n    s.rolling(3).rank(method=\"max\")\n\n.. _whatsnew_140.enhancements.groupby_indexing:\n\nGroupby positional indexing\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIt is now possible to specify positional ranges relative to the ends of each\ngroup.\n\nNegative arguments for :meth:`.DataFrameGroupBy.head`, :meth:`.SeriesGroupBy.head`, :meth:`.DataFrameGroupBy.tail`, and :meth:`.SeriesGroupBy.tail` now work\ncorrectly and result in ranges relative to the end and start of each group,\nrespectively. Previously, negative arguments returned empty frames.\n\n.. ipython:: python\n\n    df = pd.DataFrame([[\"g\", \"g0\"], [\"g\", \"g1\"], [\"g\", \"g2\"], [\"g\", \"g3\"],\n                       [\"h\", \"h0\"], [\"h\", \"h1\"]], columns=[\"A\", \"B\"])\n    df.groupby(\"A\").head(-1)\n\n\n:meth:`.DataFrameGroupBy.nth` and :meth:`.SeriesGroupBy.nth` now accept a slice or list of integers and slices.\n\n.. ipython:: python\n\n    df.groupby(\"A\").nth(slice(1, -1))\n    df.groupby(\"A\").nth([slice(None, 1), slice(-1, None)])\n\n:meth:`.DataFrameGroupBy.nth` and :meth:`.SeriesGroupBy.nth` now accept index notation.\n\n.. ipython:: python\n\n    df.groupby(\"A\").nth[1, -1]\n    df.groupby(\"A\").nth[1:-1]\n    df.groupby(\"A\").nth[:1, -1:]\n\n.. _whatsnew_140.dict_tight:\n\nDataFrame.from_dict and DataFrame.to_dict have new ``'tight'`` option\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA new ``'tight'`` dictionary format that preserves :class:`MultiIndex` entries\nand names is now available with the :meth:`DataFrame.from_dict` and\n:meth:`DataFrame.to_dict` methods and can be used with the standard ``json``\nlibrary to produce a tight representation of :class:`DataFrame` objects\n(:issue:`4889`).\n\n.. ipython:: python\n\n    df = pd.DataFrame.from_records(\n        [[1, 3], [2, 4]],\n        index=pd.MultiIndex.from_tuples([(\"a\", \"b\"), (\"a\", \"c\")],\n                                        names=[\"n1\", \"n2\"]),\n        columns=pd.MultiIndex.from_tuples([(\"x\", 1), (\"y\", 2)],\n                                          names=[\"z1\", \"z2\"]),\n    )\n    df\n    df.to_dict(orient='tight')\n\n.. _whatsnew_140.enhancements.other:\n\nOther enhancements\n^^^^^^^^^^^^^^^^^^\n- :meth:`concat` will preserve the ``attrs`` when it is the same for all objects and discard the ``attrs`` when they are different (:issue:`41828`)\n- :class:`DataFrameGroupBy` operations with ``as_index=False`` now correctly retain ``ExtensionDtype`` dtypes for columns being grouped on (:issue:`41373`)\n- Add support for assigning values to ``by`` argument in :meth:`DataFrame.plot.hist` and :meth:`DataFrame.plot.box` (:issue:`15079`)\n- :meth:`Series.sample`, :meth:`DataFrame.sample`, :meth:`.DataFrameGroupBy.sample`, and :meth:`.SeriesGroupBy.sample` now accept a ``np.random.Generator`` as input to ``random_state``. A generator will be more performant, especially with ``replace=False`` (:issue:`38100`)\n- :meth:`Series.ewm` and :meth:`DataFrame.ewm` now support a ``method`` argument with a ``'table'`` option that performs the windowing operation over an entire :class:`DataFrame`. See :ref:`Window Overview <window.overview>` for performance and functional benefits (:issue:`42273`)\n- :meth:`.DataFrameGroupBy.cummin`, :meth:`.SeriesGroupBy.cummin`, :meth:`.DataFrameGroupBy.cummax`, and :meth:`.SeriesGroupBy.cummax` now support the argument ``skipna`` (:issue:`34047`)\n- :meth:`read_table` now supports the argument ``storage_options`` (:issue:`39167`)\n- :meth:`DataFrame.to_stata` and :meth:`StataWriter` now accept the keyword only argument ``value_labels`` to save labels for non-categorical columns (:issue:`38454`)\n- Methods that relied on hashmap based algos such as :meth:`DataFrameGroupBy.value_counts`, :meth:`DataFrameGroupBy.count` and :func:`factorize` ignored imaginary component for complex numbers (:issue:`17927`)\n- Add :meth:`Series.str.removeprefix` and :meth:`Series.str.removesuffix` introduced in Python 3.9 to remove pre-/suffixes from string-type :class:`Series` (:issue:`36944`)\n- Attempting to write into a file in missing parent directory with :meth:`DataFrame.to_csv`, :meth:`DataFrame.to_html`, :meth:`DataFrame.to_excel`, :meth:`DataFrame.to_feather`, :meth:`DataFrame.to_parquet`, :meth:`DataFrame.to_stata`, :meth:`DataFrame.to_json`, :meth:`DataFrame.to_pickle`, and :meth:`DataFrame.to_xml` now explicitly mentions missing parent directory, the same is true for :class:`Series` counterparts (:issue:`24306`)\n- Indexing with ``.loc`` and ``.iloc`` now supports ``Ellipsis`` (:issue:`37750`)\n- :meth:`IntegerArray.all` , :meth:`IntegerArray.any`, :meth:`FloatingArray.any`, and :meth:`FloatingArray.all` use Kleene logic (:issue:`41967`)\n- Added support for nullable boolean and integer types in :meth:`DataFrame.to_stata`, :class:`~pandas.io.stata.StataWriter`, :class:`~pandas.io.stata.StataWriter117`, and :class:`~pandas.io.stata.StataWriterUTF8` (:issue:`40855`)\n- :meth:`DataFrame.__pos__` and :meth:`DataFrame.__neg__` now retain ``ExtensionDtype`` dtypes (:issue:`43883`)\n- The error raised when an optional dependency can't be imported now includes the original exception, for easier investigation (:issue:`43882`)\n- Added :meth:`.ExponentialMovingWindow.sum` (:issue:`13297`)\n- :meth:`Series.str.split` now supports a ``regex`` argument that explicitly specifies whether the pattern is a regular expression. Default is ``None`` (:issue:`43563`, :issue:`32835`, :issue:`25549`)\n- :meth:`DataFrame.dropna` now accepts a single label as ``subset`` along with array-like (:issue:`41021`)\n- Added :meth:`DataFrameGroupBy.value_counts` (:issue:`43564`)\n- :func:`read_csv` now accepts a ``callable`` function in ``on_bad_lines`` when ``engine=\"python\"`` for custom handling of bad lines (:issue:`5686`)\n- :class:`ExcelWriter` argument ``if_sheet_exists=\"overlay\"`` option added (:issue:`40231`)\n- :meth:`read_excel` now accepts a ``decimal`` argument that allow the user to specify the decimal point when parsing string columns to numeric (:issue:`14403`)\n- :meth:`.DataFrameGroupBy.mean`, :meth:`.SeriesGroupBy.mean`, :meth:`.DataFrameGroupBy.std`, :meth:`.SeriesGroupBy.std`, :meth:`.DataFrameGroupBy.var`, :meth:`.SeriesGroupBy.var`, :meth:`.DataFrameGroupBy.sum`, and :meth:`.SeriesGroupBy.sum` now support `Numba <http://numba.pydata.org/>`_ execution with the ``engine`` keyword (:issue:`43731`, :issue:`44862`, :issue:`44939`)\n- :meth:`Timestamp.isoformat` now handles the ``timespec`` argument from the base ``datetime`` class (:issue:`26131`)\n- :meth:`NaT.to_numpy` ``dtype`` argument is now respected, so ``np.timedelta64`` can be returned (:issue:`44460`)\n- New option ``display.max_dir_items`` customizes the number of columns added to :meth:`Dataframe.__dir__` and suggested for tab completion (:issue:`37996`)\n- Added \"Juneteenth National Independence Day\" to ``USFederalHolidayCalendar`` (:issue:`44574`)\n- :meth:`.Rolling.var`, :meth:`.Expanding.var`, :meth:`.Rolling.std`, and :meth:`.Expanding.std` now support `Numba <http://numba.pydata.org/>`_ execution with the ``engine`` keyword (:issue:`44461`)\n- :meth:`Series.info` has been added, for compatibility with :meth:`DataFrame.info` (:issue:`5167`)\n- Implemented :meth:`IntervalArray.min` and :meth:`IntervalArray.max`, as a result of which ``min`` and ``max`` now work for :class:`IntervalIndex`, :class:`Series` and :class:`DataFrame` with ``IntervalDtype`` (:issue:`44746`)\n- :meth:`UInt64Index.map` now retains ``dtype`` where possible (:issue:`44609`)\n- :meth:`read_json` can now parse unsigned long long integers (:issue:`26068`)\n- :meth:`DataFrame.take` now raises a ``TypeError`` when passed a scalar for the indexer (:issue:`42875`)\n- :meth:`is_list_like` now identifies duck-arrays as list-like unless ``.ndim == 0`` (:issue:`35131`)\n- :class:`ExtensionDtype` and :class:`ExtensionArray` are now (de)serialized when exporting a :class:`DataFrame` with :meth:`DataFrame.to_json` using ``orient='table'`` (:issue:`20612`, :issue:`44705`)\n- Add support for `Zstandard <http://facebook.github.io/zstd/>`_ compression to :meth:`DataFrame.to_pickle`/:meth:`read_pickle` and friends (:issue:`43925`)\n- :meth:`DataFrame.to_sql` now returns an ``int`` of the number of written rows (:issue:`23998`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_140.notable_bug_fixes:\n\nNotable bug fixes\n~~~~~~~~~~~~~~~~~\n\nThese are bug fixes that might have notable behavior changes.\n\n.. _whatsnew_140.notable_bug_fixes.inconsistent_date_string_parsing:\n\nInconsistent date string parsing\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``dayfirst`` option of :func:`to_datetime` isn't strict, and this can lead\nto surprising behavior:\n\n.. ipython:: python\n    :okwarning:\n\n    pd.to_datetime([\"31-12-2021\"], dayfirst=False)\n\nNow, a warning will be raised if a date string cannot be parsed accordance to\nthe given ``dayfirst`` value when the value is a delimited date string (e.g.\n``31-12-2012``).\n\n.. _whatsnew_140.notable_bug_fixes.concat_with_empty_or_all_na:\n\nIgnoring dtypes in concat with empty or all-NA columns\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. note::\n    This behaviour change has been reverted in pandas 1.4.3.\n\nWhen using :func:`concat` to concatenate two or more :class:`DataFrame` objects,\nif one of the DataFrames was empty or had all-NA values, its dtype was\n*sometimes* ignored when finding the concatenated dtype.  These are now\nconsistently *not* ignored (:issue:`43507`).\n\n.. code-block:: ipython\n\n    In [3]: df1 = pd.DataFrame({\"bar\": [pd.Timestamp(\"2013-01-01\")]}, index=range(1))\n    In [4]: df2 = pd.DataFrame({\"bar\": np.nan}, index=range(1, 2))\n    In [5]: res = pd.concat([df1, df2])\n\nPreviously, the float-dtype in ``df2`` would be ignored so the result dtype\nwould be ``datetime64[ns]``. As a result, the ``np.nan`` would be cast to\n``NaT``.\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [6]: res\n    Out[6]:\n             bar\n    0 2013-01-01\n    1        NaT\n\nNow the float-dtype is respected. Since the common dtype for these DataFrames is\nobject, the ``np.nan`` is retained.\n\n*New behavior*:\n\n.. code-block:: ipython\n\n    In [6]: res\n    Out[6]:\n                       bar\n    0  2013-01-01 00:00:00\n    1                  NaN\n\n\n\n.. _whatsnew_140.notable_bug_fixes.value_counts_and_mode_do_not_coerce_to_nan:\n\nNull-values are no longer coerced to NaN-value in value_counts and mode\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`Series.value_counts` and :meth:`Series.mode` no longer coerce ``None``,\n``NaT`` and other null-values to a NaN-value for ``np.object_``-dtype. This\nbehavior is now consistent with ``unique``, ``isin`` and others\n(:issue:`42688`).\n\n.. ipython:: python\n\n    s = pd.Series([True, None, pd.NaT, None, pd.NaT, None])\n    res = s.value_counts(dropna=False)\n\nPreviously, all null-values were replaced by a NaN-value.\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [3]: res\n    Out[3]:\n    NaN     5\n    True    1\n    dtype: int64\n\nNow null-values are no longer mangled.\n\n*New behavior*:\n\n.. ipython:: python\n\n    res\n\n.. _whatsnew_140.notable_bug_fixes.read_csv_mangle_dup_cols:\n\nmangle_dupe_cols in read_csv no longer renames unique columns conflicting with target names\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:func:`read_csv` no longer renames unique column labels which conflict with the target\nnames of duplicated columns. Already existing columns are skipped, i.e. the next\navailable index is used for the target column name (:issue:`14704`).\n\n.. ipython:: python\n\n    import io\n\n    data = \"a,a,a.1\\n1,2,3\"\n    res = pd.read_csv(io.StringIO(data))\n\nPreviously, the second column was called ``a.1``, while the third column was\nalso renamed to ``a.1.1``.\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [3]: res\n    Out[3]:\n        a  a.1  a.1.1\n    0   1    2      3\n\nNow the renaming checks if ``a.1`` already exists when changing the name of the\nsecond column and jumps this index. The second column is instead renamed to\n``a.2``.\n\n*New behavior*:\n\n.. ipython:: python\n\n    res\n\n.. _whatsnew_140.notable_bug_fixes.unstack_pivot_int32_limit:\n\nunstack and pivot_table no longer raises ValueError for result that would exceed int32 limit\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPreviously :meth:`DataFrame.pivot_table` and :meth:`DataFrame.unstack` would\nraise a ``ValueError`` if the operation could produce a result with more than\n``2**31 - 1`` elements. This operation now raises a\n:class:`errors.PerformanceWarning` instead (:issue:`26314`).\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [3]: df = DataFrame({\"ind1\": np.arange(2 ** 16), \"ind2\": np.arange(2 ** 16), \"count\": 0})\n    In [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\n    ValueError: Unstacked DataFrame is too big, causing int32 overflow\n\n*New behavior*:\n\n.. code-block:: python\n\n    In [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\n    PerformanceWarning: The following operation may generate 4294967296 cells in the resulting pandas object.\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_140.notable_bug_fixes.groupby_apply_mutation:\n\ngroupby.apply consistent transform detection\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` are designed to be flexible, allowing users to perform\naggregations, transformations, filters, and use it with user-defined functions\nthat might not fall into any of these categories. As part of this, apply will\nattempt to detect when an operation is a transform, and in such a case, the\nresult will have the same index as the input. In order to determine if the\noperation is a transform, pandas compares the input's index to the result's and\ndetermines if it has been mutated. Previously in pandas 1.3, different code\npaths used different definitions of \"mutated\": some would use Python's ``is``\nwhereas others would test only up to equality.\n\nThis inconsistency has been removed, pandas now tests up to equality.\n\n.. ipython:: python\n\n    def func(x):\n        return x.copy()\n\n    df = pd.DataFrame({'a': [1, 2], 'b': [3, 4], 'c': [5, 6]})\n    df\n\n*Previous behavior*:\n\n.. code-block:: ipython\n\n    In [3]: df.groupby(['a']).apply(func)\n    Out[3]:\n         a  b  c\n    a\n    1 0  1  3  5\n    2 1  2  4  6\n\n    In [4]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\n    Out[4]:\n         c\n    a b\n    1 3  5\n    2 4  6\n\nIn the examples above, the first uses a code path where pandas uses ``is`` and\ndetermines that ``func`` is not a transform whereas the second tests up to\nequality and determines that ``func`` is a transform. In the first case, the\nresult's index is not the same as the input's.\n\n*New behavior*:\n\n.. code-block:: ipython\n\n    In [5]: df.groupby(['a']).apply(func)\n    Out[5]:\n       a  b  c\n    0  1  3  5\n    1  2  4  6\n\n    In [6]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\n    Out[6]:\n         c\n    a b\n    1 3  5\n    2 4  6\n\nNow in both cases it is determined that ``func`` is a transform. In each case,\nthe result has the same index as the input.\n\n.. _whatsnew_140.api_breaking:\n\nBackwards incompatible API changes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. _whatsnew_140.api_breaking.python:\n\nIncreased minimum version for Python\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\npandas 1.4.0 supports Python 3.8 and higher.\n\n.. _whatsnew_140.api_breaking.deps:\n\nIncreased minimum versions for dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSome minimum supported versions of dependencies were updated.\nIf installed, we now require:\n\n+-----------------+-----------------+----------+---------+\n| Package         | Minimum Version | Required | Changed |\n+=================+=================+==========+=========+\n| numpy           | 1.18.5          |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| pytz            | 2020.1          |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| python-dateutil | 2.8.1           |    X     |    X    |\n+-----------------+-----------------+----------+---------+\n| bottleneck      | 1.3.1           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| numexpr         | 2.7.1           |          |    X    |\n+-----------------+-----------------+----------+---------+\n| pytest (dev)    | 6.0             |          |         |\n+-----------------+-----------------+----------+---------+\n| mypy (dev)      | 0.930           |          |    X    |\n+-----------------+-----------------+----------+---------+\n\nFor `optional libraries\n<https://pandas.pydata.org/docs/getting_started/install.html>`_ the general\nrecommendation is to use the latest version. The following table lists the\nlowest version per library that is currently being tested throughout the\ndevelopment of pandas. Optional libraries below the lowest tested version may\nstill work, but are not considered supported.\n\n+-----------------+-----------------+---------+\n| Package         | Minimum Version | Changed |\n+=================+=================+=========+\n| beautifulsoup4  | 4.8.2           |    X    |\n+-----------------+-----------------+---------+\n| fastparquet     | 0.4.0           |         |\n+-----------------+-----------------+---------+\n| fsspec          | 0.7.4           |         |\n+-----------------+-----------------+---------+\n| gcsfs           | 0.6.0           |         |\n+-----------------+-----------------+---------+\n| lxml            | 4.5.0           |    X    |\n+-----------------+-----------------+---------+\n| matplotlib      | 3.3.2           |    X    |\n+-----------------+-----------------+---------+\n| numba           | 0.50.1          |    X    |\n+-----------------+-----------------+---------+\n| openpyxl        | 3.0.3           |    X    |\n+-----------------+-----------------+---------+\n| pandas-gbq      | 0.14.0          |    X    |\n+-----------------+-----------------+---------+\n| pyarrow         | 1.0.1           |    X    |\n+-----------------+-----------------+---------+\n| pymysql         | 0.10.1          |    X    |\n+-----------------+-----------------+---------+\n| pytables        | 3.6.1           |    X    |\n+-----------------+-----------------+---------+\n| s3fs            | 0.4.0           |         |\n+-----------------+-----------------+---------+\n| scipy           | 1.4.1           |    X    |\n+-----------------+-----------------+---------+\n| sqlalchemy      | 1.4.0           |    X    |\n+-----------------+-----------------+---------+\n| tabulate        | 0.8.7           |         |\n+-----------------+-----------------+---------+\n| xarray          | 0.15.1          |    X    |\n+-----------------+-----------------+---------+\n| xlrd            | 2.0.1           |    X    |\n+-----------------+-----------------+---------+\n| xlsxwriter      | 1.2.2           |    X    |\n+-----------------+-----------------+---------+\n| xlwt            | 1.3.0           |         |\n+-----------------+-----------------+---------+\n\nSee :ref:`install.dependencies` and :ref:`install.optional_dependencies` for more.\n\n.. _whatsnew_140.api_breaking.other:\n\nOther API changes\n^^^^^^^^^^^^^^^^^\n- :meth:`Index.get_indexer_for` no longer accepts keyword arguments (other than ``target``); in the past these would be silently ignored if the index was not unique (:issue:`42310`)\n- Change in the position of the ``min_rows`` argument in :meth:`DataFrame.to_string` due to change in the docstring (:issue:`44304`)\n- Reduction operations for :class:`DataFrame` or :class:`Series` now raising a ``ValueError`` when ``None`` is passed for ``skipna`` (:issue:`44178`)\n- :func:`read_csv` and :func:`read_html` no longer raising an error when one of the header rows consists only of ``Unnamed:`` columns (:issue:`13054`)\n- Changed the ``name`` attribute of several holidays in\n  ``USFederalHolidayCalendar`` to match `official federal holiday\n  names <https://www.opm.gov/policy-data-oversight/pay-leave/federal-holidays/>`_\n  specifically:\n\n   - \"New Year's Day\" gains the possessive apostrophe\n   - \"Presidents Day\" becomes \"Washington's Birthday\"\n   - \"Martin Luther King Jr. Day\" is now \"Birthday of Martin Luther King, Jr.\"\n   - \"July 4th\" is now \"Independence Day\"\n   - \"Thanksgiving\" is now \"Thanksgiving Day\"\n   - \"Christmas\" is now \"Christmas Day\"\n   - Added \"Juneteenth National Independence Day\"\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_140.deprecations:\n\nDeprecations\n~~~~~~~~~~~~\n\n.. _whatsnew_140.deprecations.int64_uint64_float64index:\n\nDeprecated Int64Index, UInt64Index & Float64Index\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:class:`Int64Index`, :class:`UInt64Index` and :class:`Float64Index` have been\ndeprecated in favor of the base :class:`Index` class and will be removed in\nPandas 2.0 (:issue:`43028`).\n\nFor constructing a numeric index, you can use the base :class:`Index` class\ninstead specifying the data type (which will also work on older pandas\nreleases):\n\n.. code-block:: python\n\n    # replace\n    pd.Int64Index([1, 2, 3])\n    # with\n    pd.Index([1, 2, 3], dtype=\"int64\")\n\nFor checking the data type of an index object, you can replace ``isinstance``\nchecks with checking the ``dtype``:\n\n.. code-block:: python\n\n    # replace\n    isinstance(idx, pd.Int64Index)\n    # with\n    idx.dtype == \"int64\"\n\nCurrently, in order to maintain backward compatibility, calls to :class:`Index`\nwill continue to return :class:`Int64Index`, :class:`UInt64Index` and\n:class:`Float64Index` when given numeric data, but in the future, an\n:class:`Index` will be returned.\n\n*Current behavior*:\n\n.. code-block:: ipython\n\n    In [1]: pd.Index([1, 2, 3], dtype=\"int32\")\n    Out [1]: Int64Index([1, 2, 3], dtype='int64')\n    In [1]: pd.Index([1, 2, 3], dtype=\"uint64\")\n    Out [1]: UInt64Index([1, 2, 3], dtype='uint64')\n\n*Future behavior*:\n\n.. code-block:: ipython\n\n    In [3]: pd.Index([1, 2, 3], dtype=\"int32\")\n    Out [3]: Index([1, 2, 3], dtype='int32')\n    In [4]: pd.Index([1, 2, 3], dtype=\"uint64\")\n    Out [4]: Index([1, 2, 3], dtype='uint64')\n\n\n.. _whatsnew_140.deprecations.frame_series_append:\n\nDeprecated DataFrame.append and Series.append\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:meth:`DataFrame.append` and :meth:`Series.append` have been deprecated and will\nbe removed in a future version. Use :func:`pandas.concat` instead (:issue:`35407`).\n\n*Deprecated syntax*\n\n.. code-block:: ipython\n\n    In [1]: pd.Series([1, 2]).append(pd.Series([3, 4])\n    Out [1]:\n    <stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n    0    1\n    1    2\n    0    3\n    1    4\n    dtype: int64\n\n    In [2]: df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\n    In [3]: df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\n    In [4]: df1.append(df2)\n    Out [4]:\n    <stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n       A  B\n    0  1  2\n    1  3  4\n    0  5  6\n    1  7  8\n\n*Recommended syntax*\n\n.. ipython:: python\n\n    pd.concat([pd.Series([1, 2]), pd.Series([3, 4])])\n\n    df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\n    df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\n    pd.concat([df1, df2])\n\n\n.. _whatsnew_140.deprecations.other:\n\nOther Deprecations\n^^^^^^^^^^^^^^^^^^\n- Deprecated :meth:`Index.is_type_compatible` (:issue:`42113`)\n- Deprecated ``method`` argument in :meth:`Index.get_loc`, use ``index.get_indexer([label], method=...)`` instead (:issue:`42269`)\n- Deprecated treating integer keys in :meth:`Series.__setitem__` as positional when the index is a :class:`Float64Index` not containing the key, a :class:`IntervalIndex` with no entries containing the key, or a :class:`MultiIndex` with leading :class:`Float64Index` level not containing the key (:issue:`33469`)\n- Deprecated treating ``numpy.datetime64`` objects as UTC times when passed to the :class:`Timestamp` constructor along with a timezone. In a future version, these will be treated as wall-times. To retain the old behavior, use ``Timestamp(dt64).tz_localize(\"UTC\").tz_convert(tz)`` (:issue:`24559`)\n- Deprecated ignoring missing labels when indexing with a sequence of labels on a level of a :class:`MultiIndex` (:issue:`42351`)\n- Creating an empty :class:`Series` without a ``dtype`` will now raise a more visible ``FutureWarning`` instead of a ``DeprecationWarning`` (:issue:`30017`)\n- Deprecated the ``kind`` argument in :meth:`Index.get_slice_bound`, :meth:`Index.slice_indexer`, and :meth:`Index.slice_locs`; in a future version passing ``kind`` will raise (:issue:`42857`)\n- Deprecated dropping of nuisance columns in :class:`Rolling`, :class:`Expanding`, and :class:`EWM` aggregations (:issue:`42738`)\n- Deprecated :meth:`Index.reindex` with a non-unique :class:`Index` (:issue:`42568`)\n- Deprecated :meth:`.Styler.render` in favor of :meth:`.Styler.to_html` (:issue:`42140`)\n- Deprecated :meth:`.Styler.hide_index` and :meth:`.Styler.hide_columns` in favor of :meth:`.Styler.hide` (:issue:`43758`)\n- Deprecated passing in a string column label into ``times`` in :meth:`DataFrame.ewm` (:issue:`43265`)\n- Deprecated the ``include_start`` and ``include_end`` arguments in :meth:`DataFrame.between_time`; in a future version passing ``include_start`` or ``include_end`` will raise (:issue:`40245`)\n- Deprecated the ``squeeze`` argument to :meth:`read_csv`, :meth:`read_table`, and :meth:`read_excel`. Users should squeeze the :class:`DataFrame` afterwards with ``.squeeze(\"columns\")`` instead (:issue:`43242`)\n- Deprecated the ``index`` argument to :class:`SparseArray` construction (:issue:`23089`)\n- Deprecated the ``closed`` argument in :meth:`date_range` and :meth:`bdate_range` in favor of ``inclusive`` argument; In a future version passing ``closed`` will raise (:issue:`40245`)\n- Deprecated :meth:`.Rolling.validate`, :meth:`.Expanding.validate`, and :meth:`.ExponentialMovingWindow.validate` (:issue:`43665`)\n- Deprecated silent dropping of columns that raised a ``TypeError`` in :class:`Series.transform` and :class:`DataFrame.transform` when used with a dictionary (:issue:`43740`)\n- Deprecated silent dropping of columns that raised a ``TypeError``, ``DataError``, and some cases of ``ValueError`` in :meth:`Series.aggregate`, :meth:`DataFrame.aggregate`, :meth:`Series.groupby.aggregate`, and :meth:`DataFrame.groupby.aggregate` when used with a list (:issue:`43740`)\n- Deprecated casting behavior when setting timezone-aware value(s) into a timezone-aware :class:`Series` or :class:`DataFrame` column when the timezones do not match. Previously this cast to object dtype. In a future version, the values being inserted will be converted to the series or column's existing timezone (:issue:`37605`)\n- Deprecated casting behavior when passing an item with mismatched-timezone to :meth:`DatetimeIndex.insert`, :meth:`DatetimeIndex.putmask`, :meth:`DatetimeIndex.where` :meth:`DatetimeIndex.fillna`, :meth:`Series.mask`, :meth:`Series.where`, :meth:`Series.fillna`, :meth:`Series.shift`, :meth:`Series.replace`, :meth:`Series.reindex` (and :class:`DataFrame` column analogues). In the past this has cast to object ``dtype``. In a future version, these will cast the passed item to the index or series's timezone (:issue:`37605`, :issue:`44940`)\n- Deprecated the ``prefix`` keyword argument in :func:`read_csv` and :func:`read_table`, in a future version the argument will be removed (:issue:`43396`)\n- Deprecated passing non boolean argument to ``sort`` in :func:`concat` (:issue:`41518`)\n- Deprecated passing arguments as positional for :func:`read_fwf` other than ``filepath_or_buffer`` (:issue:`41485`)\n- Deprecated passing arguments as positional for :func:`read_xml` other than ``path_or_buffer`` (:issue:`45133`)\n- Deprecated passing ``skipna=None`` for :meth:`DataFrame.mad` and :meth:`Series.mad`, pass ``skipna=True`` instead (:issue:`44580`)\n- Deprecated the behavior of :func:`to_datetime` with the string \"now\" with ``utc=False``; in a future version this will match ``Timestamp(\"now\")``, which in turn matches :meth:`Timestamp.now` returning the local time (:issue:`18705`)\n- Deprecated :meth:`DateOffset.apply`, use ``offset + other`` instead (:issue:`44522`)\n- Deprecated parameter ``names`` in :meth:`Index.copy` (:issue:`44916`)\n- A deprecation warning is now shown for :meth:`DataFrame.to_latex` indicating the arguments signature may change and emulate more the arguments to :meth:`.Styler.to_latex` in future versions (:issue:`44411`)\n- Deprecated behavior of :func:`concat` between objects with bool-dtype and numeric-dtypes; in a future version these will cast to object dtype instead of coercing bools to numeric values (:issue:`39817`)\n- Deprecated :meth:`Categorical.replace`, use :meth:`Series.replace` instead (:issue:`44929`)\n- Deprecated passing ``set`` or ``dict`` as indexer for :meth:`DataFrame.loc.__setitem__`, :meth:`DataFrame.loc.__getitem__`, :meth:`Series.loc.__setitem__`, :meth:`Series.loc.__getitem__`, :meth:`DataFrame.__getitem__`, :meth:`Series.__getitem__` and :meth:`Series.__setitem__` (:issue:`42825`)\n- Deprecated :meth:`Index.__getitem__` with a bool key; use ``index.values[key]`` to get the old behavior (:issue:`44051`)\n- Deprecated downcasting column-by-column in :meth:`DataFrame.where` with integer-dtypes (:issue:`44597`)\n- Deprecated :meth:`DatetimeIndex.union_many`, use :meth:`DatetimeIndex.union` instead (:issue:`44091`)\n- Deprecated :meth:`.Groupby.pad` in favor of :meth:`.Groupby.ffill` (:issue:`33396`)\n- Deprecated :meth:`.Groupby.backfill` in favor of :meth:`.Groupby.bfill` (:issue:`33396`)\n- Deprecated :meth:`.Resample.pad` in favor of :meth:`.Resample.ffill` (:issue:`33396`)\n- Deprecated :meth:`.Resample.backfill` in favor of :meth:`.Resample.bfill` (:issue:`33396`)\n- Deprecated ``numeric_only=None`` in :meth:`DataFrame.rank`; in a future version ``numeric_only`` must be either ``True`` or ``False`` (the default) (:issue:`45036`)\n- Deprecated the behavior of :meth:`Timestamp.utcfromtimestamp`, in the future it will return a timezone-aware UTC :class:`Timestamp` (:issue:`22451`)\n- Deprecated :meth:`NaT.freq` (:issue:`45071`)\n- Deprecated behavior of :class:`Series` and :class:`DataFrame` construction when passed float-dtype data containing ``NaN`` and an integer dtype ignoring the dtype argument; in a future version this will raise (:issue:`40110`)\n- Deprecated the behaviour of :meth:`Series.to_frame` and :meth:`Index.to_frame` to ignore the ``name`` argument when ``name=None``. Currently, this means to preserve the existing name, but in the future explicitly passing ``name=None`` will set ``None`` as the name of the column in the resulting DataFrame (:issue:`44212`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_140.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- Performance improvement in :meth:`.DataFrameGroupBy.sample` and :meth:`.SeriesGroupBy.sample`, especially when ``weights`` argument provided (:issue:`34483`)\n- Performance improvement when converting non-string arrays to string arrays (:issue:`34483`)\n- Performance improvement in :meth:`.DataFrameGroupBy.transform` and :meth:`.SeriesGroupBy.transform` for user-defined functions (:issue:`41598`)\n- Performance improvement in constructing :class:`DataFrame` objects (:issue:`42631`, :issue:`43142`, :issue:`43147`, :issue:`43307`, :issue:`43144`, :issue:`44826`)\n- Performance improvement in :meth:`.DataFrameGroupBy.shift` and :meth:`.SeriesGroupBy.shift` when ``fill_value`` argument is provided (:issue:`26615`)\n- Performance improvement in :meth:`DataFrame.corr` for ``method=pearson`` on data without missing values (:issue:`40956`)\n- Performance improvement in some :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` operations (:issue:`42992`, :issue:`43578`)\n- Performance improvement in :func:`read_stata` (:issue:`43059`, :issue:`43227`)\n- Performance improvement in :func:`read_sas` (:issue:`43333`)\n- Performance improvement in :meth:`to_datetime` with ``uint`` dtypes (:issue:`42606`)\n- Performance improvement in :meth:`to_datetime` with ``infer_datetime_format`` set to ``True`` (:issue:`43901`)\n- Performance improvement in :meth:`Series.sparse.to_coo` (:issue:`42880`)\n- Performance improvement in indexing with a :class:`UInt64Index` (:issue:`43862`)\n- Performance improvement in indexing with a :class:`Float64Index` (:issue:`43705`)\n- Performance improvement in indexing with a non-unique :class:`Index` (:issue:`43792`)\n- Performance improvement in indexing with a listlike indexer on a :class:`MultiIndex` (:issue:`43370`)\n- Performance improvement in indexing with a :class:`MultiIndex` indexer on another :class:`MultiIndex` (:issue:`43370`)\n- Performance improvement in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` (:issue:`43469`, :issue:`43725`)\n- Performance improvement in :meth:`.DataFrameGroupBy.count` and :meth:`.SeriesGroupBy.count` (:issue:`43730`, :issue:`43694`)\n- Performance improvement in :meth:`.DataFrameGroupBy.any`, :meth:`.SeriesGroupBy.any`, :meth:`.DataFrameGroupBy.all`, and :meth:`.SeriesGroupBy.all` (:issue:`43675`, :issue:`42841`)\n- Performance improvement in :meth:`.DataFrameGroupBy.std` and :meth:`.SeriesGroupBy.std` (:issue:`43115`, :issue:`43576`)\n- Performance improvement in :meth:`.DataFrameGroupBy.cumsum` and :meth:`.SeriesGroupBy.cumsum` (:issue:`43309`)\n- :meth:`SparseArray.min` and :meth:`SparseArray.max` no longer require converting to a dense array (:issue:`43526`)\n- Indexing into a :class:`SparseArray` with a ``slice`` with ``step=1`` no longer requires converting to a dense array (:issue:`43777`)\n- Performance improvement in :meth:`SparseArray.take` with ``allow_fill=False`` (:issue:`43654`)\n- Performance improvement in :meth:`.Rolling.mean`, :meth:`.Expanding.mean`, :meth:`.Rolling.sum`, :meth:`.Expanding.sum`, :meth:`.Rolling.max`, :meth:`.Expanding.max`, :meth:`.Rolling.min` and :meth:`.Expanding.min` with ``engine=\"numba\"`` (:issue:`43612`, :issue:`44176`, :issue:`45170`)\n- Improved performance of :meth:`pandas.read_csv` with ``memory_map=True`` when file encoding is UTF-8 (:issue:`43787`)\n- Performance improvement in :meth:`RangeIndex.sort_values` overriding :meth:`Index.sort_values` (:issue:`43666`)\n- Performance improvement in :meth:`RangeIndex.insert` (:issue:`43988`)\n- Performance improvement in :meth:`Index.insert` (:issue:`43953`)\n- Performance improvement in :meth:`DatetimeIndex.tolist` (:issue:`43823`)\n- Performance improvement in :meth:`DatetimeIndex.union` (:issue:`42353`)\n- Performance improvement in :meth:`Series.nsmallest` (:issue:`43696`)\n- Performance improvement in :meth:`DataFrame.insert` (:issue:`42998`)\n- Performance improvement in :meth:`DataFrame.dropna` (:issue:`43683`)\n- Performance improvement in :meth:`DataFrame.fillna` (:issue:`43316`)\n- Performance improvement in :meth:`DataFrame.values` (:issue:`43160`)\n- Performance improvement in :meth:`DataFrame.select_dtypes` (:issue:`42611`)\n- Performance improvement in :class:`DataFrame` reductions (:issue:`43185`, :issue:`43243`, :issue:`43311`, :issue:`43609`)\n- Performance improvement in :meth:`Series.unstack` and :meth:`DataFrame.unstack` (:issue:`43335`, :issue:`43352`, :issue:`42704`, :issue:`43025`)\n- Performance improvement in :meth:`Series.to_frame` (:issue:`43558`)\n- Performance improvement in :meth:`Series.mad` (:issue:`43010`)\n- Performance improvement in :func:`merge` (:issue:`43332`)\n- Performance improvement in :func:`to_csv` when index column is a datetime and is formatted (:issue:`39413`)\n- Performance improvement in :func:`to_csv` when :class:`MultiIndex` contains a lot of unused levels (:issue:`37484`)\n- Performance improvement in :func:`read_csv` when ``index_col`` was set with a numeric column (:issue:`44158`)\n- Performance improvement in :func:`concat` (:issue:`43354`)\n- Performance improvement in :meth:`SparseArray.__getitem__` (:issue:`23122`)\n- Performance improvement in constructing a :class:`DataFrame` from array-like objects like a ``Pytorch`` tensor (:issue:`44616`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_140.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\nCategorical\n^^^^^^^^^^^\n- Bug in setting dtype-incompatible values into a :class:`Categorical` (or ``Series`` or ``DataFrame`` backed by ``Categorical``) raising ``ValueError`` instead of ``TypeError`` (:issue:`41919`)\n- Bug in :meth:`Categorical.searchsorted` when passing a dtype-incompatible value raising ``KeyError`` instead of ``TypeError`` (:issue:`41919`)\n- Bug in :meth:`Categorical.astype` casting datetimes and :class:`Timestamp` to int for dtype ``object`` (:issue:`44930`)\n- Bug in :meth:`Series.where` with ``CategoricalDtype`` when passing a dtype-incompatible value raising ``ValueError`` instead of ``TypeError`` (:issue:`41919`)\n- Bug in :meth:`Categorical.fillna` when passing a dtype-incompatible value raising ``ValueError`` instead of ``TypeError`` (:issue:`41919`)\n- Bug in :meth:`Categorical.fillna` with a tuple-like category raising ``ValueError`` instead of ``TypeError`` when filling with a non-category tuple (:issue:`41919`)\n\nDatetimelike\n^^^^^^^^^^^^\n- Bug in :class:`DataFrame` constructor unnecessarily copying non-datetimelike 2D object arrays (:issue:`39272`)\n- Bug in :func:`to_datetime` with ``format`` and ``pandas.NA`` was raising ``ValueError`` (:issue:`42957`)\n- :func:`to_datetime` would silently swap ``MM/DD/YYYY`` and ``DD/MM/YYYY`` formats if the given ``dayfirst`` option could not be respected - now, a warning is raised in the case of delimited date strings (e.g. ``31-12-2012``) (:issue:`12585`)\n- Bug in :meth:`date_range` and :meth:`bdate_range` do not return right bound when ``start`` = ``end`` and set is closed on one side (:issue:`43394`)\n- Bug in inplace addition and subtraction of :class:`DatetimeIndex` or :class:`TimedeltaIndex` with :class:`DatetimeArray` or :class:`TimedeltaArray` (:issue:`43904`)\n- Bug in calling ``np.isnan``, ``np.isfinite``, or ``np.isinf`` on a timezone-aware :class:`DatetimeIndex` incorrectly raising ``TypeError`` (:issue:`43917`)\n- Bug in constructing a :class:`Series` from datetime-like strings with mixed timezones incorrectly partially-inferring datetime values (:issue:`40111`)\n- Bug in addition of a :class:`Tick` object and a ``np.timedelta64`` object incorrectly raising instead of returning :class:`Timedelta` (:issue:`44474`)\n- ``np.maximum.reduce`` and ``np.minimum.reduce`` now correctly return :class:`Timestamp` and :class:`Timedelta` objects when operating on :class:`Series`, :class:`DataFrame`, or :class:`Index` with ``datetime64[ns]`` or ``timedelta64[ns]`` dtype (:issue:`43923`)\n- Bug in adding a ``np.timedelta64`` object to a :class:`BusinessDay` or :class:`CustomBusinessDay` object incorrectly raising (:issue:`44532`)\n- Bug in :meth:`Index.insert` for inserting ``np.datetime64``, ``np.timedelta64`` or ``tuple`` into :class:`Index` with ``dtype='object'`` with negative loc adding ``None`` and replacing existing value (:issue:`44509`)\n- Bug in :meth:`Timestamp.to_pydatetime` failing to retain the ``fold`` attribute (:issue:`45087`)\n- Bug in :meth:`Series.mode` with ``DatetimeTZDtype`` incorrectly returning timezone-naive and ``PeriodDtype`` incorrectly raising (:issue:`41927`)\n- Fixed regression in :meth:`~Series.reindex` raising an error when using an incompatible fill value with a datetime-like dtype (or not raising a deprecation warning for using a ``datetime.date`` as fill value) (:issue:`42921`)\n- Bug in :class:`DateOffset` addition with :class:`Timestamp` where ``offset.nanoseconds`` would not be included in the result (:issue:`43968`, :issue:`36589`)\n- Bug in :meth:`Timestamp.fromtimestamp` not supporting the ``tz`` argument (:issue:`45083`)\n- Bug in :class:`DataFrame` construction from dict of :class:`Series` with mismatched index dtypes sometimes raising depending on the ordering of the passed dict (:issue:`44091`)\n- Bug in :class:`Timestamp` hashing during some DST transitions caused a segmentation fault (:issue:`33931` and :issue:`40817`)\n\nTimedelta\n^^^^^^^^^\n- Bug in division of all-``NaT`` :class:`TimeDeltaIndex`, :class:`Series` or :class:`DataFrame` column with object-dtype array like of numbers failing to infer the result as timedelta64-dtype (:issue:`39750`)\n- Bug in floor division of ``timedelta64[ns]`` data with a scalar returning garbage values (:issue:`44466`)\n- Bug in :class:`Timedelta` now properly taking into account any nanoseconds contribution of any kwarg (:issue:`43764`, :issue:`45227`)\n\nTime Zones\n^^^^^^^^^^\n- Bug in :func:`to_datetime` with ``infer_datetime_format=True`` failing to parse zero UTC offset (``Z``) correctly (:issue:`41047`)\n- Bug in :meth:`Series.dt.tz_convert` resetting index in a :class:`Series` with :class:`CategoricalIndex` (:issue:`43080`)\n- Bug in ``Timestamp`` and ``DatetimeIndex`` incorrectly raising a ``TypeError`` when subtracting two timezone-aware objects with mismatched timezones (:issue:`31793`)\n\nNumeric\n^^^^^^^\n- Bug in floor-dividing a list or tuple of integers by a :class:`Series` incorrectly raising (:issue:`44674`)\n- Bug in :meth:`DataFrame.rank` raising ``ValueError`` with ``object`` columns and ``method=\"first\"`` (:issue:`41931`)\n- Bug in :meth:`DataFrame.rank` treating missing values and extreme values as equal (for example ``np.nan`` and ``np.inf``), causing incorrect results when ``na_option=\"bottom\"`` or ``na_option=\"top`` used (:issue:`41931`)\n- Bug in ``numexpr`` engine still being used when the option ``compute.use_numexpr`` is set to ``False`` (:issue:`32556`)\n- Bug in :class:`DataFrame` arithmetic ops with a subclass whose :meth:`_constructor` attribute is a callable other than the subclass itself (:issue:`43201`)\n- Bug in arithmetic operations involving :class:`RangeIndex` where the result would have the incorrect ``name`` (:issue:`43962`)\n- Bug in arithmetic operations involving :class:`Series` where the result could have the incorrect ``name`` when the operands having matching NA or matching tuple names (:issue:`44459`)\n- Bug in division with ``IntegerDtype`` or ``BooleanDtype`` array and NA scalar incorrectly raising (:issue:`44685`)\n- Bug in multiplying a :class:`Series` with ``FloatingDtype`` with a timedelta-like scalar incorrectly raising (:issue:`44772`)\n\nConversion\n^^^^^^^^^^\n- Bug in :class:`UInt64Index` constructor when passing a list containing both positive integers small enough to cast to int64 and integers too large to hold in int64 (:issue:`42201`)\n- Bug in :class:`Series` constructor returning 0 for missing values with dtype ``int64`` and ``False`` for dtype ``bool`` (:issue:`43017`, :issue:`43018`)\n- Bug in constructing a :class:`DataFrame` from a :class:`PandasArray` containing :class:`Series` objects behaving differently than an equivalent ``np.ndarray`` (:issue:`43986`)\n- Bug in :class:`IntegerDtype` not allowing coercion from string dtype (:issue:`25472`)\n- Bug in :func:`to_datetime` with ``arg:xr.DataArray`` and ``unit=\"ns\"`` specified raises ``TypeError`` (:issue:`44053`)\n- Bug in :meth:`DataFrame.convert_dtypes` not returning the correct type when a subclass does not overload :meth:`_constructor_sliced` (:issue:`43201`)\n- Bug in :meth:`DataFrame.astype` not propagating ``attrs`` from the original :class:`DataFrame` (:issue:`44414`)\n- Bug in :meth:`DataFrame.convert_dtypes` result losing ``columns.names`` (:issue:`41435`)\n- Bug in constructing a ``IntegerArray`` from pyarrow data failing to validate dtypes (:issue:`44891`)\n- Bug in :meth:`Series.astype` not allowing converting from a ``PeriodDtype`` to ``datetime64`` dtype, inconsistent with the :class:`PeriodIndex` behavior (:issue:`45038`)\n\nStrings\n^^^^^^^\n- Bug in checking for ``string[pyarrow]`` dtype incorrectly raising an ``ImportError`` when pyarrow is not installed (:issue:`44276`)\n\nInterval\n^^^^^^^^\n- Bug in :meth:`Series.where` with ``IntervalDtype`` incorrectly raising when the ``where`` call should not replace anything (:issue:`44181`)\n\nIndexing\n^^^^^^^^\n- Bug in :meth:`Series.rename` with :class:`MultiIndex` and ``level`` is provided (:issue:`43659`)\n- Bug in :meth:`DataFrame.truncate` and :meth:`Series.truncate` when the object's :class:`Index` has a length greater than one but only one unique value (:issue:`42365`)\n- Bug in :meth:`Series.loc` and :meth:`DataFrame.loc` with a :class:`MultiIndex` when indexing with a tuple in which one of the levels is also a tuple (:issue:`27591`)\n- Bug in :meth:`Series.loc` with a :class:`MultiIndex` whose first level contains only ``np.nan`` values (:issue:`42055`)\n- Bug in indexing on a :class:`Series` or :class:`DataFrame` with a :class:`DatetimeIndex` when passing a string, the return type depended on whether the index was monotonic (:issue:`24892`)\n- Bug in indexing on a :class:`MultiIndex` failing to drop scalar levels when the indexer is a tuple containing a datetime-like string (:issue:`42476`)\n- Bug in :meth:`DataFrame.sort_values` and :meth:`Series.sort_values` when passing an ascending value, failed to raise or incorrectly raising ``ValueError`` (:issue:`41634`)\n- Bug in updating values of :class:`pandas.Series` using boolean index, created by using :meth:`pandas.DataFrame.pop` (:issue:`42530`)\n- Bug in :meth:`Index.get_indexer_non_unique` when index contains multiple ``np.nan`` (:issue:`35392`)\n- Bug in :meth:`DataFrame.query` did not handle the degree sign in a backticked column name, such as \\`Temp(\u00c2\u00b0C)\\`, used in an expression to query a :class:`DataFrame` (:issue:`42826`)\n- Bug in :meth:`DataFrame.drop` where the error message did not show missing labels with commas when raising ``KeyError`` (:issue:`42881`)\n- Bug in :meth:`DataFrame.query` where method calls in query strings led to errors when the ``numexpr`` package was installed (:issue:`22435`)\n- Bug in :meth:`DataFrame.nlargest` and :meth:`Series.nlargest` where sorted result did not count indexes containing ``np.nan`` (:issue:`28984`)\n- Bug in indexing on a non-unique object-dtype :class:`Index` with an NA scalar (e.g. ``np.nan``) (:issue:`43711`)\n- Bug in :meth:`DataFrame.__setitem__` incorrectly writing into an existing column's array rather than setting a new array when the new dtype and the old dtype match (:issue:`43406`)\n- Bug in setting floating-dtype values into a :class:`Series` with integer dtype failing to set inplace when those values can be losslessly converted to integers (:issue:`44316`)\n- Bug in :meth:`Series.__setitem__` with object dtype when setting an array with matching size and dtype='datetime64[ns]' or dtype='timedelta64[ns]' incorrectly converting the datetime/timedeltas to integers (:issue:`43868`)\n- Bug in :meth:`DataFrame.sort_index` where ``ignore_index=True`` was not being respected when the index was already sorted (:issue:`43591`)\n- Bug in :meth:`Index.get_indexer_non_unique` when index contains multiple ``np.datetime64(\"NaT\")`` and ``np.timedelta64(\"NaT\")`` (:issue:`43869`)\n- Bug in setting a scalar :class:`Interval` value into a :class:`Series` with ``IntervalDtype`` when the scalar's sides are floats and the values' sides are integers (:issue:`44201`)\n- Bug when setting string-backed :class:`Categorical` values that can be parsed to datetimes into a :class:`DatetimeArray` or :class:`Series` or :class:`DataFrame` column backed by :class:`DatetimeArray` failing to parse these strings (:issue:`44236`)\n- Bug in :meth:`Series.__setitem__` with an integer dtype other than ``int64`` setting with a ``range`` object unnecessarily upcasting to ``int64`` (:issue:`44261`)\n- Bug in :meth:`Series.__setitem__` with a boolean mask indexer setting a listlike value of length 1 incorrectly broadcasting that value (:issue:`44265`)\n- Bug in :meth:`Series.reset_index` not ignoring ``name`` argument when ``drop`` and ``inplace`` are set to ``True`` (:issue:`44575`)\n- Bug in :meth:`DataFrame.loc.__setitem__` and :meth:`DataFrame.iloc.__setitem__` with mixed dtypes sometimes failing to operate in-place (:issue:`44345`)\n- Bug in :meth:`DataFrame.loc.__getitem__` incorrectly raising ``KeyError`` when selecting a single column with a boolean key (:issue:`44322`).\n- Bug in setting :meth:`DataFrame.iloc` with a single ``ExtensionDtype`` column and setting 2D values e.g. ``df.iloc[:] = df.values`` incorrectly raising (:issue:`44514`)\n- Bug in setting values with :meth:`DataFrame.iloc` with a single ``ExtensionDtype`` column and a tuple of arrays as the indexer (:issue:`44703`)\n- Bug in indexing on columns with ``loc`` or ``iloc`` using a slice with a negative step with ``ExtensionDtype`` columns incorrectly raising (:issue:`44551`)\n- Bug in :meth:`DataFrame.loc.__setitem__` changing dtype when indexer was completely ``False`` (:issue:`37550`)\n- Bug in :meth:`IntervalIndex.get_indexer_non_unique` returning boolean mask instead of array of integers for a non unique and non monotonic index (:issue:`44084`)\n- Bug in :meth:`IntervalIndex.get_indexer_non_unique` not handling targets of ``dtype`` 'object' with NaNs correctly (:issue:`44482`)\n- Fixed regression where a single column ``np.matrix`` was no longer coerced to a 1d ``np.ndarray`` when added to a :class:`DataFrame` (:issue:`42376`)\n- Bug in :meth:`Series.__getitem__` with a :class:`CategoricalIndex` of integers treating lists of integers as positional indexers, inconsistent with the behavior with a single scalar integer (:issue:`15470`, :issue:`14865`)\n- Bug in :meth:`Series.__setitem__` when setting floats or integers into integer-dtype :class:`Series` failing to upcast when necessary to retain precision (:issue:`45121`)\n- Bug in :meth:`DataFrame.iloc.__setitem__` ignores axis argument (:issue:`45032`)\n\nMissing\n^^^^^^^\n- Bug in :meth:`DataFrame.fillna` with ``limit`` and no ``method`` ignores ``axis='columns'`` or ``axis = 1`` (:issue:`40989`, :issue:`17399`)\n- Bug in :meth:`DataFrame.fillna` not replacing missing values when using a dict-like ``value`` and duplicate column names (:issue:`43476`)\n- Bug in constructing a :class:`DataFrame` with a dictionary ``np.datetime64`` as a value and ``dtype='timedelta64[ns]'``, or vice-versa, incorrectly casting instead of raising (:issue:`44428`)\n- Bug in :meth:`Series.interpolate` and :meth:`DataFrame.interpolate` with ``inplace=True`` not writing to the underlying array(s) in-place (:issue:`44749`)\n- Bug in :meth:`Index.fillna` incorrectly returning an unfilled :class:`Index` when NA values are present and ``downcast`` argument is specified. This now raises ``NotImplementedError`` instead; do not pass ``downcast`` argument (:issue:`44873`)\n- Bug in :meth:`DataFrame.dropna` changing :class:`Index` even if no entries were dropped (:issue:`41965`)\n- Bug in :meth:`Series.fillna` with an object-dtype incorrectly ignoring ``downcast=\"infer\"`` (:issue:`44241`)\n\nMultiIndex\n^^^^^^^^^^\n- Bug in :meth:`MultiIndex.get_loc` where the first level is a :class:`DatetimeIndex` and a string key is passed (:issue:`42465`)\n- Bug in :meth:`MultiIndex.reindex` when passing a ``level`` that corresponds to an ``ExtensionDtype`` level (:issue:`42043`)\n- Bug in :meth:`MultiIndex.get_loc` raising ``TypeError`` instead of ``KeyError`` on nested tuple (:issue:`42440`)\n- Bug in :meth:`MultiIndex.union` setting wrong ``sortorder`` causing errors in subsequent indexing operations with slices (:issue:`44752`)\n- Bug in :meth:`MultiIndex.putmask` where the other value was also a :class:`MultiIndex` (:issue:`43212`)\n- Bug in :meth:`MultiIndex.dtypes` duplicate level names returned only one dtype per name (:issue:`45174`)\n\nI/O\n^^^\n- Bug in :func:`read_excel` attempting to read chart sheets from .xlsx files (:issue:`41448`)\n- Bug in :func:`json_normalize` where ``errors=ignore`` could fail to ignore missing values of ``meta`` when ``record_path`` has a length greater than one (:issue:`41876`)\n- Bug in :func:`read_csv` with multi-header input and arguments referencing column names as tuples (:issue:`42446`)\n- Bug in :func:`read_fwf`, where difference in lengths of ``colspecs`` and ``names`` was not raising ``ValueError`` (:issue:`40830`)\n- Bug in :func:`Series.to_json` and :func:`DataFrame.to_json` where some attributes were skipped when serializing plain Python objects to JSON (:issue:`42768`, :issue:`33043`)\n- Column headers are dropped when constructing a :class:`DataFrame` from a sqlalchemy's ``Row`` object (:issue:`40682`)\n- Bug in unpickling an :class:`Index` with object dtype incorrectly inferring numeric dtypes (:issue:`43188`)\n- Bug in :func:`read_csv` where reading multi-header input with unequal lengths incorrectly raised ``IndexError`` (:issue:`43102`)\n- Bug in :func:`read_csv` raising ``ParserError`` when reading file in chunks and some chunk blocks have fewer columns than header for ``engine=\"c\"`` (:issue:`21211`)\n- Bug in :func:`read_csv`, changed exception class when expecting a file path name or file-like object from ``OSError`` to ``TypeError`` (:issue:`43366`)\n- Bug in :func:`read_csv` and :func:`read_fwf` ignoring all ``skiprows`` except first when ``nrows`` is specified for ``engine='python'`` (:issue:`44021`, :issue:`10261`)\n- Bug in :func:`read_csv` keeping the original column in object format when ``keep_date_col=True`` is set (:issue:`13378`)\n- Bug in :func:`read_json` not handling non-numpy dtypes correctly (especially ``category``) (:issue:`21892`, :issue:`33205`)\n- Bug in :func:`json_normalize` where multi-character ``sep`` parameter is incorrectly prefixed to every key (:issue:`43831`)\n- Bug in :func:`json_normalize` where reading data with missing multi-level metadata would not respect ``errors=\"ignore\"`` (:issue:`44312`)\n- Bug in :func:`read_csv` used second row to guess implicit index if ``header`` was set to ``None`` for ``engine=\"python\"`` (:issue:`22144`)\n- Bug in :func:`read_csv` not recognizing bad lines when ``names`` were given for ``engine=\"c\"`` (:issue:`22144`)\n- Bug in :func:`read_csv` with :code:`float_precision=\"round_trip\"` which did not skip initial/trailing whitespace (:issue:`43713`)\n- Bug when Python is built without the lzma module: a warning was raised at the pandas import time, even if the lzma capability isn't used (:issue:`43495`)\n- Bug in :func:`read_csv` not applying dtype for ``index_col`` (:issue:`9435`)\n- Bug in dumping/loading a :class:`DataFrame` with ``yaml.dump(frame)`` (:issue:`42748`)\n- Bug in :func:`read_csv` raising ``ValueError`` when ``names`` was longer than ``header`` but equal to data rows for ``engine=\"python\"`` (:issue:`38453`)\n- Bug in :class:`ExcelWriter`, where ``engine_kwargs`` were not passed through to all engines (:issue:`43442`)\n- Bug in :func:`read_csv` raising ``ValueError`` when ``parse_dates`` was used with :class:`MultiIndex` columns (:issue:`8991`)\n- Bug in :func:`read_csv` not raising an ``ValueError`` when ``\\n`` was specified as ``delimiter`` or ``sep`` which conflicts with ``lineterminator`` (:issue:`43528`)\n- Bug in :func:`to_csv` converting datetimes in categorical :class:`Series` to integers (:issue:`40754`)\n- Bug in :func:`read_csv` converting columns to numeric after date parsing failed (:issue:`11019`)\n- Bug in :func:`read_csv` not replacing ``NaN`` values with ``np.nan`` before attempting date conversion (:issue:`26203`)\n- Bug in :func:`read_csv` raising ``AttributeError`` when attempting to read a .csv file and infer index column dtype from an nullable integer type (:issue:`44079`)\n- Bug in :func:`to_csv` always coercing datetime columns with different formats to the same format (:issue:`21734`)\n- :meth:`DataFrame.to_csv` and :meth:`Series.to_csv` with ``compression`` set to ``'zip'`` no longer create a zip file containing a file ending with \".zip\". Instead, they try to infer the inner file name more smartly (:issue:`39465`)\n- Bug in :func:`read_csv` where reading a mixed column of booleans and missing values to a float type results in the missing values becoming 1.0 rather than NaN (:issue:`42808`, :issue:`34120`)\n- Bug in :func:`to_xml` raising error for ``pd.NA`` with extension array dtype (:issue:`43903`)\n- Bug in :func:`read_csv` when passing simultaneously a parser in ``date_parser`` and ``parse_dates=False``, the parsing was still called (:issue:`44366`)\n- Bug in :func:`read_csv` not setting name of :class:`MultiIndex` columns correctly when ``index_col`` is not the first column (:issue:`38549`)\n- Bug in :func:`read_csv` silently ignoring errors when failing to create a memory-mapped file (:issue:`44766`)\n- Bug in :func:`read_csv` when passing a ``tempfile.SpooledTemporaryFile`` opened in binary mode (:issue:`44748`)\n- Bug in :func:`read_json` raising ``ValueError`` when attempting to parse json strings containing \"://\" (:issue:`36271`)\n- Bug in :func:`read_csv` when ``engine=\"c\"`` and ``encoding_errors=None`` which caused a segfault (:issue:`45180`)\n- Bug in :func:`read_csv` an invalid value of ``usecols`` leading to an unclosed file handle (:issue:`45384`)\n- Bug in :meth:`DataFrame.to_json` fix memory leak (:issue:`43877`)\n\nPeriod\n^^^^^^\n- Bug in adding a :class:`Period` object to a ``np.timedelta64`` object incorrectly raising ``TypeError`` (:issue:`44182`)\n- Bug in :meth:`PeriodIndex.to_timestamp` when the index has ``freq=\"B\"`` inferring ``freq=\"D\"`` for its result instead of ``freq=\"B\"`` (:issue:`44105`)\n- Bug in :class:`Period` constructor incorrectly allowing ``np.timedelta64(\"NaT\")`` (:issue:`44507`)\n- Bug in :meth:`PeriodIndex.to_timestamp` giving incorrect values for indexes with non-contiguous data (:issue:`44100`)\n- Bug in :meth:`Series.where` with ``PeriodDtype`` incorrectly raising when the ``where`` call should not replace anything (:issue:`45135`)\n\nPlotting\n^^^^^^^^\n- When given non-numeric data, :meth:`DataFrame.boxplot` now raises a ``ValueError`` rather than a cryptic ``KeyError`` or ``ZeroDivisionError``, in line with other plotting functions like :meth:`DataFrame.hist` (:issue:`43480`)\n\nGroupby/resample/rolling\n^^^^^^^^^^^^^^^^^^^^^^^^\n- Bug in :meth:`SeriesGroupBy.apply` where passing an unrecognized string argument failed to raise ``TypeError`` when the underlying ``Series`` is empty (:issue:`42021`)\n- Bug in :meth:`Series.rolling.apply`, :meth:`DataFrame.rolling.apply`, :meth:`Series.expanding.apply` and :meth:`DataFrame.expanding.apply` with ``engine=\"numba\"`` where ``*args`` were being cached with the user passed function (:issue:`42287`)\n- Bug in :meth:`.DataFrameGroupBy.max`, :meth:`.SeriesGroupBy.max`, :meth:`.DataFrameGroupBy.min`, and :meth:`.SeriesGroupBy.min` with nullable integer dtypes losing precision (:issue:`41743`)\n- Bug in :meth:`DataFrame.groupby.rolling.var` would calculate the rolling variance only on the first group (:issue:`42442`)\n- Bug in :meth:`.DataFrameGroupBy.shift` and :meth:`.SeriesGroupBy.shift` that would return the grouping columns if ``fill_value`` was not ``None`` (:issue:`41556`)\n- Bug in :meth:`SeriesGroupBy.nlargest` and :meth:`SeriesGroupBy.nsmallest` would have an inconsistent index when the input :class:`Series` was sorted and ``n`` was greater than or equal to all group sizes (:issue:`15272`, :issue:`16345`, :issue:`29129`)\n- Bug in :meth:`pandas.DataFrame.ewm`, where non-float64 dtypes were silently failing (:issue:`42452`)\n- Bug in :meth:`pandas.DataFrame.rolling` operation along rows (``axis=1``) incorrectly omits columns containing ``float16`` and ``float32`` (:issue:`41779`)\n- Bug in :meth:`Resampler.aggregate` did not allow the use of Named Aggregation (:issue:`32803`)\n- Bug in :meth:`Series.rolling` when the :class:`Series` ``dtype`` was ``Int64`` (:issue:`43016`)\n- Bug in :meth:`DataFrame.rolling.corr` when the :class:`DataFrame` columns was a :class:`MultiIndex` (:issue:`21157`)\n- Bug in :meth:`DataFrame.groupby.rolling` when specifying ``on`` and calling ``__getitem__`` would subsequently return incorrect results (:issue:`43355`)\n- Bug in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` with time-based :class:`Grouper` objects incorrectly raising ``ValueError`` in corner cases where the grouping vector contains a ``NaT`` (:issue:`43500`, :issue:`43515`)\n- Bug in :meth:`.DataFrameGroupBy.mean` and :meth:`.SeriesGroupBy.mean` failing with ``complex`` dtype (:issue:`43701`)\n- Bug in :meth:`Series.rolling` and :meth:`DataFrame.rolling` not calculating window bounds correctly for the first row when ``center=True`` and index is decreasing (:issue:`43927`)\n- Bug in :meth:`Series.rolling` and :meth:`DataFrame.rolling` for centered datetimelike windows with uneven nanosecond (:issue:`43997`)\n- Bug in :meth:`.DataFrameGroupBy.mean` and :meth:`.SeriesGroupBy.mean` raising ``KeyError`` when column was selected at least twice (:issue:`44924`)\n- Bug in :meth:`.DataFrameGroupBy.nth` and :meth:`.SeriesGroupBy.nth` failing on ``axis=1`` (:issue:`43926`)\n- Bug in :meth:`Series.rolling` and :meth:`DataFrame.rolling` not respecting right bound on centered datetime-like windows, if the index contain duplicates (:issue:`3944`)\n- Bug in :meth:`Series.rolling` and :meth:`DataFrame.rolling` when using a :class:`pandas.api.indexers.BaseIndexer` subclass that returned unequal start and end arrays would segfault instead of raising a ``ValueError`` (:issue:`44470`)\n- Bug in :meth:`Groupby.nunique` not respecting ``observed=True`` for ``categorical`` grouping columns (:issue:`45128`)\n- Bug in :meth:`.DataFrameGroupBy.head`, :meth:`.SeriesGroupBy.head`, :meth:`.DataFrameGroupBy.tail`, and :meth:`.SeriesGroupBy.tail` not dropping groups with ``NaN`` when ``dropna=True`` (:issue:`45089`)\n- Bug in :meth:`GroupBy.__iter__` after selecting a subset of columns in a :class:`GroupBy` object, which returned all columns instead of the chosen subset (:issue:`44821`)\n- Bug in :meth:`Groupby.rolling` when non-monotonic data passed, fails to correctly raise ``ValueError`` (:issue:`43909`)\n- Bug where grouping by a :class:`Series` that has a ``categorical`` data type and length unequal to the axis of grouping raised ``ValueError`` (:issue:`44179`)\n\nReshaping\n^^^^^^^^^\n- Improved error message when creating a :class:`DataFrame` column from a multi-dimensional :class:`numpy.ndarray` (:issue:`42463`)\n- Bug in :func:`concat` creating :class:`MultiIndex` with duplicate level entries when concatenating a :class:`DataFrame` with duplicates in :class:`Index` and multiple keys (:issue:`42651`)\n- Bug in :meth:`pandas.cut` on :class:`Series` with duplicate indices and non-exact :meth:`pandas.CategoricalIndex` (:issue:`42185`, :issue:`42425`)\n- Bug in :meth:`DataFrame.append` failing to retain dtypes when appended columns do not match (:issue:`43392`)\n- Bug in :func:`concat` of ``bool`` and ``boolean`` dtypes resulting in ``object`` dtype instead of ``boolean`` dtype (:issue:`42800`)\n- Bug in :func:`crosstab` when inputs are categorical :class:`Series`, there are categories that are not present in one or both of the :class:`Series`, and ``margins=True``. Previously the margin value for missing categories was ``NaN``. It is now correctly reported as 0 (:issue:`43505`)\n- Bug in :func:`concat` would fail when the ``objs`` argument all had the same index and the ``keys`` argument contained duplicates (:issue:`43595`)\n- Bug in :func:`concat` which ignored the ``sort`` parameter (:issue:`43375`)\n- Bug in :func:`merge` with :class:`MultiIndex` as column index for the ``on`` argument returning an error when assigning a column internally (:issue:`43734`)\n- Bug in :func:`crosstab` would fail when inputs are lists or tuples (:issue:`44076`)\n- Bug in :meth:`DataFrame.append` failing to retain ``index.name`` when appending a list of :class:`Series` objects (:issue:`44109`)\n- Fixed metadata propagation in :meth:`Dataframe.apply` method, consequently fixing the same issue for :meth:`Dataframe.transform`, :meth:`Dataframe.nunique` and :meth:`Dataframe.mode` (:issue:`28283`)\n- Bug in :func:`concat` casting levels of :class:`MultiIndex` to float if all levels only consist of missing values (:issue:`44900`)\n- Bug in :meth:`DataFrame.stack` with ``ExtensionDtype`` columns incorrectly raising (:issue:`43561`)\n- Bug in :func:`merge` raising ``KeyError`` when joining over differently named indexes with on keywords (:issue:`45094`)\n- Bug in :meth:`Series.unstack` with object doing unwanted type inference on resulting columns (:issue:`44595`)\n- Bug in :meth:`MultiIndex.join()` with overlapping ``IntervalIndex`` levels (:issue:`44096`)\n- Bug in :meth:`DataFrame.replace` and :meth:`Series.replace` results is different ``dtype`` based on ``regex`` parameter (:issue:`44864`)\n- Bug in :meth:`DataFrame.pivot` with ``index=None`` when the :class:`DataFrame` index was a :class:`MultiIndex` (:issue:`23955`)\n\nSparse\n^^^^^^\n- Bug in :meth:`DataFrame.sparse.to_coo` raising ``AttributeError`` when column names are not unique (:issue:`29564`)\n- Bug in :meth:`SparseArray.max` and :meth:`SparseArray.min` raising ``ValueError`` for arrays with 0 non-null elements (:issue:`43527`)\n- Bug in :meth:`DataFrame.sparse.to_coo` silently converting non-zero fill values to zero (:issue:`24817`)\n- Bug in :class:`SparseArray` comparison methods with an array-like operand of mismatched length raising ``AssertionError`` or unclear ``ValueError`` depending on the input (:issue:`43863`)\n- Bug in :class:`SparseArray` arithmetic methods ``floordiv`` and ``mod`` behaviors when dividing by zero not matching the non-sparse :class:`Series` behavior (:issue:`38172`)\n- Bug in :class:`SparseArray` unary methods as well as :meth:`SparseArray.isna` doesn't recalculate indexes (:issue:`44955`)\n\nExtensionArray\n^^^^^^^^^^^^^^\n- Bug in :func:`array` failing to preserve :class:`PandasArray` (:issue:`43887`)\n- NumPy ufuncs ``np.abs``, ``np.positive``, ``np.negative`` now correctly preserve dtype when called on ExtensionArrays that implement ``__abs__, __pos__, __neg__``, respectively. In particular this is fixed for :class:`TimedeltaArray` (:issue:`43899`, :issue:`23316`)\n- NumPy ufuncs ``np.minimum.reduce`` ``np.maximum.reduce``, ``np.add.reduce``, and ``np.prod.reduce`` now work correctly instead of raising ``NotImplementedError`` on :class:`Series` with ``IntegerDtype`` or ``FloatDtype`` (:issue:`43923`, :issue:`44793`)\n- NumPy ufuncs with ``out`` keyword are now supported by arrays with ``IntegerDtype`` and ``FloatingDtype`` (:issue:`45122`)\n- Avoid raising ``PerformanceWarning`` about fragmented :class:`DataFrame` when using many columns with an extension dtype (:issue:`44098`)\n- Bug in :class:`IntegerArray` and :class:`FloatingArray` construction incorrectly coercing mismatched NA values (e.g. ``np.timedelta64(\"NaT\")``) to numeric NA (:issue:`44514`)\n- Bug in :meth:`BooleanArray.__eq__` and :meth:`BooleanArray.__ne__` raising ``TypeError`` on comparison with an incompatible type (like a string). This caused :meth:`DataFrame.replace` to sometimes raise a ``TypeError`` if a nullable boolean column was included (:issue:`44499`)\n- Bug in :func:`array` incorrectly raising when passed a ``ndarray`` with ``float16`` dtype (:issue:`44715`)\n- Bug in calling ``np.sqrt`` on :class:`BooleanArray` returning a malformed :class:`FloatingArray` (:issue:`44715`)\n- Bug in :meth:`Series.where` with ``ExtensionDtype`` when ``other`` is a NA scalar incompatible with the :class:`Series` dtype (e.g. ``NaT`` with a numeric dtype) incorrectly casting to a compatible NA value (:issue:`44697`)\n- Bug in :meth:`Series.replace` where explicitly passing ``value=None`` is treated as if no ``value`` was passed, and ``None`` not being in the result (:issue:`36984`, :issue:`19998`)\n- Bug in :meth:`Series.replace` with unwanted downcasting being done in no-op replacements (:issue:`44498`)\n- Bug in :meth:`Series.replace` with ``FloatDtype``, ``string[python]``, or ``string[pyarrow]`` dtype not being preserved when possible (:issue:`33484`, :issue:`40732`, :issue:`31644`, :issue:`41215`, :issue:`25438`)\n\nStyler\n^^^^^^\n- Bug in :class:`.Styler` where the ``uuid`` at initialization maintained a floating underscore (:issue:`43037`)\n- Bug in :meth:`.Styler.to_html` where the ``Styler`` object was updated if the ``to_html`` method was called with some args (:issue:`43034`)\n- Bug in :meth:`.Styler.copy` where ``uuid`` was not previously copied (:issue:`40675`)\n- Bug in :meth:`Styler.apply` where functions which returned :class:`Series` objects were not correctly handled in terms of aligning their index labels (:issue:`13657`, :issue:`42014`)\n- Bug when rendering an empty :class:`DataFrame` with a named :class:`Index` (:issue:`43305`)\n- Bug when rendering a single level :class:`MultiIndex` (:issue:`43383`)\n- Bug when combining non-sparse rendering and :meth:`.Styler.hide_columns` or :meth:`.Styler.hide_index` (:issue:`43464`)\n- Bug setting a table style when using multiple selectors in :class:`.Styler` (:issue:`44011`)\n- Bugs where row trimming and column trimming failed to reflect hidden rows (:issue:`43703`, :issue:`44247`)\n\nOther\n^^^^^\n- Bug in :meth:`DataFrame.astype` with non-unique columns and a :class:`Series` ``dtype`` argument (:issue:`44417`)\n- Bug in :meth:`CustomBusinessMonthBegin.__add__` (:meth:`CustomBusinessMonthEnd.__add__`) not applying the extra ``offset`` parameter when beginning (end) of the target month is already a business day (:issue:`41356`)\n- Bug in :meth:`RangeIndex.union` with another ``RangeIndex`` with matching (even) ``step`` and starts differing by strictly less than ``step / 2`` (:issue:`44019`)\n- Bug in :meth:`RangeIndex.difference` with ``sort=None`` and ``step<0`` failing to sort (:issue:`44085`)\n- Bug in :meth:`Series.replace` and :meth:`DataFrame.replace` with ``value=None`` and ExtensionDtypes (:issue:`44270`, :issue:`37899`)\n- Bug in :meth:`FloatingArray.equals` failing to consider two arrays equal if they contain ``np.nan`` values (:issue:`44382`)\n- Bug in :meth:`DataFrame.shift` with ``axis=1`` and ``ExtensionDtype`` columns incorrectly raising when an incompatible ``fill_value`` is passed (:issue:`44564`)\n- Bug in :meth:`DataFrame.shift` with ``axis=1`` and ``periods`` larger than ``len(frame.columns)`` producing an invalid :class:`DataFrame` (:issue:`44978`)\n- Bug in :meth:`DataFrame.diff` when passing a NumPy integer object instead of an ``int`` object (:issue:`44572`)\n- Bug in :meth:`Series.replace` raising ``ValueError`` when using ``regex=True`` with a :class:`Series` containing ``np.nan`` values (:issue:`43344`)\n- Bug in :meth:`DataFrame.to_records` where an incorrect ``n`` was used when missing names were replaced by ``level_n`` (:issue:`44818`)\n- Bug in :meth:`DataFrame.eval` where ``resolvers`` argument was overriding the default resolvers (:issue:`34966`)\n- :meth:`Series.__repr__` and :meth:`DataFrame.__repr__` no longer replace all null-values in indexes with \"NaN\" but use their real string-representations. \"NaN\" is used only for ``float(\"nan\")`` (:issue:`45263`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_140.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.3.5..v1.4.0\n", "2.1.1": ".. _whatsnew_211:\n\nWhat's new in 2.1.1 (September 20, 2023)\n----------------------------------------\n\nThese are the changes in pandas 2.1.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_211.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :func:`concat` when :class:`DataFrame` 's have two different extension dtypes (:issue:`54848`)\n- Fixed regression in :func:`merge` when merging over a PyArrow string index (:issue:`54894`)\n- Fixed regression in :func:`read_csv` when ``usecols`` is given and ``dtypes`` is a dict for ``engine=\"python\"`` (:issue:`54868`)\n- Fixed regression in :func:`read_csv` when ``delim_whitespace`` is True (:issue:`54918`, :issue:`54931`)\n- Fixed regression in :meth:`.GroupBy.get_group` raising for ``axis=1`` (:issue:`54858`)\n- Fixed regression in :meth:`DataFrame.__setitem__` raising ``AssertionError`` when setting a :class:`Series` with a partial :class:`MultiIndex` (:issue:`54875`)\n- Fixed regression in :meth:`DataFrame.filter` not respecting the order of elements for ``filter`` (:issue:`54980`)\n- Fixed regression in :meth:`DataFrame.to_sql` not roundtripping datetime columns correctly for sqlite (:issue:`54877`)\n- Fixed regression in :meth:`DataFrameGroupBy.agg` when aggregating a DataFrame with duplicate column names using a dictionary (:issue:`55006`)\n- Fixed regression in :meth:`MultiIndex.append` raising when appending overlapping :class:`IntervalIndex` levels (:issue:`54934`)\n- Fixed regression in :meth:`Series.drop_duplicates` for PyArrow strings (:issue:`54904`)\n- Fixed regression in :meth:`Series.interpolate` raising when ``fill_value`` was given (:issue:`54920`)\n- Fixed regression in :meth:`Series.value_counts` raising for numeric data if ``bins`` was specified (:issue:`54857`)\n- Fixed regression in comparison operations for PyArrow backed columns not propagating exceptions correctly (:issue:`54944`)\n- Fixed regression when comparing a :class:`Series` with ``datetime64`` dtype with ``None`` (:issue:`54870`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_211.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fixed bug for :class:`ArrowDtype` raising ``NotImplementedError`` for fixed-size list (:issue:`55000`)\n- Fixed bug in :meth:`DataFrame.stack` with ``future_stack=True`` and columns a non-:class:`MultiIndex` consisting of tuples (:issue:`54948`)\n- Fixed bug in :meth:`Series.dt.tz` with :class:`ArrowDtype` where a string was returned instead of a ``tzinfo`` object (:issue:`55003`)\n- Fixed bug in :meth:`Series.pct_change` and :meth:`DataFrame.pct_change` showing unnecessary ``FutureWarning`` (:issue:`54981`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_211.other:\n\nOther\n~~~~~\n- Reverted the deprecation that disallowed :meth:`Series.apply` returning a :class:`DataFrame` when the passed-in callable returns a :class:`Series` object (:issue:`52116`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_211.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.1.0..v2.1.1\n", "0.6.1": "\n.. _whatsnew_061:\n\nVersion 0.6.1 (December 13, 2011)\n---------------------------------\n\nNew features\n~~~~~~~~~~~~\n- Can append single rows (as Series) to a DataFrame\n- Add Spearman and Kendall rank correlation\n  options to Series.corr and DataFrame.corr (:issue:`428`)\n- :ref:`Added <indexing.basics.get_value>` ``get_value`` and ``set_value`` methods to\n  Series, DataFrame, and Panel for very low-overhead access (>2x faster in many\n  cases) to scalar elements (:issue:`437`, :issue:`438`). ``set_value`` is capable of\n  producing an enlarged object.\n- Add PyQt table widget to sandbox (:issue:`435`)\n- DataFrame.align can :ref:`accept Series arguments <basics.align.frame.series>`\n  and an :ref:`axis option <basics.df_join>` (:issue:`461`)\n- Implement new :ref:`SparseArray <sparse.array>` and ``SparseList``\n  data structures. SparseSeries now derives from SparseArray (:issue:`463`)\n- :ref:`Better console printing options <basics.console_output>` (:issue:`453`)\n- Implement fast data ranking for Series and\n  DataFrame, fast versions of scipy.stats.rankdata (:issue:`428`)\n- Implement ``DataFrame.from_items`` alternate\n  constructor (:issue:`444`)\n- DataFrame.convert_objects method for :ref:`inferring better dtypes <basics.cast>`\n  for object columns (:issue:`302`)\n- Add :ref:`rolling_corr_pairwise <window.corr_pairwise>` function for\n  computing Panel of correlation matrices (:issue:`189`)\n- Add :ref:`margins <reshaping.pivot.margins>` option to :ref:`pivot_table\n  <reshaping.pivot>` for computing subgroup aggregates (:issue:`114`)\n- Add ``Series.from_csv`` function (:issue:`482`)\n- :ref:`Can pass <window.cov_corr>` DataFrame/DataFrame and\n  DataFrame/Series to rolling_corr/rolling_cov (GH #462)\n- MultiIndex.get_level_values can :ref:`accept the level name <advanced.get_level_values>`\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n- Improve memory usage of ``DataFrame.describe`` (do not copy data\n  unnecessarily) (PR #425)\n\n- Optimize scalar value lookups in the general case by 25% or more in Series\n  and DataFrame\n\n- Fix performance regression in cross-sectional count in DataFrame, affecting\n  DataFrame.dropna speed\n- Column deletion in DataFrame copies no data (computes views on blocks) (GH\n  #158)\n\n\n\n.. _whatsnew_0.6.1.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.6.0..v0.6.1\n", "1.0.5": "\n.. _whatsnew_105:\n\nWhat's new in 1.0.5 (June 17, 2020)\n-----------------------------------\n\nThese are the changes in pandas 1.0.5. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_105.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n\n- Fix regression in :meth:`read_parquet` when reading from file-like objects\n  (:issue:`34467`).\n- Fix regression in reading from public S3 buckets (:issue:`34626`).\n\nNote this disables the ability to read Parquet files from directories on S3\nagain (:issue:`26388`, :issue:`34632`), which was added in the 1.0.4 release,\nbut is now targeted for pandas 1.1.0.\n\n- Fixed regression in :meth:`~DataFrame.replace` raising an ``AssertionError`` when replacing values in an extension dtype with values of a different dtype (:issue:`34530`)\n\n.. _whatsnew_105.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n\n- Fixed building from source with Python 3.8 fetching the wrong version of NumPy (:issue:`34666`)\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.0.4..v1.0.5|HEAD\n", "1.4.2": ".. _whatsnew_142:\n\nWhat's new in 1.4.2 (April 2, 2022)\n-----------------------------------\n\nThese are the changes in pandas 1.4.2. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_142.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :meth:`DataFrame.drop` and :meth:`Series.drop` when :class:`Index` had extension dtype and duplicates (:issue:`45860`)\n- Fixed regression in :func:`read_csv` killing python process when invalid file input was given for ``engine=\"c\"`` (:issue:`45957`)\n- Fixed memory performance regression in :meth:`Series.fillna` when called on a :class:`DataFrame` column with ``inplace=True`` (:issue:`46149`)\n- Provided an alternative solution for passing custom Excel formats in :meth:`.Styler.to_excel`, which was a regression based on stricter CSS validation. Examples available in the documentation for :meth:`.Styler.format` (:issue:`46152`)\n- Fixed regression in :meth:`DataFrame.replace` when a replacement value was also a target for replacement (:issue:`46306`)\n- Fixed regression in :meth:`DataFrame.replace` when the replacement value was explicitly ``None`` when passed in a dictionary to ``to_replace`` (:issue:`45601`, :issue:`45836`)\n- Fixed regression when setting values with :meth:`DataFrame.loc` losing :class:`MultiIndex` names if :class:`DataFrame`  was empty before (:issue:`46317`)\n- Fixed regression when rendering boolean datatype columns with :meth:`.Styler` (:issue:`46384`)\n- Fixed regression in :meth:`Groupby.rolling` with a frequency window that would raise a ``ValueError`` even if the datetimes within each group were monotonic (:issue:`46061`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_142.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fix some cases for subclasses that define their ``_constructor`` properties as general callables (:issue:`46018`)\n- Fixed \"longtable\" formatting in :meth:`.Styler.to_latex` when ``column_format`` is given in extended format (:issue:`46037`)\n- Fixed incorrect rendering in :meth:`.Styler.format` with ``hyperlinks=\"html\"`` when the url contains a colon or other special characters (:issue:`46389`)\n- Improved error message in :class:`.Rolling` when ``window`` is a frequency and ``NaT`` is in the rolling axis (:issue:`46087`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_142.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.4.1..v1.4.2\n", "0.9.1": ".. _whatsnew_0901:\n\nVersion 0.9.1 (November 14, 2012)\n---------------------------------\n\n{{ header }}\n\n\nThis is a bug fix release from 0.9.0 and includes several new features and\nenhancements along with a large number of bug fixes. The new features include\nby-column sort order for DataFrame and Series, improved NA handling for the rank\nmethod, masking functions for DataFrame, and intraday time-series filtering for\nDataFrame.\n\nNew features\n~~~~~~~~~~~~\n\n  - ``Series.sort``, ``DataFrame.sort``, and ``DataFrame.sort_index`` can now be\n    specified in a per-column manner to support multiple sort orders (:issue:`928`)\n\n    .. code-block:: ipython\n\n       In [2]: df = pd.DataFrame(np.random.randint(0, 2, (6, 3)),\n          ...:                   columns=['A', 'B', 'C'])\n\n       In [3]: df.sort(['A', 'B'], ascending=[1, 0])\n\n       Out[3]:\n          A  B  C\n       3  0  1  1\n       4  0  1  1\n       2  0  0  1\n       0  1  0  0\n       1  1  0  0\n       5  1  0  0\n\n  - ``DataFrame.rank`` now supports additional argument values for the\n    ``na_option`` parameter so missing values can be assigned either the largest\n    or the smallest rank (:issue:`1508`, :issue:`2159`)\n\n    .. ipython:: python\n\n        df = pd.DataFrame(np.random.randn(6, 3), columns=['A', 'B', 'C'])\n\n        df.loc[2:4] = np.nan\n\n        df.rank()\n\n        df.rank(na_option='top')\n\n        df.rank(na_option='bottom')\n\n\n  - DataFrame has new ``where`` and ``mask`` methods to select values according to a\n    given boolean mask (:issue:`2109`, :issue:`2151`)\n\n        DataFrame currently supports slicing via a boolean vector the same length as the DataFrame (inside the ``[]``).\n        The returned DataFrame has the same number of columns as the original, but is sliced on its index.\n\n        .. ipython:: python\n\n            df = pd.DataFrame(np.random.randn(5, 3), columns=['A', 'B', 'C'])\n\n            df\n\n            df[df['A'] > 0]\n\n        If a DataFrame is sliced with a DataFrame based boolean condition (with the same size as the original DataFrame),\n        then a DataFrame the same size (index and columns) as the original is returned, with\n        elements that do not meet the boolean condition as ``NaN``. This is accomplished via\n        the new method ``DataFrame.where``. In addition, ``where`` takes an optional ``other`` argument for replacement.\n\n        .. ipython:: python\n\n           df[df > 0]\n\n           df.where(df > 0)\n\n           df.where(df > 0, -df)\n\n        Furthermore, ``where`` now aligns the input boolean condition (ndarray or DataFrame), such that partial selection\n        with setting is possible. This is analogous to partial setting via ``.ix`` (but on the contents rather than the axis labels)\n\n        .. ipython:: python\n\n           df2 = df.copy()\n           df2[df2[1:4] > 0] = 3\n           df2\n\n        ``DataFrame.mask`` is the inverse boolean operation of ``where``.\n\n        .. ipython:: python\n\n           df.mask(df <= 0)\n\n  - Enable referencing of Excel columns by their column names (:issue:`1936`)\n\n    .. code-block:: ipython\n\n       In [1]: xl = pd.ExcelFile('data/test.xls')\n\n       In [2]: xl.parse('Sheet1', index_col=0, parse_dates=True,\n                        parse_cols='A:D')\n\n\n  - Added option to disable pandas-style tick locators and formatters\n    using ``series.plot(x_compat=True)`` or ``pandas.plot_params['x_compat'] =\n    True`` (:issue:`2205`)\n  - Existing TimeSeries methods ``at_time`` and ``between_time`` were added to\n    DataFrame (:issue:`2149`)\n  - DataFrame.dot can now accept ndarrays (:issue:`2042`)\n  - DataFrame.drop now supports non-unique indexes (:issue:`2101`)\n  - Panel.shift now supports negative periods (:issue:`2164`)\n  - DataFrame now support unary ~ operator (:issue:`2110`)\n\nAPI changes\n~~~~~~~~~~~\n\n  - Upsampling data with a PeriodIndex will result in a higher frequency\n    TimeSeries that spans the original time window\n\n    .. code-block:: ipython\n\n       In [1]: prng = pd.period_range('2012Q1', periods=2, freq='Q')\n\n       In [2]: s = pd.Series(np.random.randn(len(prng)), prng)\n\n       In [4]: s.resample('M')\n       Out[4]:\n       2012-01   -1.471992\n       2012-02         NaN\n       2012-03         NaN\n       2012-04   -0.493593\n       2012-05         NaN\n       2012-06         NaN\n       Freq: M, dtype: float64\n\n  - Period.end_time now returns the last nanosecond in the time interval\n    (:issue:`2124`, :issue:`2125`, :issue:`1764`)\n\n    .. ipython:: python\n\n        p = pd.Period('2012')\n\n        p.end_time\n\n\n  - File parsers no longer coerce to float or bool for columns that have custom\n    converters specified (:issue:`2184`)\n\n    .. ipython:: python\n\n        import io\n\n        data = ('A,B,C\\n'\n                '00001,001,5\\n'\n                '00002,002,6')\n        pd.read_csv(io.StringIO(data), converters={'A': lambda x: x.strip()})\n\n\nSee the :ref:`full release notes\n<release>` or issue tracker\non GitHub for a complete list.\n\n\n.. _whatsnew_0.9.1.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.9.0..v0.9.1\n", "0.7.1": ".. _whatsnew_0701:\n\nVersion 0.7.1 (February 29, 2012)\n---------------------------------\n\n{{ header }}\n\n\nThis release includes a few new features and addresses over a dozen bugs in\n0.7.0.\n\nNew features\n~~~~~~~~~~~~\n\n  - Add ``to_clipboard`` function to pandas namespace for writing objects to\n    the system clipboard (:issue:`774`)\n  - Add ``itertuples`` method to DataFrame for iterating through the rows of a\n    dataframe as tuples (:issue:`818`)\n  - Add ability to pass fill_value and method to DataFrame and Series align\n    method (:issue:`806`, :issue:`807`)\n  - Add fill_value option to reindex, align methods (:issue:`784`)\n  - Enable concat to produce DataFrame from Series (:issue:`787`)\n  - Add ``between`` method to Series (:issue:`802`)\n  - Add HTML representation hook to DataFrame for the IPython HTML notebook\n    (:issue:`773`)\n  - Support for reading Excel 2007 XML documents using openpyxl\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n  - Improve performance and memory usage of fillna on DataFrame\n  - Can concatenate a list of Series along axis=1 to obtain a DataFrame (:issue:`787`)\n\n\n\n.. _whatsnew_0.7.1.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v0.7.0..v0.7.1\n", "1.3.3": ".. _whatsnew_133:\n\nWhat's new in 1.3.3 (September 12, 2021)\n----------------------------------------\n\nThese are the changes in pandas 1.3.3. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_133.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :class:`DataFrame` constructor failing to broadcast for defined :class:`Index` and len one list of :class:`Timestamp` (:issue:`42810`)\n- Fixed regression in :meth:`.DataFrameGroupBy.agg` and :meth:`.SeriesGroupBy.agg` incorrectly raising in some cases (:issue:`42390`)\n- Fixed regression in :meth:`.DataFrameGroupBy.apply` and :meth:`.SeriesGroupBy.apply` where ``nan`` values were dropped even with ``dropna=False`` (:issue:`43205`)\n- Fixed regression in :meth:`.DataFrameGroupBy.quantile` and :meth:`.SeriesGroupBy.quantile` which were failing with ``pandas.NA`` (:issue:`42849`)\n- Fixed regression in :meth:`merge` where ``on`` columns with ``ExtensionDtype`` or ``bool`` data types were cast to ``object`` in ``right`` and ``outer`` merge (:issue:`40073`)\n- Fixed regression in :meth:`RangeIndex.where` and :meth:`RangeIndex.putmask` raising ``AssertionError`` when result did not represent a :class:`RangeIndex` (:issue:`43240`)\n- Fixed regression in :meth:`read_parquet` where the ``fastparquet`` engine would not work properly with fastparquet 0.7.0 (:issue:`43075`)\n- Fixed regression in :meth:`DataFrame.loc.__setitem__` raising ``ValueError`` when setting array as cell value (:issue:`43422`)\n- Fixed regression in :func:`is_list_like` where objects with ``__iter__`` set to ``None`` would be identified as iterable (:issue:`43373`)\n- Fixed regression in :meth:`DataFrame.__getitem__` raising error for slice of :class:`DatetimeIndex` when index is non monotonic (:issue:`43223`)\n- Fixed regression in :meth:`.Resampler.aggregate` when used after column selection would raise if ``func`` is a list of aggregation functions (:issue:`42905`)\n- Fixed regression in :meth:`DataFrame.corr` where Kendall correlation would produce incorrect results for columns with repeated values (:issue:`43401`)\n- Fixed regression in :meth:`DataFrame.groupby` where aggregation on columns with object types dropped results on those columns (:issue:`42395`, :issue:`43108`)\n- Fixed regression in :meth:`Series.fillna` raising ``TypeError`` when filling ``float`` ``Series`` with list-like fill value having a dtype which couldn't cast lostlessly (like ``float32`` filled with ``float64``) (:issue:`43424`)\n- Fixed regression in :func:`read_csv` raising ``AttributeError`` when the file handle is an ``tempfile.SpooledTemporaryFile`` object (:issue:`43439`)\n- Fixed performance regression in :meth:`core.window.ewm.ExponentialMovingWindow.mean` (:issue:`42333`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_133.performance:\n\nPerformance improvements\n~~~~~~~~~~~~~~~~~~~~~~~~\n- Performance improvement for :meth:`DataFrame.__setitem__` when the key or value is not a :class:`DataFrame`, or key is not list-like (:issue:`43274`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_133.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Fixed bug in :meth:`.DataFrameGroupBy.agg` and :meth:`.DataFrameGroupBy.transform` with ``engine=\"numba\"`` where ``index`` data was not being correctly passed into ``func`` (:issue:`43133`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_133.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.3.2..v1.3.3\n", "2.2.2": ".. _whatsnew_222:\n\nWhat's new in 2.2.2 (April 10, 2024)\n---------------------------------------\n\nThese are the changes in pandas 2.2.2. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_220.np2_compat:\n\nPandas 2.2.2 is now compatible with numpy 2.0\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPandas 2.2.2 is the first version of pandas that is generally compatible with the upcoming\nnumpy 2.0 release, and wheels for pandas 2.2.2 will work with both numpy 1.x and 2.x.\n\nOne major caveat is that arrays created with numpy 2.0's new ``StringDtype`` will convert\nto ``object`` dtyped arrays upon :class:`Series`/:class:`DataFrame` creation.\nFull support for numpy 2.0's StringDtype is expected to land in pandas 3.0.\n\nAs usual please report any bugs discovered to our `issue tracker <https://github.com/pandas-dev/pandas/issues/new/choose>`_\n\n.. _whatsnew_222.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- :meth:`DataFrame.__dataframe__` was producing incorrect data buffers when the a column's type was a pandas nullable on with missing values (:issue:`56702`)\n- :meth:`DataFrame.__dataframe__` was producing incorrect data buffers when the a column's type was a pyarrow nullable on with missing values (:issue:`57664`)\n- Avoid issuing a spurious ``DeprecationWarning`` when a custom :class:`DataFrame` or :class:`Series` subclass method is called (:issue:`57553`)\n- Fixed regression in precision of :func:`to_datetime` with string and ``unit`` input (:issue:`57051`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_222.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- :meth:`DataFrame.__dataframe__` was producing incorrect data buffers when the column's type was nullable boolean (:issue:`55332`)\n- :meth:`DataFrame.__dataframe__` was showing bytemask instead of bitmask for ``'string[pyarrow]'`` validity buffer (:issue:`57762`)\n- :meth:`DataFrame.__dataframe__` was showing non-null validity buffer (instead of ``None``) ``'string[pyarrow]'`` without missing values (:issue:`57761`)\n- :meth:`DataFrame.to_sql` was failing to find the right table when using the schema argument (:issue:`57539`)\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_222.other:\n\nOther\n~~~~~\n-\n\n.. ---------------------------------------------------------------------------\n.. _whatsnew_222.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v2.2.1..v2.2.2|HEAD\n", "1.2.5": ".. _whatsnew_125:\n\nWhat's new in 1.2.5 (June 22, 2021)\n-----------------------------------\n\nThese are the changes in pandas 1.2.5. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_125.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed regression in :func:`concat` between two :class:`DataFrame` where one has an :class:`Index` that is all-None and the other is :class:`DatetimeIndex` incorrectly raising (:issue:`40841`)\n- Fixed regression in :meth:`DataFrame.sum` and :meth:`DataFrame.prod` when ``min_count`` and ``numeric_only`` are both given (:issue:`41074`)\n- Fixed regression in :func:`read_csv` when using ``memory_map=True`` with an non-UTF8 encoding (:issue:`40986`)\n- Fixed regression in :meth:`DataFrame.replace` and :meth:`Series.replace` when the values to replace is a NumPy float array (:issue:`40371`)\n- Fixed regression in :func:`ExcelFile` when a corrupt file is opened but not closed (:issue:`41778`)\n- Fixed regression in :meth:`DataFrame.astype` with ``dtype=str`` failing to convert ``NaN`` in categorical columns (:issue:`41797`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_125.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.2.4..v1.2.5|HEAD\n", "1.5.1": ".. _whatsnew_151:\n\nWhat's new in 1.5.1 (October 19, 2022)\n--------------------------------------\n\nThese are the changes in pandas 1.5.1. See :ref:`release` for a full changelog\nincluding other versions of pandas.\n\n{{ header }}\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_151.groupby_categorical_regr:\n\nBehavior of ``groupby`` with categorical groupers (:issue:`48645`)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn versions of pandas prior to 1.5, ``groupby`` with ``dropna=False`` would still drop\nNA values when the grouper was a categorical dtype. A fix for this was attempted in\n1.5, however it introduced a regression where passing ``observed=False`` and\n``dropna=False`` to ``groupby`` would result in only observed categories. It was found\nthat the patch fixing the ``dropna=False`` bug is incompatible with ``observed=False``,\nand decided that the best resolution is to restore the correct ``observed=False``\nbehavior at the cost of reintroducing the ``dropna=False`` bug.\n\n.. ipython:: python\n\n   df = pd.DataFrame(\n       {\n           \"x\": pd.Categorical([1, None], categories=[1, 2, 3]),\n           \"y\": [3, 4],\n       }\n   )\n   df\n\n*1.5.0 behavior*:\n\n.. code-block:: ipython\n\n   In [3]: # Correct behavior, NA values are not dropped\n           df.groupby(\"x\", observed=True, dropna=False).sum()\n   Out[3]:\n        y\n   x\n   1    3\n   NaN  4\n\n\n   In [4]: # Incorrect behavior, only observed categories present\n           df.groupby(\"x\", observed=False, dropna=False).sum()\n   Out[4]:\n        y\n   x\n   1    3\n   NaN  4\n\n\n*1.5.1 behavior*:\n\n.. ipython:: python\n\n   # Incorrect behavior, NA values are dropped\n   df.groupby(\"x\", observed=True, dropna=False).sum()\n\n   # Correct behavior, unobserved categories present (NA values still dropped)\n   df.groupby(\"x\", observed=False, dropna=False).sum()\n\n.. _whatsnew_151.regressions:\n\nFixed regressions\n~~~~~~~~~~~~~~~~~\n- Fixed Regression in :meth:`Series.__setitem__` casting ``None`` to ``NaN`` for object dtype (:issue:`48665`)\n- Fixed Regression in :meth:`DataFrame.loc` when setting values as a :class:`DataFrame` with all ``True`` indexer (:issue:`48701`)\n- Regression in :func:`.read_csv` causing an ``EmptyDataError`` when using an UTF-8 file handle that was already read from (:issue:`48646`)\n- Regression in :func:`to_datetime` when ``utc=True`` and ``arg`` contained timezone naive and aware arguments raised a ``ValueError`` (:issue:`48678`)\n- Fixed regression in :meth:`DataFrame.loc` raising ``FutureWarning`` when setting an empty :class:`DataFrame` (:issue:`48480`)\n- Fixed regression in :meth:`DataFrame.describe` raising ``TypeError`` when result contains ``NA`` (:issue:`48778`)\n- Fixed regression in :meth:`DataFrame.plot` ignoring invalid ``colormap`` for ``kind=\"scatter\"`` (:issue:`48726`)\n- Fixed regression in :meth:`MultiIndex.values` resetting ``freq`` attribute of underlying :class:`Index` object (:issue:`49054`)\n- Fixed performance regression in :func:`factorize` when ``na_sentinel`` is not ``None`` and ``sort=False`` (:issue:`48620`)\n- Fixed regression causing an ``AttributeError`` during warning emitted if the provided table name in :meth:`DataFrame.to_sql` and the table name actually used in the database do not match (:issue:`48733`)\n- Fixed regression in :func:`to_datetime` when ``arg`` was a date string with nanosecond and ``format`` contained ``%f`` would raise a ``ValueError`` (:issue:`48767`)\n- Fixed regression in :func:`testing.assert_frame_equal` raising for :class:`MultiIndex` with :class:`Categorical` and ``check_like=True`` (:issue:`48975`)\n- Fixed regression in :meth:`DataFrame.fillna` replacing wrong values for ``datetime64[ns]`` dtype and ``inplace=True`` (:issue:`48863`)\n- Fixed :meth:`.DataFrameGroupBy.size` not returning a Series when ``axis=1`` (:issue:`48738`)\n- Fixed Regression in :meth:`.DataFrameGroupBy.apply` when user defined function is called on an empty dataframe (:issue:`47985`)\n- Fixed regression in :meth:`DataFrame.apply` when passing non-zero ``axis`` via keyword argument (:issue:`48656`)\n- Fixed regression in :meth:`Series.groupby` and :meth:`DataFrame.groupby` when the grouper is a nullable data type (e.g. :class:`Int64`) or a PyArrow-backed string array, contains null values, and ``dropna=False`` (:issue:`48794`)\n- Fixed performance regression in :meth:`Series.isin` with mismatching dtypes (:issue:`49162`)\n- Fixed regression in :meth:`DataFrame.to_parquet` raising when file name was specified as ``bytes`` (:issue:`48944`)\n- Fixed regression in :class:`ExcelWriter` where the ``book`` attribute could no longer be set; however setting this attribute is now deprecated and this ability will be removed in a future version of pandas (:issue:`48780`)\n- Fixed regression in :meth:`DataFrame.corrwith` when computing correlation on tied data with ``method=\"spearman\"`` (:issue:`48826`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_151.bug_fixes:\n\nBug fixes\n~~~~~~~~~\n- Bug in :meth:`Series.__getitem__` not falling back to positional for integer keys and boolean :class:`Index` (:issue:`48653`)\n- Bug in :meth:`DataFrame.to_hdf` raising ``AssertionError`` with boolean index (:issue:`48667`)\n- Bug in :func:`testing.assert_index_equal` for extension arrays with non matching ``NA`` raising ``ValueError`` (:issue:`48608`)\n- Bug in :meth:`DataFrame.pivot_table` raising unexpected ``FutureWarning`` when setting datetime column as index (:issue:`48683`)\n- Bug in :meth:`DataFrame.sort_values` emitting unnecessary ``FutureWarning`` when called on :class:`DataFrame` with boolean sparse columns (:issue:`48784`)\n- Bug in :class:`.arrays.ArrowExtensionArray` with a comparison operator to an invalid object would not raise a ``NotImplementedError`` (:issue:`48833`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_151.other:\n\nOther\n~~~~~\n- Avoid showing deprecated signatures when introspecting functions with warnings about arguments becoming keyword-only (:issue:`48692`)\n\n.. ---------------------------------------------------------------------------\n\n.. _whatsnew_151.contributors:\n\nContributors\n~~~~~~~~~~~~\n\n.. contributors:: v1.5.0..v1.5.1\n"}